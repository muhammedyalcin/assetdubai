(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["module", "exports", "../core/Actor", "@smartface/styler/lib/utils/merge"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require("../core/Actor"), require("@smartface/styler/lib/utils/merge"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.Actor, global.merge);
    global.Stylable = mod.exports;
  }
})(this, function (module, exports, _Actor2, _merge) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = makeStylable;

  var _Actor3 = _interopRequireDefault(_Actor2);

  var _merge2 = _interopRequireDefault(_merge);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  // TODO create new jsdoc type for the parameter
  /**
   * Styleable Actor HOC. Decorates specifeid component and return an actor component
   * 
   * @param {object} component - A component to decorate
   * @param {string} className - initial className for actor
   * @param {function} hooks - context's hooks dispatcher
   * 
   * @returns {Object} - A Stylable Actor
   */
  function makeStylable(_ref) {
    var component = _ref.component,
        _ref$classNames = _ref.classNames,
        classNames = _ref$classNames === undefined ? "" : _ref$classNames,
        _ref$userStyle = _ref.userStyle,
        userStyle = _ref$userStyle === undefined ? {} : _ref$userStyle,
        name = _ref.name;

    var initialClassNames = classNames && classNames.split(" ") || [];
    userStyle = (0, _merge2.default)(userStyle);

    /**
     * Styable actor
     * @class
     */
    return new (function (_Actor) {
      _inherits(Stylable, _Actor);

      function Stylable() {
        _classCallCheck(this, Stylable);

        var _this = _possibleConstructorReturn(this, _Actor.call(this, component, name));

        _this.getUserStyle = function () {
          return (0, _merge2.default)(userStyle);
        };

        _this.updateUserStyle = function (props) {
          userStyle = (0, _merge2.default)(userStyle, props);
          _this.isDirty = true;
        };

        _this.reset = function () {
          _this.setStyles(_this.getStyles(), true);
        };

        _this.setUserStyle = function (props) {
          if (typeof props === 'function') {
            userStyle = props(_this.getUserStyle());
          } else {
            userStyle = (0, _merge2.default)(props);
          }

          _this.isDirty = true;
        };

        _this.setStyles = function (style) {
          var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          var reduceDiffStyleHook = _this.hook("reduceDiffStyleHook");
          style = (0, _merge2.default)(style, userStyle);
          var diffReducer = reduceDiffStyleHook ? reduceDiffStyleHook(_this.styles || {}, style) : function (acc, key) {
            if (_this.styles[key] !== undefined) {
              if (_this.styles[key] !== style[key]) {
                acc[key] = style[key];
              } else {
                acc[key] = style[key];
              }
            }

            return acc;
          };

          var rawDiff = !force ? Object.keys(style).reduce(diffReducer, {}) : (0, _merge2.default)(style);

          var beforeHook = _this.hook("beforeStyleDiffAssign");
          var diff = beforeHook && beforeHook(rawDiff) || null;
          var comp = name.indexOf("_") === -1 && _this._actorInternal_.component.layout ? _this._actorInternal_.component.layout : _this._actorInternal_.component;
          var hasDiff = diff !== null && Object.keys(diff).length > 0;

          //TODO: extract all specified area @cenk
          // ------------->

          var componentObjectProps = {
            "android": {},
            "ios": {},
            "layout": {}
          };

          var SCW_LAYOUT_PROPS = {
            "alignContent": "alignContent",
            "alignItems": "alignItems",
            "direction": "direction",
            "flexDirection": "flexDirection",
            "justifyContent": "justifyContent",
            "flexWrap": "flexWrap",
            "paddingLeft": "paddingLeft",
            "paddingTop": "paddingTop",
            "paddingRight": "paddingRight",
            "paddingBottom": "paddingBottom",
            "marginRight": "marginRight",
            "marginLeft": "marginLeft",
            "marginTop": "marginTop",
            "marginBottom": "marginBottom",
            "layoutHeight": "height",
            "layoutWidth": "width",
            "backgroundColor": "backgroundColor"
          };

          function componentAssign(component, key, value) {
            if (value !== null && value instanceof Object && componentObjectProps[key]) {
              Object.keys(value).forEach(function (k) {
                return componentAssign(component[key], k, value[k]);
              });
            } else {
              component[key] = value;
            }
          }

          typeof component.subscribeContext === "function" ? hasDiff && component.subscribeContext({ type: "new-styles", style: Object.assign({}, diff), rawStyle: (0, _merge2.default)(rawDiff) }) : hasDiff && Object.keys(diff).forEach(function (key) {
            try {
              if (component.layout && SCW_LAYOUT_PROPS[key]) {
                componentAssign(component.layout, SCW_LAYOUT_PROPS[key], diff[key]);
              } else {
                componentAssign(component, key, diff[key]);
              }
            } catch (e) {
              throw new Error(key + " has invalid value " + JSON.stringify(style[key]) + " " + e.message);
            }
          });
          // <-------------------

          var afterHook = _this.hook("afterStyleDiffAssign");
          afterHook && (style = afterHook(style));

          _this.styles = style;
        };

        _this.getStyles = function () {
          return _this.styles ? Object.assign({}, _this.styles) : {};
        };

        _this.getClassName = function () {
          return _this.classNames.join(" ");
        };

        _this.classNamesCount = function () {
          return _this.classNames.length;
        };

        _this.removeClassName = function (className) {
          if (_this.hasClassName(className)) {
            _this.isDirty = true;
            _this.classNames = _this.classNames.filter(function (cname) {
              return cname !== className;
            });
          }

          return _this.getClassName();
        };

        _this.resetClassNames = function () {
          var classNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          _this.classNames = [].concat(initialClassNames, classNames);
          _this.isDirty = true;
        };

        _this.hasClassName = function (className) {
          return _this.classNames.some(function (cname) {
            return cname === className;
          });
        };

        _this.pushClassNames = function (classNames) {
          if (!_this.hasClassName(classNames)) {
            Array.isArray(classNames) ? _this.classNames = [].concat(_this.classNames, classNames) : _this.classNames.push(classNames);

            _this.isDirty = true;
          }

          return _this.getClassName();
        };

        _this.addClassName = function (className, index) {
          if (!_this.hasClassName(className)) {
            _this.classNames.splice(index, 1, className);
            _this.isDirty = true;
          }

          return _this.getClassName();
        };

        _this.dispose = function () {
          _this._actorInternal_.component = null;
          _this._actorInternal_ = null;
          _this.context = null;
          _this.styles = null;
          component.dispatch = null;
          component.onDispose && component.onDispose();
        };

        _this.classNames = [].concat(initialClassNames);
        _this.styles = {};
        _this.inlinestyles = {};
        _this.isDirty = true;
        return _this;
      }

      /**
       * Sets styles
       *
       * @param {object} styles - a style object
       */


      Stylable.prototype.getInitialClassName = function getInitialClassName() {
        return initialClassNames;
      };

      return Stylable;
    }(_Actor3.default))();
  }
  module.exports = exports["default"];
});