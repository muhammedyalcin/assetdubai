(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["module", "exports", "./utils/styleAssign", "./utils/merge", "./utils/findClassNames"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require("./utils/styleAssign"), require("./utils/merge"), require("./utils/findClassNames"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.styleAssign, global.merge, global.findClassNames);
    global.memoizeStyler = mod.exports;
  }
})(this, function (module, exports, _styleAssign, _merge, _findClassNames) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = memoizeStyler;

  var _merge2 = _interopRequireDefault(_merge);

  var _findClassNames2 = _interopRequireDefault(_findClassNames);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  /**
   * Memoize Pattern implementation for Styler. Decorates a styler function 
   * and caches every request then returns styles from the cache.
   * 
   * @param {function} styling - Styling function
   * @returns {function} - Styling composer
   */
  function memoizeStyler(styling) {
    var memory = {};

    /**
     * Gets styles from styler then caches them using className as a key
     * 
     * @param {string} classNames - Classnames string
     * @returns {function | Object} - If classnames exists then return styles composer if not returns the cache's deep copy.
     */
    return function (classNames) {
      if (classNames) {
        var styles = styling(classNames);
        var parsedClassNames = (0, _findClassNames2.default)(classNames).map(function (classNm) {
          return classNm.join("");
        });

        if (!memory[classNames]) {
          memory[classNames] = {};
          styles(function (className, key, value) {
            if (!memory[className]) {
              memory[className] = memory[className] || {};
              memory[className][key] = value;
            };
            memory[classNames][key] = value;
          });
        }
      }

      var style = classNames ? (0, _merge2.default)(memory[classNames]) : (0, _merge2.default)(memory);

      /**
       * Styles mapping function, get styles from styler or cache if exists then calls fn and pass style.
       *
       * @param {function} fn - Map function
       * @returns {Object} - Styles
       */
      return function () {
        var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (typeof fn === 'function') {
          Object.keys(style).forEach(function (key) {
            return fn(classNames, key, style[key]);
          });
        }

        // returns deep copy of styles from cache
        return style;
      };
    };
  }
  module.exports = exports["default"];
});