(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["module", "exports", "./styleAssign", "./merge", "../constants"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require("./styleAssign"), require("./merge"), require("../constants"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.styleAssign, global.merge, global.constants);
    global.styleDenormalizer = mod.exports;
  }
})(this, function (module, exports, _styleAssign, _merge, _constants) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = styleDenormalizer;

  var _merge2 = _interopRequireDefault(_merge);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function flat(styles) {
    var denormalizedStyles = {};
    var commands = {};
    var runtimeCommands = {};
    var parentIndex = 0;

    function flatStyle(style, key) {
      var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

      Object.keys(style[key]).forEach(function (skey) {
        var newKey = key;

        if (key.charAt(0) === _constants.CHILD_CLASS) {
          newKey = key.slice(1);
        }

        switch (skey.charAt(0)) {
          case _constants.RUNTIME_COMMAND:
            var currentClass = parent + newKey;
            runtimeCommands[currentClass] = runtimeCommands[currentClass] || [];
            runtimeCommands[currentClass].push({
              type: skey.slice(0, skey.indexOf(":")),
              args: skey.slice(skey.indexOf(":") + 1),
              className: parent + newKey,
              value: style[key][skey]
            });

            delete style[key][skey];
            break;
          case _constants.COMMAND:
            commands[skey] = commands[skey] || [];
            var newCommand = {
              className: parent + newKey,
              value: style[key][skey]
            };

            if (parent === "") {
              commands[skey].splice(parentIndex, 0, newCommand);
              parentIndex = commands[skey].length;
            } else {
              commands[skey].splice(parentIndex, 0, newCommand);
            }

            delete style[key][skey];
            break;
          case _constants.CLASSNAME:
          case _constants.ID:
          case _constants.CHILD_CLASS:
            flatStyle(style[key], skey, parent + newKey);

            break;
          default:
            denormalizedStyles[parent + newKey] = denormalizedStyles[parent + newKey] || {};

            // if current is className then merge with parent
            if (parent && denormalizedStyles[parent] && key.charAt(0) === _constants.CLASSNAME) {
              denormalizedStyles[parent + newKey] = (0, _merge2.default)(denormalizedStyles[parent], denormalizedStyles[parent + newKey]);
            }

            (0, _styleAssign.styleAssign)(denormalizedStyles[parent + newKey], skey, style[key][skey]);
        }
      });
    }

    Object.keys(styles).forEach(function (key, index) {
      flatStyle(styles, key);
    });

    return {
      styles: denormalizedStyles,
      commands: commands,
      runtimeCommands: runtimeCommands
    };
  }

  function flatStyles(styles) {
    return styles.map(function (style) {
      return flat((0, _merge2.default)(style));
    });
  }

  function styleDenormalizer() {
    var styles = Array.prototype.slice.call(arguments);
    return flatStyles(styles);
  };
  module.exports = exports["default"];
});