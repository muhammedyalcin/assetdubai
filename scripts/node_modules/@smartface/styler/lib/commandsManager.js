(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["module", "exports", "./utils/merge"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require("./utils/merge"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.merge);
    global.commandsManager = mod.exports;
  }
})(this, function (module, exports, _merge) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _merge2 = _interopRequireDefault(_merge);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function extend(styles, className, extendFrom, runtimeCommands) {
    if (extendFrom === null || extendFrom === undefined) throw new TypeError("Classname: " + className + " must not have empty extending class");

    var classNamePattern = new RegExp("\\" + className + "[\\.]+");
    var extendeds = extendFrom.split(",");
    var superStyles = {};
    // console.log(classN, " :: ", styles[classN])
    extendeds.forEach(function (extend) {
      superStyles = (0, _merge2.default)(superStyles, styles[extend]);
      // merge if extended className has runtime commands
      if (runtimeCommands && runtimeCommands[extend]) {
        runtimeCommands[className] = runtimeCommands[className] || [];
        //override extended className commands
        runtimeCommands[className] = runtimeCommands[extend].map(function (item) {
          return (0, _merge2.default)(item);
        }).concat(runtimeCommands[className].map(function (obj) {
          return (0, _merge2.default)(obj);
        }));
      }
    });

    styles[className] = (0, _merge2.default)(superStyles, styles[className]);

    Object.keys(styles).forEach(function (classN) {
      if (classNamePattern.test(classN)) {
        styles[classN] = (0, _merge2.default)(styles[className], styles[classN]);
      }
    });

    return styles;
  }

  function extendAll(styles, className, extendFrom) {
    var extendeds = extendFrom.split(",");
    var extendingClassNamePattern = new RegExp("\\" + extendFrom + "\\W+");

    Object.keys(styles).forEach(function (classN) {
      if (classN === extendFrom || extendingClassNamePattern.test(classN)) {
        // console.log(classN, " :: ", styles[classN])
        styles[classN.replace(extendFrom, className)] = (0, _merge2.default)(styles[classN], styles[className]);
      }
    });

    return styles;
  }

  function findCommnand(command) {
    switch (command) {
      case '@extend':
        return extend;
      case '@extend*':
        return extendAll;
    }
  }

  var commands = [findCommnand];
  var runtimeCommands = [];

  exports.default = {
    addCommandFactory: function addCommandFactory(commandFactory) {
      commands.push(commandFactory);
    },
    addRuntimeCommandFactory: function addRuntimeCommandFactory(commandFactory) {
      runtimeCommands.push(commandFactory);
    },
    getCommands: function getCommands() {
      return commands.concat();
    },
    getRuntimeCommands: function getRuntimeCommands() {
      return runtimeCommands.concat();
    }
  };
  module.exports = exports["default"];
});