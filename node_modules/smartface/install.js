"use strict"
var os = require('os');
var https = require('https');
var fs = require('fs');
var path = require('path');

const ProgressInfo = require('./lib/progressinfo.js');

var ENV = process.env;
var PLATFORM = os.platform();
var TMP_ROOT = os.tmpdir() + '/smartface-install/';

const ZIP_ALING = {
	"win32": "zipalign-win32.exe",
	"linux": "zipalign-linux",
	"darwin": "zipalign-darwin"
};

if (process.env.npm_lifecycle_event === 'preuninstall') {
	handlePreUninstall();
}
else if (process.env.npm_lifecycle_event === 'postinstall') {
	handlePostInstall();
}


function handlePreUninstall() {
	setupBashCompletion("uninstall", function(err, res) {
		!err && console.log(res);
	});
}

function handlePostInstall() {
	var packageJson = require('./package.json');
	var filesToDownload = getDownloadFilesFromPackageJsonObject(packageJson);

	setupBashCompletion("install", function(err, res) {
		!err && console.log(res + "\n");
		downloadFiles(filesToDownload, path.join(__dirname, 'bin/'), function() {
			console.log('All required files are downloaded\n');
			fs.readdir(TMP_ROOT, function(err, files) {
				if (err) {
					return;
				}
				files.forEach(function(fileName) {
					fs.unlink(path.join(TMP_ROOT, fileName));
				});
			});
			fs.chmodSync(path.join(__dirname, "bin", ZIP_ALING[PLATFORM]), 511);
		});
	});
}

function downloadFiles(urls, dest, done) {
	var url = null;
	var maxLen = findMaxLength();

	next();

	function next() {
		if (urls.length === 0) {
			return done();
		}
		url = urls.pop();
		var basename = path.basename(url);
		downloadFile(url, dest + basename, maxLen, callback);
	}

	function callback(err) {
		if (err) {
			console.log('There was an error downloading a required file: ' + url);
		}
		next();
	}

	function findMaxLength() {
		var len = 0;
		urls.forEach(function(item) {
			item = path.basename(item);
			if (len < item.length) {
				len = item.length;
			}
		});
		return len;
	}
}

function downloadFile(url, dest, maxLen, cb) {
	var file = fs.createWriteStream(dest);
	https.get(url, function(response) {
		var contentLength = response.headers["content-length"];
		response.pipe(file);
		file.on('finish', function() {
			file.close(function(err) {
				if (err) {
					cb(err);
				}
				else if (!contentLength) {
					cb(null);
				}
			});
		});

		if (contentLength) {
			var fname = path.basename(dest);
			var proginfo = new ProgressInfo(Number(contentLength),
				"Downloading " + fname + " ".repeat((maxLen + 2) - fname.length),
				ProgressInfo.writer);
			proginfo.start();
			proginfo.onFinish = cb;
			response.on("data", function(chunk) {
				proginfo.update(chunk.length);
			});
		}

	}).on('error', function(err) {
		fs.unlink(dest);
		if (cb) {
			cb(err);
		}
	});
}
/*
downloadFile("https://az793023.vo.msecnd.net/smartface-bin/runtime/5.3.1.0-cli-153/SmartfacePlayer.zip",
	"/home/ubuntu/workspace/ali.zip");
*/

/*
function moveAllFilesToNewRoot(files, newRoot) {
	for (var i = 0; i < files.length; i++) {
		var file = files[i];
		var basename = path.basename(file);
		moveIfExists(file, path.normalize(path.join(newRoot, basename)));
	}
}

function moveIfExists(file, newPath) {
	if (fs.existsSync(file)) {
		try {
			fs.renameSync(file, newPath);
		}
		catch (e) {
			// If 'file' and 'newPath' are on different devices renaming is not
			// working, file should
			fse.move(file, newPath, {
				mkdirp: true,
				clobber: true
			}, function(err) {});
		}
		return true;
	}
	else {
		return false;
	}
}

function getFilesWithNewRoot(files, newRoot) {
	var new_files = [];
	for (var i = 0; i < files.length; i++) {
		var file = files[i];
		var basename = path.basename(file);
		new_files.push(path.join(newRoot, basename));
	}
	return new_files;
}
*/

function getDownloadFilesFromPackageJsonObject(obj) {
	if (!obj) {
		return [];
	}
	var downloadFiles = [];
	var meta = obj.smartface_meta.binaries;
	var keys = Object.keys(meta);
	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		if (key === 'zipalign') {
			continue;
		}
		downloadFiles.push(meta[key]);
	}
	downloadFiles.push(meta.zipalign[PLATFORM]);
	return downloadFiles;
}

function setupBashCompletion(phaseInstallOrUninstall, callback) {

	if ((PLATFORM !== "win32") && process.env.SHELL) {
		const setup = require('./lib/autocomplete');
		if (phaseInstallOrUninstall === "install") {
			setup.install(callback);
		}
		else {
			setup.uninstall(callback);
		}
	}
	else {
		callback(null, "Autocomplete has not been installed.");
	}
}
