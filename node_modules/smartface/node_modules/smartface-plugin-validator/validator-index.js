const fs = require("fs");
const path = require("path");

const jsonlint = require("jsonlint");
const JSZip = require("jszip");
const _ = require("lodash");
const validate = require("validate-npm-package-name");

const OS = {
    ios: "iOS",
    android: "Android"
};

const basicPkgJSON = {
    iOS: {
        "name": "icloudios",
        "version": "1.0.0",
        "os": "iOS",
        "cpu": [
            "ARM",
            "ARM64"
        ],
        "zipFiles": [
            "icloudios.zip"
        ]
    },
    Android: {
        "name": "smfparse",
        "version": "1.0.0",
        "os": "Android",
        "cpu": ["ARM", "x86"]
    }
};



/**
 * validates plugin.zip
 * @function
 * @param {Object} _pluginPath - (required) plugin.zip file path
 * @param {string} _os - (required) ios, android
 * @param {string} _wsPath - (optional) workspace directory for reletive path in results.
 * @return {Promise} promise of result.
 */
function smartfacePluginNValidator(_pluginPath, _os, _wsPath) {
    var pluginPath, os, packageJSON = null,
        zip = null,
        result = {
            packageJSON: {
                missingProperties: [],
                parse: null
            },
            missingFiles: [],
            error: false
        };
    os = _os.toLowerCase();

    if (_wsPath) {
        pluginPath = path.relative(_wsPath, _pluginPath);
    }
    else {
        pluginPath = _pluginPath;
    }

    return new Promise(function(resolve, reject) {

        if (!OS[os]) {
            return reject(result("Invalid os -> " + os + "\n\You can only use one of these -> iOS, Android"));
        }

        init().then(function(res) {
            parsePackageJSON().then(function(resPkg) {
                packageJSONValidator();
                checkMissingFiles();
                collectError();
                resolve(result);
            }, function(err) {
                reject(err);
            });
        }, function(err) {
            reject(err);
        });

    });

    /**
     * @private
     * does initalizations 
     * @return {Promise} promise.
     */
    function init() {
        return new Promise(function(resolve, reject) {
            if (!zip) {
                zip = new JSZip();
                fs.readFile(_pluginPath, (err, data) => {
                    if (err) {
                        return reject(err);
                    }
                    zip.loadAsync(data).then(function(res) {
                        resolve(res);
                    }, function(err) {
                        reject(err);
                    });
                });
            }
            else {
                resolve(zip);
            }
        });
    }
    /**
     * try parse package.json if it is exists.
     * @function parsePackageJSON
     * @private
     * parse package.json
     * @return {Promise} promise.
     */
    function parsePackageJSON() {
        var pkg = zip.file("package.json");

        return new Promise(function(resolve, reject) {
            if (pkg) {
                pkg.async("string").then(function(res) {
                    try {
                        packageJSON = jsonlint.parse(res);
                        resolve(packageJSON);
                    }
                    catch (e) {
                        result.packageJSON.parse = e;
                        packageJSON = {};
                        resolve(e);
                    }
                }, function(err) {
                    reject(err);
                });
            }
            else {
                packageJSON = {};
                result.missingFiles.push("package.json");
                resolve("package.json not found !");
            }
        });
    }

    /**
     * validates package.json file
     * @function packageJSONValidator
     * @private
     */
    function packageJSONValidator() {
        var keys = Object.keys(basicPkgJSON[OS[os]]);
        var temp;
        keys.forEach(function(item, index) {
            temp = packageJSON[item];
            if (_.isUndefined(temp)) {
                result.packageJSON.missingProperties.push("missing property -> " + item);
            }
            else if ((item === "zipFiles") && (os === "ios")) {
                if (typeof temp === "string") {
                    packageJSON.zipFiles = [temp];
                }
                else if (!_.isArray(temp)) {
                    result.packageJSON.missingProperties.push("'zipFiles' must be an Array or string. -> " + temp);
                }
            }
            else if (item === "cpu") {
                if (!_.isArray(temp)) {
                    result.packageJSON.missingProperties.push("'cpu' must be an Array. -> " + temp);
                }
                else if (os === "ios") {
                    if (temp.length !== 2) {
                        result.packageJSON.missingProperties.push("length of 'cpu' must be equal 2 -> " + temp.length);
                    }
                    _.each(temp, function(cpu_item) {
                        if (basicPkgJSON.iOS.cpu.indexOf(cpu_item) === -1) {
                            result.packageJSON.missingProperties.push("'cpu' element must be one of [" +
                                basicPkgJSON.iOS.cpu.join(",") +
                                "]. Incorrect element for cpu -> " + cpu_item);
                        }
                    });
                }
                else if (os === "android") {
                    if ((temp.length === 0) || (temp.length > 2)) {
                        result.packageJSON.missingProperties.push("length of 'cpu' must be greater than 0 or less than 3 -> " + temp.length);
                    }
                    _.each(temp, function(cpu_item) {
                        if (basicPkgJSON.Android.cpu.indexOf(cpu_item) === -1) {
                            result.packageJSON.missingProperties.push("'cpu' element must be one of [" +
                                basicPkgJSON.Android.cpu.join(",") +
                                "]. Incorrect element for cpu -> " + cpu_item);
                        }
                    });
                }
            }
            else if (item === "os") {
                if (temp !== OS[os]) {
                    result.packageJSON.missingProperties.push("incorrect 'os' -> " + temp);
                }
            }
            else if (item === "version") {
                // 1-3 dot-sperated components.
                if (!(/^(\d+\.)?(\d+\.)?(\*|\d+)$/.test(temp))) {
                    result.packageJSON.missingProperties.push("'version' format must be as 1-3 dot-sperated components. Incorrect 'version' format -> " + temp);
                }
            }
            else if (item === "name") {
                var resValidation = validate(temp);
                if (resValidation.results || resValidation.warnings) {
                    var res = [];
                    resValidation.results && (res = res.concat(resValidation.results));
                    resValidation.warnings && (res = res.concat(resValidation.warnings));
                    result.packageJSON.missingProperties.push("Incorrect 'name' format -> " + temp +
                        "\n\t\t - " + res.join("\n\t\t - "));
                }
            }
            //TODO more validator for Android.
        });
    }

    /**
     * @function checkMissingFiles
     * check missing that required files
     */
    function checkMissingFiles() {
        var missingFiles = result.missingFiles;
        if (os === "ios") {
            if (packageJSON.zipFiles) {
                _.each(packageJSON.zipFiles, function(item) {
                    zip.file(item) || (missingFiles.push(item));
                });
            }
            zip.file("project.pbxproj") || (missingFiles.push("project.pbxproj"));
            zip.file("SmartfaceAppDelegate.mm") || (missingFiles.push("SmartfaceAppDelegate.mm"));
        }
        else {
            //TODO for android
        }
    }
    /**
     * collects all errors in one Array.
     * @function collectError
     * @private
     * check missing that required files
     */
    function collectError() {
        var res = [];
        if (result.missingFiles.length > 0) {
            result.error = true;
            result.missingFiles = result.missingFiles.map(function(item) {
                return "missing " + path.join(pluginPath, item) + " file.";
            });
        }
        if (result.packageJSON.missingProperties.length > 0 || result.packageJSON.parse) {
            result.error = true;
            result.packageJSON.parse && (res[0] = "on package.json, " +
                result.packageJSON.parse.toString("utf8").replace(/\n/gm, "\n\t    "));
            if (result.packageJSON.missingProperties.length > 0) {
                result.packageJSON.missingProperties = result.packageJSON.missingProperties.map(function(item) {
                    return "on package.json, " + item;
                });
            }
        }
        if (result.error) {
            res = res.concat(result.packageJSON.missingProperties);
            res = res.concat(result.missingFiles);
            result.allErrors = res;
        }
        else {
            delete result.packageJSON;
            delete result.missingFiles;
        }
    }

}
module.exports = smartfacePluginNValidator;
