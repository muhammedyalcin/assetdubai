const fs = require('fs');
const path = require('path');
const colors = require('colors');
var callCount = 0;
var basePath = "";

module.exports = {
	checkImages: checkImages,
	checkImagesfromArray: checkImagesfromArray,
	checkImagesfromFolder: checkImagesfromFolder,
	imageNameCheck: imageNameCheck,
	searchFileNamesfromFolderRecursively: searchFileNamesfromFolderRecursively
};
//callbacks true if error occured
function checkImages(imagesFolder, isJsonOut, callback, errorLogger) {
	function createColoredFirstLetter(baseName) {
		return baseName.substring(0, 1).replace(/[a-z]/g, function(str, p1, p2) {
			return colors.white(str);
		});
	}
	function createColoredString(baseName) {
		return baseName.substring(1, baseName.length)
			.replace(/[a-z0-9_\.]*/g, function(str, p1, p2) {
				return colors.white(str);
			}
		);
	}
	checkImagesfromFolder(imagesFolder, isJsonOut, function(faultyImageNames, isJsonOut, faultyImagePaths) {
		var errMsg = "Following image names are not acceptable for Android, please fix them and try to publish again";
		var errObj;
		if (faultyImageNames.length > 0) {
			if (isJsonOut) {
				errObj = {
					err: errMsg,
					msg: faultyImagePaths
				};
				if (errorLogger) {
					errorLogger(errObj);
				}
				callback(true);
			} else {
				var filepaths = [];
				var diff = [];
				var name = [];

				for (var i = 0; i < faultyImageNames.length; i++) {
					var faultyImageName = faultyImageNames[i];
					var tmpBaseName = path.basename(faultyImageName, path.extname(faultyImageName));
					var coloredFirstLetter = createColoredFirstLetter(tmpBaseName);
					var coloredStr = createColoredString(tmpBaseName);
					filepaths.push(faultyImagePaths[i]);
					diff.push(colors.red(coloredFirstLetter + coloredStr));
					name.push(faultyImageName);
				}
				filepaths.push('');
				diff.push('');
				name.push('');

				errObj = {
					msg: errMsg,
					fileNames: name.join('\n'),
					filePaths: filepaths.join('\n'),
					differences: diff.join('\n')
				};
				writeToStdOut(errObj);
				callback(true);
			}
		} else {
			callback(false);
		}
	});
}

/**
 * Checks images from given array
 * @param {Array.String} images array of images to be checked at once
 * @param {checkImagesfromArrayCallBack} callback containing result
 * @returns {Array.String} list of faulty images
 */
function checkImagesfromArray(images, callback) {
	var faultyImageNames = [];
	try {
		images.forEach(function(imageName) {
			if (!imageNameCheck(imageName)) {
				faultyImageNames.push(imageName);
			}
		});
	} catch (e) {
		console.log(e);
	}
	if(typeof callback === "function")
		callback(faultyImageNames);
	return faultyImageNames;
}

/**
 * This callback is showing list of invalid image names
 * @callback checkImagesfromArrayCallBack
 * @param {Array.String} faultyImageNames list of faulty images
 */

function checkImagesfromFolder(folderPath, isJsonOut, callback) {
	var faultyImageNames = [];
	var faultyImagePaths = [];
	try {
		var readImages = [];
		var imageRelativePaths = [];
		searchFileNamesfromFolderRecursively(folderPath, readImages, imageRelativePaths);
		for (var i = 0; i < readImages.length; i++) {
			if (!imageNameCheck(readImages[i])) {
				faultyImageNames.push(readImages[i]);
				faultyImagePaths.push(imageRelativePaths[i]);
			}
		}
	} catch (e) {
		console.log(e);
	}
	callback(faultyImageNames, isJsonOut, faultyImagePaths);
}

var reAndroidNamePattern = /^[a-z][a-z0-9]*(_[a-z0-9]+)*(?:\.(?:png|jpg|gif))$/;

/**
 * Checks image name vor valid android image name
 * @param {String} imageName name of the file, not full path
 * @returns {Boolean} true for valid image name
 */
function imageNameCheck(imageName) {
	const toIgnoreList = ['.DS_Store'];
	if (toIgnoreList.indexOf(imageName) !== -1) {
		return true;
	}
	reAndroidNamePattern.lastIndex = 0;
	var doesMatch = reAndroidNamePattern.test(imageName);
	return doesMatch;
}

function searchFileNamesfromFolderRecursively(folderPath, searchResult, relativePaths) {
	const files = fs.readdirSync(folderPath);
	if (callCount === 0) {
		basePath = folderPath;
		callCount++;
	}
	for (var i in files) {
		if (fs.statSync(path.join(folderPath, files[i])).isDirectory()) {
			searchFileNamesfromFolderRecursively(path.join(folderPath, files[i]), searchResult, relativePaths);
		} else {
			var imagePath = path.join(folderPath, files[i]);
			searchResult.push(path.basename(imagePath));
			relativePaths.push(path.relative(basePath, imagePath));
		}
	}
}

function writeToStdOut(jsonObj) {
	console.log(colors.red(' ERROR : ') + jsonObj.msg);
	console.log();
	var pathStr = jsonObj.filePaths.trim().split("\n");
	var nameStr = jsonObj.fileNames.trim().split("\n");
	var differenceStr = jsonObj.differences.trim().split("\n");

	for (var i = 0; i < pathStr.length; i++) {
		console.log(colors.yellow("File Path: ") + (path.dirname(pathStr[i]) + path.sep + differenceStr[i] + path.extname(pathStr[i])) + "\n" + colors.red("Error: ") + imageRegExpCheck(nameStr[i]));
		console.log();
	}
}

function imageRegExpCheck(imageName) {
	var imageNamewoutExt = path.basename(imageName, path.extname(imageName));
	var searchFirstLetter = new RegExp("[a-z]");
	var searchOtherLetters = new RegExp("[^a-z0-9_\.]+");
	var imageFirstLetter = imageNamewoutExt.substring(0, 1);
	var imageRest = imageNamewoutExt.substring(1, imageNamewoutExt.length);
	var retStr = "";
	if (imageNamewoutExt.length >= 2) {
		if (!searchFirstLetter.test(imageFirstLetter)) {
			retStr += "[The first character should be a non-capital letter]";
		}
		if (searchOtherLetters.test(imageRest)) {
			retStr += "[Filename can contain only non-capital letters, (0-9), . and _]";
		}
	} else {
		if (!searchFirstLetter.test(imageFirstLetter)) {
			retStr += "[The first character should be a non-capital letter]";
		}
	}
	return retStr;
}