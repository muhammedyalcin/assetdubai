const spawnSync = require('child_process').spawnSync;
const exec = require('child_process').exec;
const os = require('os');

const _ = require('lodash');
const reg = require('reg_java');

const utility = require('./utility');
const convert = utility.convertAbsolute.convert;
const requireJSON = require('./requireJSON');
const TASK = requireJSON(__dirname, './task.json');
const PATH_ARGS = requireJSON(__dirname, './pathArgs.json');
const error = require('./error');

// check for arguments by the task.json.
function checkArguments(_args, _platform) {
	var task = _args.task;
	const argsKeys = _.keys(_args);
	const workSpace = getWorkSpace(_platform);
	const workSpaceArgs = TASK[task][workSpace];
	const commonArgs = TASK[task]['common'];
	var basicArgs = null;
	const pad = '       : ';

	checkBasicArgs();
	checkArgs();
	checkUnderScoreArgs();
	checkPathArguments();

	function checkBasicArgs() {
		basicArgs = commonArgs.basicArguments.concat(workSpaceArgs.basicArguments);
		const diff = _.difference(basicArgs, argsKeys);
		if (!checkDiff(diff)) {
			var err = error.getObject('requiredArguments');
			err.msg += '\r\n' + pad + diff;
			utility.killProcess(err);
		}
	}

	function checkArgs() {
		const optinalArgs = basicArgs.concat(commonArgs.optionalArguments.concat(workSpaceArgs.optionalArguments));
		const diff = _.difference(argsKeys, optinalArgs);
		if (!checkDiff(diff)) {
			diff.splice(0, 1); // delete '_' element
			var err = error.getObject('fullArguments', {
				msg: {
					task: task
				},
				helpForUser: {
					task: task
				}
			});
			err.msg += '\r\n' + pad + diff + getUndersScoreArgs(_args);
			utility.killProcess(err);
		}
	}

	function checkUnderScoreArgs() {
		if (_args._.length !== 0) {
			var err = error.getObject('fullArguments', {
				msg: {
					task: task
				},
				helpForUser: {
					task: task
				}
			});
			err.msg += '\r\n' + pad + getUndersScoreArgs(_args);
			utility.killProcess(err);
		}
	}

	function checkPathArguments() {
		var arg, fullPath;
		PATH_ARGS.files.forEach(function(item) {
			arg = _args[item];
			if (arg) {
				if (typeof arg === "string") {
					fullPath = convert(arg);
					utility.throwsNoSuchFile(fullPath, null, "You should set existing file for this argument : " + item);
				}
				else {
					killProcessForArgumentPath(item, arg);
				}
			}
		});
		PATH_ARGS.dirs.forEach(function(item) {
			arg = _args[item];
			if (arg) {
				if (typeof arg === "string") {
					fullPath = convert(arg);
					utility.throwsNoSuchDir(fullPath, "You should set existing directory for this argument : " + item);
				}
				else {
					killProcessForArgumentPath(item, arg);
				}
			}
		});

		function killProcessForArgumentPath(item, arg_item) {
			utility.killProcess(error.getObject("argumentPath", {
				msg: {
					argument: item + " = " + arg_item
				}
			}));
		}
	}
}

function getWorkSpace(_platform) {
	if (_platform === 'win32') {
		return 'desktop';
	}
	return 'smfCloud';
}

// check for minimist _ 
function checkDiff(_diff) {
	if (_diff.length === 1) {
		if (_diff[0] === '_') {
			return true;
		}
	}
	else if (_diff.length === 0) {
		return true;
	}
	return false;
}

function getUndersScoreArgs(_args) {
	if (_args._.length !== 0) {
		return _args._.join(',');
	}
	return '';
}

// checking git enviroment.
function checkGitCommond(callback) {
	const ticket = 'InstallLocation';
	const searchPath = '\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Git_is1';
	const gitCmd = 'git';
	const gitChild = spawnSync(gitCmd, ['--version']);
	if (gitChild.error && os.platform() === 'win32') {
		reg.search('HKLM/SOFTWARE/Wow6432Node' + searchPath, ticket, function(err, data) {
			if (err) {
				reg.search('HKLM/SOFTWARE' + searchPath, ticket, function(_err, _data) {
					if (_data) {
						gitCmd = _data[0].value + '/bin/git';
						gitChild = spawnSync(gitCmd, ['--version']);
						if (gitChild.error) {
							callback(null);
						}
						else {
							callback(gitCmd);
						}
					}
					else if (_err) {
						callback(null);
					}
				});
			}
			else if (data) {
				gitCmd = data[0].value + '/bin/git';
				gitChild = spawnSync(gitCmd, ['--version']);
				if (gitChild.error) {
					callback(null);
				}
				else {
					callback(gitCmd);
				}
			}
		});
	}
	else {
		if (gitChild.error) {
			callback(null);
		}
		else {
			callback(gitCmd);
		}
	}
}


var EnvDependencies = (function() {
	var _res = {
		env: {
			java: null,
			git: null
		},
		dep: {
			lib32: ['lib32z1', 'lib32ncurses5', 'lib32bz2-1.0', 'lib32stdc++6'],
			nonLib32: []
		}
	};
	var _isChecked = false;

	function isChecked() {
		return _isChecked;
	}

	function checkEnvironment(_callback) {
		var res = _res.env;
		utility.javaFinder(function(err, javaPath) {
			if (javaPath) {
				res.java = javaPath;
			}
			checkGitCommond(function(_data) {
				if (_data) {
					res.git = _data;
				}
				_callback(res);
			});
		});
	}

	function checkNeedDependencies() {
		return (os.platform() === 'linux' && os.arch() === 'x64');
	}

	function checkDependencies(callback) {
		if (checkNeedDependencies()) { // Linux 64bit Machines 
			var nonDependencies = _res.dep.nonLib32;
			if (_isChecked) {
				return callback(null, _res.dep);
			}
			const childDpkg = exec('dpkg -l | grep lib32');
			if (childDpkg) {
				var bufferData = '';
				var bufferErr = '';
				childDpkg.stdout.on('data', function(data) {
					bufferData += data;
				});
				childDpkg.stderr.on('data', function(_data) {
					bufferErr += _data;
				});
				childDpkg.on('close', function(code) {
					if (bufferErr !== '') {
						// errors
						callback(new Error(bufferErr));
					}
					else if (bufferData !== '') {
						// datas
						_.each(_res.dep.lib32, function(item) {
							if (getCurrentlyInstalled().search(utility.escapeRegExp(item)) === -1) {
								nonDependencies.push(item);
							}
						});
						callback(null, _res.dep);
					}
					else {
						_res.dep.nonLib32 = _.cloneDeep(_res.dep.lib32);
						callback(null, _res.dep);
					}
				});
			}
			else {
				callback(new Error(' Command: dpkg -l | grep lib32 '));
			}
		}
		else {
			callback(null, _res.dep);
		}

		function getCurrentlyInstalled() {
			const regExp = /ii.*\n/gmi; // get active packages.
			var res = [];
			var match;

			while (match = regExp.exec(bufferData)) {
				res.push(match);
			}

			return res.join('');
		}
	}

	function getJavaPath(callback) {
		if (_isChecked) {
			callback(_res.env.java);
		}
		else {
			checkEnvironment(function(cbRes) {
				callback(cbRes.java);
			});
		}
	}

	function getGitPath(callback) {
		if (_isChecked) {
			callback(_res.env.git);
		}
		else {
			checkEnvironment(function(cbRes) {
				callback(cbRes.git);
			});
		}
	}

	function getVersion(child) {
		if (child && child.output) {
			const regExp = /\d+.\d+.\d+_\d+|\d+.\d+.\d+/gmi;
			return regExp.exec(child.output.toString('utf8'));
		}
		return '';
	}

	function getJavaVersion() {
		const child = spawnSync(_res.env.java, ['-jar', '-version']);
		return getVersion(child);
	}

	function getGitVersion() {
		const child = spawnSync(_res.env.git, ['--version']);
		return getVersion(child);
	}

	function getNodeVersion() {

		return process.version;
	}

	function getEnvResultsForUI() {
		var res = [];
		var stat = 'ok';

		res.push(getOneObject('Node.js', getNodeVersion()));
		res.push(getOneObject('Java 1.8', getJavaVersion()));
		res.push(getOneObject('Git', getGitVersion()));

		function getOneObject(name, version) {
			var ok = 'ok';
			if (!version || version === '') {
				ok = 'no';
				stat = 'no';
			}
			return {
				stat: ok,
				version: version,
				name: name
			};
		}
		return {
			env: res,
			stat: stat
		};
	}

	function getDepResultsForUI() {
		var res;
		var stat = 'ok';
		if (checkNeedDependencies()) { // for debug (!) // TO DO remove !
			res = [];
			const uninstalled = _res.dep.nonLib32;
			const installed = _.difference(_res.dep.lib32, uninstalled);
			_.each(installed, function(item) {
				res.push({
					stat: 'ok',
					name: item
				});
			});
			_.each(uninstalled, function(item) {
				stat = 'no';
				res.push({
					stat: 'no',
					name: item
				});
			});
		}
		return {
			dep: res,
			stat: stat
		};
	}


	function checkAll(callback) { // checking Env & Dependencies
		checkEnvironment(function() {
			checkDependencies(function(err, data) {
				if (err) {
					callback(err);
				}
				else {
					_isChecked = true;
					callback(null, _res);
				}
			});
		});
	}

	function getEnvDepResult() {
		return _.extend({}, _res);
	}

	return {
		isChecked: isChecked,
		checkEnvironment: checkEnvironment,
		checkDependencies: checkDependencies,
		getJavaPath: getJavaPath,
		getGitPath: getGitPath,
		checkAll: checkAll,
		getEnvDepResult: getEnvDepResult,
		getJavaVersion: getJavaVersion,
		getGitVersion: getGitVersion,
		getNodeVersion: getNodeVersion,
		getEnvResultsForUI: getEnvResultsForUI,
		getDepResultsForUI: getDepResultsForUI,
		checkNeedDependencies: checkNeedDependencies
	};
})();
module.exports = {
	checkArguments: checkArguments,
	checkGitCommond: checkGitCommond,
	EnvDep: EnvDependencies
};