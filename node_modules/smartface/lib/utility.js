const fs = require('fs');
const path = require('path');
const spawn = require('child_process').spawn;
const spawnSync = require('child_process').spawnSync;
const exec = require('child_process').exec;
const os = require('os');
const inspect = require('util').inspect;

const _ = require('underscore');
const uuid = require('uuid');
const fs_extra = require('fs-extra');
const colors = require('colors');
const rmdir = require("rmdir");

const logger = require('./log/log4j').getLogger('utility');
const ConfigObjects = require('./config/index');
const error = require('./error');
const helpJSON = require("./help/help.json");

var TASK = {};
_.each(_.keys(helpJSON.task), item => {
	TASK[item.toLowerCase()] = item;
});

var Config = ConfigObjects.Config;
var Config2 = ConfigObjects.Config2;

var searchRes = [];

const LogStatus = (function() {
	var logging = false;
	var outJson = false;

	function setLogStatus(status) {
		logging = status;
	}

	function getLogStatus() {
		return logging;
	}

	function setOutJson(_status) {
		outJson = _status;
	}

	function getOutJson() {
		return outJson;
	}

	return {
		setLogStatus: setLogStatus,
		getLogStatus: getLogStatus,
		getOutJson: getOutJson,
		setOutJson: setOutJson
	};
})();

//convert absolute path with cwd
const convertAbsolute = (function() {
	var cwd = '';

	function setCwd(_cwd) {
		if (!path.isAbsolute(_cwd)) {
			throw new Error('cwd must be absolute path ! : ' + _cwd);
		}
		cwd = _cwd;
	}

	function convert(_path) {
		if (_path && !path.isAbsolute(_path)) {
			return path.join(cwd, _path);
		}
		else {
			return _path;
		}
	}

	function getCwd() {
		return cwd;
	}

	return {
		setCwd: setCwd,
		convert: convert,
		getCwd: getCwd
	};
})();

const TmpDir = (function() {
	var tmpdir = null;

	function set(_tmp) {
		tmpdir = _tmp;
	}

	function get() {
		return tmpdir;
	}
	return {
		get: get,
		set: set
	};
})();

// get date time as a string.
function getDateTime() {
	const date = new Date();
	var hour = date.getHours();
	hour = (hour < 10 ? "0" : "") + hour;
	var min = date.getMinutes();
	min = (min < 10 ? "0" : "") + min;
	var sec = date.getSeconds();
	sec = (sec < 10 ? "0" : "") + sec;
	const year = date.getFullYear();
	var month = date.getMonth() + 1;
	month = (month < 10 ? "0" : "") + month;
	var day = date.getDate();
	day = (day < 10 ? "0" : "") + day;
	return year + ":" + month + ":" + day + ":" + hour + ":" + min + ":" + sec;
}

function getBuildTimestamp() {
	const a = new Date().toISOString().replace('T', ':').split('.')[0].replace(/\:/g, '-').split('-');
	return a[0] + a[1] + a[2] + '-' + a[3] + a[4] + a[5];
}

//remove folder recursively with subfolders.
function removeFolder(_path) {
	var folder = fs.readdirSync(_path);
	for (var i = 0; i < folder.length; i++) {
		var item = folder[i];
		var itemPath = path.join(_path + '/' + item);
		if (fs.lstatSync(itemPath).isDirectory()) {
			removeFolder(itemPath); // delete recursively.
			fs.rmdirSync(itemPath);
		}
		else {
			if (os.platform() === 'win32') {
				fs.chmodSync(itemPath, 666);
			}
			fs.unlinkSync(itemPath);
		}
	}
}

// control one file is exist and is file and .type ?
function safeControlFile(file, type) {
	var res = false;
	if (fs.existsSync(file)) {
		if (!fs.statSync(file).isDirectory()) {
			const fileType = file.slice(file.lastIndexOf('.') + 1, file.length);
			if (type) {
				if (fileType === type) {
					res = true;
				}
			}
			else {
				res = true;
			}
		}

	}
	return res;
}

// control directory is eexits and  isDirectory ?.
function safeControlDirectory(_path) {
	var res = false;
	if (fs.existsSync(_path)) {
		if (fs.statSync(_path).isDirectory()) {
			res = true;
		}

	}
	return res;
}

// control  child is, have error object and  output any error strings. ?
function controlChildProcess(child) {
	var res = false;
	if (_.isUndefined(child.error) && (child.output.toString('utf8').search(/error/gim) === -1 && child.output.toString('utf8').search(/Exception/gim) === -1)) {
		res = true;
	}

	return res;
}

// control config, config2 instance.
function controlConfig(config) {
	var err = {
		err: '',
		msg: '',
	};

	if (_.isUndefined(config)) {
		err.err = 'undefined object';
		err.msg = 'config object is undefined';

	}
	else if (!(config instanceof Config)) {
		err.err = 'Config object';
		err.msg = 'config is not Config object';

	}
	else if (!(config.config2 instanceof Config2)) {
		err.err = 'Config2 object';
		err.msg = 'config.config2 object is not Config2';

	}
	if (err.err !== '') {
		logger.error(err.msg);
		killProcess(err);
	}
}
// control config2 properties.
function controlProperties(obj, name) {
	var err = {
		err: '',
		msg: '',
	};
	const index = _.values(obj).indexOf(undefined);
	if (index != -1) {
		err.err = 'undefined properties value';
		err.msg = ' at least , ' + name + '  one properties is undefined  prop: ' + _.keys(obj)[index];
	}
	if (err.err !== '') {
		logger.error(err.msg);
		killProcess(err);
	}
}

function generateUUID() { // remove - chs.
	return uuid.v4().toUpperCase().replace(/\-/g, '');
}

// Exp: ali.asd.txt ->> type=cmd ->> returns  ali.asd.cmd
function renameFilesType(fileName, type) {
	const temp = fileName.split('.');
	var res = fileName;
	if (temp.length > 0) {
		res = temp[0];
		for (var i = 1; i < temp.length - 1; ++i) {
			res += '.' + temp[i];
		}
		res += '.' + type;
	}
	return res;
}

function throwsNoSuchDir(dir, helpForUser) {

	if (!safeControlDirectory(dir)) {
		var errObj = _.extend(error.getObject('fileDir', {
			err: {
				fileDir: 'Directory'
			},
			msg: {
				fileDir: 'directory'
			}
		}), {
			"fullPath": convertAbsolute.convert(dir)
		});
		if (!path.isAbsolute(dir)) {
			errObj.msg += ' : ' + dir;
		}
		if (typeof helpForUser === "string") {
			errObj.helpForUser = helpForUser;
		}
		killProcess(errObj);
	}
}

function throwsNoSuchFile(file, type, helpForUser) {

	if (!safeControlFile(file, type)) {


		var errObj = _.extend(error.getObject('fileDir', {
			err: {
				fileDir: 'File'
			},
			msg: {
				fileDir: 'file'
			}
		}), {
			"fullPath": convertAbsolute.convert(file)
		});
		if (!path.isAbsolute(file)) {
			errObj.msg += ' : ' + file;
		}
		if (typeof helpForUser === "string") {
			errObj.helpForUser = helpForUser;
		}
		killProcess(errObj);
	}
}
/*@deprecated We can use package from npm instead of this.*/
function searchFilesRec(dir) {
	const files = fs.readdirSync(dir);
	for (var i in files) {
		if (fs.statSync(dir + '/' + files[i]).isDirectory()) {
			searchFilesRec(dir + '/' + files[i]);
		}
		else {
			searchRes.push(dir + '/' + files[i]);
		}
	}
}

/*@deprecated We can use package from npm instead of this.*/
// returns files in directory with subdirectories.
function searchFiles(dir) {
	searchRes = [];
	searchFilesRec(dir);
	return searchRes;
}

function killProcess(obj) {
	if (obj) {
		obj.allDone = true;
		writeJsonToStdout(obj);
	}
	if (TmpDir.get() !== null && !process.env.SMF_TOKEN) {
		spawnSync('node', [__dirname + '/bin/cleaner', '--folder=' + TmpDir.get()]);
	}
	process.exit(1);
}

// write error  to console & logger then killProcess.
// opt.logger        specific logger
// opt.errOpt        options for error object
// opt.extendOpt     extend any properties on error object
function killProcessWithError(errName, opt) {
	var logger = null,
		errOpt = null,
		extendOpt = null;
	if (opt) {
		opt.logger && (logger = opt.logger);
		opt.errOpt && (errOpt = opt.errOpt);
		opt.extendOpt && (extendOpt = opt.extendOpt);
	}
	const errObject = _.extend(error.getObject(errName, errOpt), extendOpt);
	killProcess(errObject);
}

// safety creating directories.
function mkdirpSync(pathStr) {

	var unvalidDirname = [];
	// first occurence valid directory.
	function getValidDirname(pathString) {
		const dirname = path.dirname(pathString);

		if ((dirname === '.') || fs.existsSync(dirname)) {
			unvalidDirname.push(pathString.substring(pathString.lastIndexOf(path.sep)).replace(/\\|\//gm, ''));
			return dirname;
		}
		unvalidDirname.push(pathString.substring(pathString.lastIndexOf(path.sep)).replace(/\\|\//gm, ''));
		return getValidDirname(path.dirname(pathString));
	}
	var res = false;
	var normalPath = path.normalize(pathStr);
	var validDirname = getValidDirname(normalPath);
	if (validDirname !== '.') {
		_.each(unvalidDirname.reverse(), function(item) {
			validDirname = validDirname + path.sep + item;
			if (!fs.existsSync(validDirname)) {
				fs.mkdirSync(validDirname);
			}
		});
		res = true;
	}
	return res;
}

// rename file name not include ext name.
function createOutPathByTheProfile(filePath, profile) {

	var file = path.parse(filePath);
	var newName = profile.name;
	if (newName !== 'Default') {
		file.name += ' - ' + newName;
		file.base = file.name + file.ext;
	}
	file.base = file.name + file.ext;
	return path.normalize(path.format(file));
}

function createOptionalCallback(callback) {
	if (!callback || typeof callback !== 'function') {
		callback = function() {};
	}
	return callback;
}

function writeJsonToStdout(jsonObj) {
	var resStr = "";
	if (LogStatus.getOutJson()) {
		if (jsonObj.err) {
			jsonObj.allDone = true;
		}
		process.stdout.write(JSON.stringify(jsonObj, null, "\t") + "\n");
	}
	if (jsonObj.err) {
		appendNewLine("");
		appendNewLine(jsonObj.err);
		appendNewLine('  └─── : ' + jsonObj.msg);
		if (jsonObj.fullPath) {
			appendNewLine(' Path  : ' + jsonObj.fullPath);
		}
		if (jsonObj.detail) {
			appendNewLine(' Detail: ' + jsonObj.detail);
		}
		if (jsonObj.helpForUser) {
			appendNewLine(' help ?: ' + jsonObj.helpForUser);
		}
		appendNewLine("");
	}
	else if (jsonObj.warning) {
		appendNewLine("");
		appendNewLine(colors.yellow(jsonObj.warning));
		jsonObj.msg && appendNewLine('  └─── : ' + jsonObj.msg);
		jsonObj.helpForUser && appendNewLine(' help ?: ' + jsonObj.helpForUser);
		appendNewLine("");
	}
	else if (jsonObj.nextProfile && jsonObj.cpuType) {
		appendNewLine('Profile : ' + jsonObj.nextProfile + " - " + jsonObj.cpuType + '... ');
	}
	else if (jsonObj.nextIOS) {
		appendNewLine('iOS Publish ... ');
	}
	else if (jsonObj.msg) {
		appendNewLine(jsonObj.msg);
	}
	if (jsonObj.responseDone) {
		if (jsonObj.finishedTask && jsonObj.finishedTask.downloadFilePath)
			appendNewLine('Output: ' + jsonObj.finishedTask.downloadFilePath);
	}


	StdoutLogger.logNicely(jsonObj, resStr);

	if (!LogStatus.getOutJson()) {
		addColors();
		process.stdout.write(resStr);
	}

	function appendNewLine(_str) {
		resStr += _str + "\n";
	}

	function addColors() {
		if (jsonObj.err) {
			resStr = resStr.replace(jsonObj.err, colors.red(' ERROR ') + jsonObj.err);
		}
		else if (jsonObj.warning) {
			resStr = resStr.replace(jsonObj.warning, colors.yellow(' WARNING ') + jsonObj.warning);
		}

	}

	function cropLargeStrings(obj) {
		var croppedJson = Object.assign({}, obj);
		obj.msg && (croppedJson.msg = obj.msg.substring(0, 500));
		obj.stack && (croppedJson.stack = obj.stack.substring(0, 500));
		obj.detail && (croppedJson.detail = obj.detail.substring(0, 500));
		obj.helpForUser && (croppedJson.helpForUser = obj.helpForUser.substring(0, 500));
		return croppedJson;
	}
}

//outputs are need logging by logger.
const StdoutLogger = (function() {
	var _logger = logger;

	function logNicely(obj, str) {
		if (isLogging()) {
			if (obj.err)
				_logger.error(str);
			else if (obj.warning)
				_logger.warn(str);
			else
				_logger.info(str);
		}
	}

	function setLogger(loggerParam) {
		_logger = loggerParam;
	}
	// can it log. return true/false.
	function isLogging() {
		if (_logger)
			return true;
		return false;
	}
	return {
		setLogger: setLogger,
		logNicely: logNicely,
		isLogging: isLogging
	};
})();

function writeJsonMsgToStdout(msg, source) {
	writeJsonToStdout({
		msg: msg,
		source: source
	});
}
/*@deprecated We can use package from npm instead of this.*/
function getJavaPathForDarwin(callback) {
	const child = spawn('/usr/libexec/java_home', ['-v', '1.8']);
	child.stdout.on('data', function(data) {
		callback(null, data.toString().replace('\n', '') + '/bin/java');
	});
	child.stderr.on('data', function(data) {
		callback(data);
	});
}

// find automaticaly java path from process.env.programFiles.
function javaControlSync(java, version) {
	const child = spawnSync(java, ['-jar', '-version']);
	var output = '';
	child && (child.output && (output = child.output.toString('utf8')));

	return controlVersion(output, version);
}

function controlVersion(outputJava, javaVersion) { // control java version.
	const reg = new RegExp(javaVersion + '.\\d', 'gm');
	var res = false;
	if (outputJava.search(reg) !== -1) {
		res = true;
	}
	return res;
}
/*@deprecated We can use package from npm instead of this.*/
function javaFinderForLinux() {
	const child = spawnSync('which', ['java']);
	var output = '';
	child && (child.output && (output = child.stdout.toString('utf8')));
	const resultJavaPath = output.replace(/\n/gm, '');

	if (resultJavaPath !== '') {
		logger.debug('Java was found : ' + resultJavaPath);
	}

	return resultJavaPath;

}

function getJavaPathByTheVersion(version, callback) {
	switch (process.platform) {
		case 'win32':
			var win = require('javapathfinder/javapath_win');
			win = win.path(version, function(err, javaPath) {
				if (err) {
					callback(err);
				}
				else {
					callback(null, path.join(javaPath, "java.exe"));
				}
			});
			break;
		case 'darwin':
			var mac = require('javapathfinder/javapath_mac');
			mac = mac.path(version, function(err, javaPath) {
				if (err) {
					callback(err);
				}
				else {
					callback(null, path.join(javaPath, "java"));
				}
			});
			break;
		case 'linux':
			var linux = require('javapathfinder/javapath_linux');
			linux = linux.path(version, function(err, javaPath) {
				if (err) {
					callback(err);
				}
				else {
					callback(null, path.join(javaPath, "java"));
				}
			});
			break;
		default:
			killProcessWithError('platform.support', {
				errOpt: {
					msg: {
						platform: process.platform,
						msg: ' method: javaFinder() .'
					}
				},
				logger: logger
			});
	}
}

function JavaPathWithOs(callback) {

	getJavaPathByTheVersion("1.8", done);
	getJavaPathByTheVersion("1.7", done);

	var taskCount = 2,
		_javaPath = null;

	function done(err, javaPath) {
		if (javaPath) {
			_javaPath = javaPath;
			return callback(null, javaPath);
		}
		if (--taskCount === 0 && (!_javaPath && err))
			callback(err);
	}

}

// find current workspace directory.
function cwd(callback) {
	const platform = os.platform();
	var cmd = ''; // command taht will be operated.
	if (platform === 'win32') {
		cmd = 'echo %cd%';
	}
	else if (platform === 'linux' || platform === 'darwin') {
		cmd = 'pwd';
	}
	if (cmd !== '') {
		exec(cmd,
			function(error, stdout, stderr) {
				if (error) {
					logger.error('Error during find CWD.');
					return callback(error);
				}
				return callback(null, stdout.toString('utf8').replace(/\r|\n/gm, ''));
			});

	}
	else {
		killProcessWithError('platform.support', {
			errOpt: {
				msg: {
					platform: platform,
					msg: 'find cwd ( Current Workspace Directory ).'
				}
			},
			logger: logger
		});
	}
}

//logger must update after the configure
function updateLogger() {
	logger = require('./log/log4j').getLogger('utility');
}

/* @deprecated we can use same func in builtin string */
function repeatStr(str, count) { // string repeater
	var rpt = '';
	for (var i = 0; i < count; i++) {
		rpt = rpt + str;
	}
	return rpt;
}

// control png images
function pngImagesControl(imagesDir, pkcgProfiles) {
	const folderName = imagesDir.substr(imagesDir.lastIndexOf(path.sep) + 1, imagesDir.length);
	if (!fs.existsSync(imagesDir)) {
		return writeJsonToStdout({
			warning: 'PackageProfiles.xml contains "' + folderName + '", but it was not found. The process will continue, but you might want to check if this is an error.'
		});
	}
	const pngFiles = fs.readdirSync(imagesDir);
	for (var i = 0; i < pngFiles.length; i++) {
		if (fs.statSync(path.join(imagesDir, pngFiles[i])).isDirectory()) {
			pngFiles.splice(i, 1);
			i--;
		}
	}
	if (!pkcgProfiles) {
		for (var i = 0; i < pngFiles.length; i++) {
			var pngFile = path.parse(pngFiles[i]);
			if (pngFile.ext.match(/png/gmi) === null) {
				killProcessWithError('imageFormat', {
					errOpt: {
						msg: {
							imageFormat: pngFile.ext
						}
					},
					extendOpt: {
						fullPath: path.join(imagesDir, pngFiles[i])
					},
					logger: logger
				});
			}
		}
	}
	else {
		_.each(pkcgProfiles, function(itemProfile) {
			_.each(itemProfile.profile.folders, function(_itemFolder) {
				pngImagesControl(path.join(imagesDir, _itemFolder));
			});
		});
	}
}
// @unused
// sfpx & _data find on projectRoot
function findSfpxAndDataFolder(_input) {
	//TODO: remove this function?
	const parsedFile = path.parse(_input); //TODO: unused
	if (safeControlFile(_input, 'sfpx')) { // input sfpx file ?

	}
	else if (safeControlDirectory(_input)) { // input data folder ?

	}
	else { // input only name ?

	}
}

// get sub object.
function getSubObject(_obj, _key) {
	const _keys = _key.split('.');
	var res = _obj;
	for (var i = 0; i < _keys.length; i++) {
		if (res) {
			res = res[_keys[i]];
		}
		else { // handle undefined .
			return undefined;
		}
	}
	return res;
}

function escapeRegExp(str) {
	return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

function searchFilesInDirRec(pathToFolder) {
	var fileArray = readDirSyncRecursively(pathToFolder);
	var retArray = [];
	//ignore directory entries because we only want files.
	fileArray.forEach(function(fileName) {
		if (!fs.statSync(path.join(pathToFolder, fileName)).isDirectory()) {
			retArray.push(path.join(pathToFolder, fileName));
		}
	});
	return retArray;
}

function copyFilesFromFileArrToFolder(fileArray, copyFolderPath) {
	fs_extra.mkdirsSync(copyFolderPath);
	var scrFolder = path.dirname(copyFolderPath);
	fileArray.forEach(function(fileName) {
		var relativeFilePath = path.relative(scrFolder, fileName);
		fs_extra.copySync(fileName, path.join(copyFolderPath, relativeFilePath));
	});
}

function rmDirRec(dirPath) {
	fs_extra.removeSync(dirPath);
}

function readDirSyncRecursivelyAbs(dirPath) {
	var read = [];
	var rootRead = fs.readdirSync(dirPath);
	rootRead.forEach(function(item) {
		var itemPath = path.join(dirPath, item);
		read.push(itemPath);
		if (fs.statSync(itemPath).isDirectory()) {
			read = read.concat(readDirSyncRecursivelyAbs(itemPath));
		}
	});
	return read;
}

function readDirSyncRecursively(dirPath) {
	var relRead = [];
	var absRead = readDirSyncRecursivelyAbs(dirPath);
	absRead.forEach(function(items) {
		relRead.push(path.relative(dirPath, items));
	});
	return relRead;
}

function outputPathByChannel(outputpath, channel) {
	var ext = path.extname(outputpath);
	var res = outputpath;
	channel = channel.trim();
	if (channel !== '')
		res = res.replace(ext, " - " + channel + ext);
	return res;
}

//beautify log for console
(function() {
	if (!console.inspect) {
		console.inspect = function(obj) {
			console.log(inspect(obj, {
				colors: true,
				depth: Infinity
			}));
		};
	}
})();

//israu task, task:android, task:ios ?
function isRAU(task, str, os) {
	var res = false;
	if (os) {
		RegExp(task + ":.*" + os, "i").test(str) && (res = true);
	}
	else {
		RegExp(task + ":", "i").test(str) && (res = true);
	}
	return res;
}

function isValidTask(task, expectedTask) {
	var res = null,
		originalParamTask = task;
	var indexDotDot = task.indexOf(':');
	indexDotDot !== -1 && (task = task.substring(0, indexDotDot));
	task = task.toLowerCase();
	if (!expectedTask) {
		res = TASK[task] ? (indexDotDot === -1) ? TASK[task] : originalParamTask : null;
	}
	else {
		(expectedTask.toLowerCase() === task) && (res = TASK[task]);
	}
	if (["rau", "publish", "test"].indexOf(originalParamTask) !== -1) {
		res += ":";
	}
	return res;
}


function getCliVersion() {
	return require(__dirname + "/../package.json").version;
}

function parseJSONForMessage(msg) {
	var res;
	try {
		res = JSON.parse(msg).Message;
	}
	catch (e) {}!res && (res = msg);
	return res;
}


/**
 * @function createSafeDir
 * remove and create directory.
 * @param path {string} path of directory that will be created.
 * @return {promise} result of promise.
 */
function createClearDir(path) {
	return new Promise((resolve, reject) => {
		fs.stat(path, (err, stats) => {
			var createDir = false;
			if (err) { // if it does not exist
				createDir = true;
			}
			else {
				if (!stats.isDirectory()) {
					createDir = true;
				}
			}
			if (createDir) {
				mkdirpSync(path);
				resolve("Directory is created -> " + path);
			}
			else {
				rmdir(path, _err => {
					if (_err) {
						reject(err);
					}
					else {
						mkdirpSync(path);
						resolve("Directory is removed & created -> " + path);
					}
				});
			}
		});
	});
}

function createDummyPromise(err, data) {
	return new Promise((resolve, reject) => {
		if (err) {
			return reject(err);
		}
		resolve(data);
	});
}
//Promise serial
(function() {
	if (!Promise.series) {
		Promise.series = function(promiseArr) {
			var results = [];
			var len = promiseArr.length;
			var resolver, rejecter;
			var resPromise = new Promise((resolve, reject) => {
				resolver = resolve;
				rejecter = reject;
			});
			var temp;

			function runOne(index) {
				if (index >= len) {
					return resolver(results);
				}
				temp = promiseArr[index];
				temp().then(res => {
					results.push(res);
					runOne(index + 1);
				}, rejecter);
			}
			runOne(0);
			return resPromise;
		};
	}
})();

function delay(ms) {
	spawnSync('node', [__dirname + '/bin/delay', '--timeout=' + ms]);
}

/**
 * @function isExistsFileDir
 * control for existing file or dir
 * @param prePath {string} pre path of tempDirectory that will be created.
 * @return {promise} stats of file  promise.
 */
function isExistsFileDir(path) {
	var res = {
		dir: false,
		existing: false,
		file: false
	};
	return new Promise((resolve, reject) => {
		fs.stat(path, (err, stats) => {
			if (!err) {
				res.dir = stats.isDirectory();
				res.file = stats.isFile();
				res.existing = true;
				resolve(res);

			}
			else if (err && (err.code !== "ENOENT")) {
				reject(err);
			}
			else {
				resolve(res);
			}
		});
	});
}

function convertToBase64(file) {
	var bitmap = fs.readFileSync(file);
	return new Buffer(bitmap).toString('base64');
}

function guid() {
	function s4() {
		return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	}

	return s4() + s4();
}

function isExistsFileDirSync(path){
	var res = null;
	try{
		res = fs.statSync(path);
		res = {
			dir: res.isDirectory(),
			file: res.isFile(),
			existing: true,
		};
	}catch(exp){
		if(exp.code !== "ENOENT"){
			throw exp;
		}
	}
	return res;
}

module.exports = {
	controlChildProcess: controlChildProcess,
	controlConfig: controlConfig,
	controlProperties: controlProperties,
	controlVersion: controlVersion,
	convertAbsolute: convertAbsolute,
	copyFilesFromFileArrToFolder: copyFilesFromFileArrToFolder,
	createOptionalCallback: createOptionalCallback,
	createOutPathByTheProfile: createOutPathByTheProfile,
	cwd: cwd,
	escapeRegExp: escapeRegExp,
	generateUUID: generateUUID,
	getBuildTimestamp: getBuildTimestamp,
	getDateTime: getDateTime,
	getJavaPathForDarwin: getJavaPathForDarwin,
	getSubObject: getSubObject,
	javaControlSync: javaControlSync,
	javaFinder: JavaPathWithOs,
	javaFinderForLinux: javaFinderForLinux,
	killProcess: killProcess,
	LogStatus: LogStatus,
	mkdirpSync: mkdirpSync,
	pngImagesControl: pngImagesControl,
	removeFolder: removeFolder,
	renameFilesType: renameFilesType,
	repeatStr: repeatStr,
	readDirSyncRecursively: readDirSyncRecursively,
	rmDirRec: rmDirRec,
	safeControlDirectory: safeControlDirectory,
	safeControlFile: safeControlFile,
	searchFiles: searchFiles,
	searchFilesInDirRec: searchFilesInDirRec,
	throwsNoSuchDir: throwsNoSuchDir,
	throwsNoSuchFile: throwsNoSuchFile,
	tmpdir: TmpDir,
	updateLogger: updateLogger,
	writeJsonMsgToStdout: writeJsonMsgToStdout,
	writeJsonToStdout: writeJsonToStdout,
	isRAU: isRAU,
	outputPathByChannel: outputPathByChannel,
	isValidTask: isValidTask,
	StdoutLogger: StdoutLogger,
	getCliVersion: getCliVersion,
	parseJSONForMessage: parseJSONForMessage,
	createClearDir: createClearDir,
	createDummyPromise: createDummyPromise,
	delay: delay,
	isExistsFileDir: isExistsFileDir,
	isExistsFileDirSync: isExistsFileDirSync,
	convertToBase64: convertToBase64,
	guid: guid
};
