/**
 *
 * @file copy operations.
 * @version 1.0.0
 * @requires module:fs
 *
 */

const fs = require('fs');
const fse = require("fs-extra");
/**
 * Copy file from source to destination file.
 * @function copyFile
 * @param {string} filepath source file path.
 * @param {string} filepath dest file path.
 * @return {undefined} undefined
 * @this Global
 */
const BIN_ENCODING_JSON = {
	encoding: 'binary'
};

function copyFile(orgFilePath, targetFilePath) {
	//fs.writeFileSync(targetFilePath, fs.readFileSync(orgFilePath, BIN_ENCODING_JSON), BIN_ENCODING_JSON);
	if (filemanager) {
		filemanager.updateWithoutHashSync(targetFilePath, orgFilePath);
	}
	else {
		fse.copySync(orgFilePath, targetFilePath);
	}
}

var filemanager = null;

function setFileMager(mf) {
	filemanager = mf;
}
/**
 * Copy files from source with subFolders to destination folder .
 * @function copyDirectory
 * @param {string} dirPath source folder path.
 * @param {string} destDirectoryPath dest folder path.
 * @param {string} destNameReplacer A lambda function that can alter the file name on the destination, or allow it to be skipped if it returns Boolean false.
 * @return {undefined} undefined
 */
function copyDirectory(dirPath, destDirectoryPath, destNameReplacer, isVirtual, ignoreFilemanager) {
	const files = fs.readdirSync(dirPath);
	destNameReplacer = destNameReplacer || function(dirPath, fileName, isDirectory) {
		return fileName;
	};
	if (!isVirtual) {
		//This is for special handling for JSZip objects
		createDirectoryIfNotExists(destDirectoryPath);
	}
	for (var i = 0; i < files.length; ++i) {
		var orgFileName = files[i],
			destFileName;
		if (fs.statSync(dirPath + '/' + orgFileName).isDirectory()) { // sub folder.
			destFileName = destNameReplacer(dirPath, orgFileName, true);
			if (!destFileName) {
				continue;
			}
			copyDirectory(dirPath + '/' + orgFileName, destDirectoryPath + '/' + destFileName, destNameReplacer, isVirtual, ignoreFilemanager);
		}
		else {
			destFileName = destNameReplacer(dirPath, orgFileName, false);
			if (!destFileName) {
				continue;
			}
			//fs.writeFileSync(destDirectoryPath + '/' + destFileName, 
			//	fs.readFileSync(dirPath + '/' + orgFileName, BIN_ENCODING_JSON), 
			//	BIN_ENCODING_JSON);
			if ((filemanager !== null) && !ignoreFilemanager) {
				filemanager.updateWithoutHashSync(destDirectoryPath + '/' + destFileName, dirPath + '/' + orgFileName);
			}
			else {
				fse.copySync(dirPath + '/' + orgFileName, destDirectoryPath + '/' + destFileName);
			}
		}
	}
}

function copyFromZiptoFolder(zipper, destDirectoryPath) {
	createDirectoryIfNotExists(destDirectoryPath);
	const files = zipper.files;
	const keys = Object.keys(files);

	for (var i = 0; i < keys.length; ++i) {
		if (files[keys[i]].dir) {
			fs.mkdirSync(destDirectoryPath + '/' + files[keys[i]].name);
		}
	}

	// for (var i = 0; i < keys.length; ++i) {
	// 	if (files[keys[i]].dir) {
	// 		fs.mkdirSync(destDirectoryPath + '/' + files[keys[i]].name);
	// 	} else {

	// 		fs.writeFileSync(destDirectoryPath + '/' + files[keys[i]].name, files[keys[i]]._data, {
	// 			encoding: 'binary',
	// 		});
	// 	}
	// }

}

function createDirectoryIfNotExists(dirPath) {
	if (!fs.existsSync(dirPath)) {
		fs.mkdirSync(dirPath);
	}
}

exports.copyFile = copyFile;
exports.copyDirectory = copyDirectory;
exports.copyFromZiptoFolder = copyFromZiptoFolder;
exports.createDirectoryIfNotExists = createDirectoryIfNotExists;
exports.setFileMager = setFileMager;