const fs = require('fs');
const path = require('path');

const xml2js = require('xml2js');
const jsonlint = require("jsonlint");
const _ = require('underscore');

const syntaxErrorChecker = require('syntax-error');
const projectJSONCombiner = require('project-json-combiner');
const projectJSONValidator = require('project-json-validator');

const requireJSON = require('../requireJSON');
const iosImagesChecker = require("./iosImagesChecker");

const _Error = (function() {

	const _errorJson = requireJSON(__dirname, './error.json');

	if (!_errorJson) {
		throw new Error('JSON parse error');
	}

	function getObject(_key, opt) { // getter for error objects.
		const res = getSubObject(_errorJson, _key);
		if (opt) {
			return replacer(res, opt);
		}
		return res;
	}

	function getSubObject(_obj, _key) {
		const _keys = _key.split('.');
		var res = _obj;
		for (var i = 0; i < _keys.length; i++) {
			if (res) {
				res = res[_keys[i]];
			}
			else { // handle undefined .
				return undefined;
			}
		}
		return res;
	}

	function replacer(_obj, opt) { // replacer string in the  
		var err = opt.err,
			msg = opt.msg,
			helpForUser = opt.helpForUser;

		const errStr = replaceOne(err, _obj.err);
		const msgStr = replaceOne(msg, _obj.msg);
		const helpForUserStr = replaceOne(helpForUser, _obj.helpForUser);

		return _.extend({}, {
			"err": errStr,
			"msg": msgStr,
			"helpForUser": helpForUserStr,
			"os": _obj.os
		});

		function replaceOne(subObj, str) {
			if (subObj && str) {
				_.each(_.keys(subObj), function(item) {
					str = str.replace(createReg(item), subObj[item]);
				});
			}
			return str;

			function createReg(_str) {
				return new RegExp('\\$\\(' + _str + '\\)', 'gm');
			}
		}
	}

	function getMessage(_key, opt) { // getter message of error 
		const _obj = getObject(_key, opt);
		if (_obj) {
			return _obj.msg;
		}
		return undefined;
	}

	function getMsgForLogger(_key, _opt) {
		return getMsgForLoggerFromErr(getObject(_key, _opt));
	}

	function getMsgForLoggerFromErr(_obj) {
		var str = '';
		if (_obj) {
			str = _obj.err + '\n' + _obj.msg;

			if (_obj.fullPath) {
				str += '\n Path  : ' + _obj.fullPath;
			}
			if (_obj.detail) {
				str += '\n Detail: ' + _obj.detail;
			}
			if (_obj.helpForUser) {
				str += '\n help? : ' +
					_obj.helpForUser;
			}
		}
		return str;
	}

	/**
	 * Manipulates file object defined with these properties:
	 *	- path {string}
	 *	- exists {bool}
	 *	- isDir {bool}
	 *	- isImage {bool}
	 *  - isJson {bool}
	 *  - isValid {bool}
	 *	- errors {string[]}
	 *  - warnings {string[]}
	 * 
	 * @param {object} args
	 */
	function ErrorChecker(args) {
		var files = {},
			filesProcessed = 0,
			fileObject = {
				path: null,
				exists: null,
				isDir: null,
				isImage: null,
				isJson: null,
				isValid: null,
				errors: null,
				warnings: null
			},

			// Paths
			iOSScriptsPath,
			iOSImagesPath,
			androidScriptsPath,
			androidImagesPath,
			androidManifestPath,
			packageProfilesPath,

			// Args
			projectRoot = args.projectRoot || "/home/ubuntu/workspace",
			verbose = !!args.verbose,
			publishType = args.publishType, // Could be local, test or rau
			projectJSON = readProjectJSON(path.join(projectRoot, 'config/project.json'));

		this.done = function(callback) {
			init();

			checkSyntax(projectRoot, iOSScriptsPath);
			(iOSScriptsPath != androidScriptsPath) && checkSyntax(projectRoot, androidScriptsPath);

			checkImages(projectRoot, androidImagesPath);
			iosImagesChecker.checkImages(path.join(projectRoot, iOSImagesPath)).forEach(result => {
				result.path && (result.path = path.relative(projectRoot, result.path));
				files[filesProcessed++] = result;
			});
			checkProjectJSON(projectRoot, 'config', function(err, combinedProjectJSON) {
				if (err) return callback();

				checkProjectForPublish(combinedProjectJSON, function() {
					return callback();
				});
			});
		};

		this.getReport = function() {
			return JSON.stringify(files, null, "\t");
		};

		function checkProjectForPublish(combinedProjectJSON, callback) {
			if (!publishType) return callback();

			fileObject = {
				path: 'config/project.json',
				exists: true,
				isDir: false,
				isImage: false,
				isJson: true,
				isValid: false,
				errors: [],
				warnings: []
			};

			var testingDist = combinedProjectJSON.build.output.android.testingDistribution;

			if (publishType == "test") {
				if ((testingDist && !testingDist.packageProfileName) || !testingDist) {
					fileObject.errors.push("build/output/android/\
					testingDistribution/packageProfileName must be provided.");
					files[filesProcessed++] = fileObject;
					return callback();
				}
				else {
					var packageProfilesFullPath = path.join(projectRoot, packageProfilesPath);
					var packageProfilesContent = fs.readFileSync(packageProfilesFullPath).toString();
					xml2js.parseString(packageProfilesContent, function(err, result) {
						if (err) return callback();

						var profiles = result.packageProfiles.profile,
							profileExists = false,
							profileName;
						profiles.forEach(function(profile) {
							profileName = profile['$'].name;
							if (profileName == testingDist.packageProfileName) {
								profileExists = true;
							}
						});
						if (!profileExists) {
							fileObject.errors.push("packageProfileName \"" +
								testingDist.packageProfileName +
								"\" should be provided in " + packageProfilesPath +
								" as a profile name.");
							files[filesProcessed++] = fileObject;
						}
						return callback();
					});
				}
			}
			else {
				return callback();
			}
		}

		/**
		 * Reads project.json and returns it's contents as an object, 
		 * if an error occurs returns null
		 */
		function readProjectJSON(projectJSONPath) {
			var projectJSON;
			try {
				projectJSON = JSON.parse(fs.readFileSync(projectJSONPath).toString());
			}
			catch (ex) {
				projectJSON = null;
			}
			finally {
				return projectJSON;
			}
		}

		function init() {
			var fileObj;
			initPaths(projectJSON);

			fileObj = fileExists(projectRoot, 'config');
			if (!fileObj.exists || verbose) {
				fileObj.isDir = true;
				files[filesProcessed++] = fileObj;
			}
			else {
				fileObj = fileExists(projectRoot, 'config/Android');
				if (!fileObj.exists || verbose) {
					fileObj.isDir = true;
					files[filesProcessed++] = fileObj;
				}
				else {
					fileObj = fileExists(projectRoot, androidManifestPath);
					if (!fileObj.exists || verbose) {
						files[filesProcessed++] = fileObj;
					}
					fileObj = fileExists(projectRoot, packageProfilesPath);
					if (!fileObj.exists || verbose) {
						files[filesProcessed++] = fileObj;
					}
				}
				fileObj = fileExists(projectRoot, 'config/Fonts');
				if (!fileObj.exists || verbose) {
					fileObj.isDir = true;
					files[filesProcessed++] = fileObj;
				}
				fileObj = fileExists(projectRoot, 'config/project.json');
				if (!fileObj.exists || verbose) {
					files[filesProcessed++] = fileObj;
				}
				fileObj = fileExists(projectRoot, 'config/iOS');
				if (!fileObj.exists || verbose) {
					fileObj.isDir = true;
					files[filesProcessed++] = fileObj;
				}
			}

			//////////////////////////////

			fileObj = fileExists(projectRoot, 'images');
			if (!fileObj.exists || verbose) {
				fileObj.isDir = true;
				files[filesProcessed++] = fileObj;
			}
			else {
				fileObj = fileExists(projectRoot, androidImagesPath);
				if (!fileObj.exists || verbose) {
					fileObj.isDir = true;
					files[filesProcessed++] = fileObj;
				}
				fileObj = fileExists(projectRoot, iOSImagesPath);
				if (!fileObj.exists || verbose) {
					fileObj.isDir = true;
					files[filesProcessed++] = fileObj;
				}
			}

			//////////////////////////////

			fileObj = fileExists(projectRoot, 'plugins');
			if (!fileObj.exists || verbose) {
				fileObj.isDir = true;
				files[filesProcessed++] = fileObj;
			}
			else {
				fileObj = fileExists(projectRoot, 'plugins/Android');
				if (!fileObj.exists || verbose) {
					fileObj.isDir = true;
					files[filesProcessed++] = fileObj;
				}
				fileObj = fileExists(projectRoot, 'plugins/iOS');
				if (!fileObj.exists || verbose) {
					fileObj.isDir = true;
					files[filesProcessed++] = fileObj;
				}
			}

			//////////////////////////////

			fileObj = fileExists(projectRoot, iOSScriptsPath);
			if (!fileObj.exists || verbose) {
				fileObj.isDir = true;
				files[filesProcessed++] = fileObj;
			}
			else {
				fileObj = fileExists(projectRoot, path.join(iOSScriptsPath, 'app.js'));
				if (!fileObj.exists || verbose) {
					files[filesProcessed++] = fileObj;
				}
			}
			if (iOSScriptsPath != androidScriptsPath) {
				fileObj = fileExists(projectRoot, androidScriptsPath);
				if (!fileObj.exists || verbose) {
					fileObj.isDir = true;
					files[filesProcessed++] = fileObj;
				}
				else {
					fileObj = fileExists(projectRoot, path.join(androidScriptsPath, 'app.js'));
					if (!fileObj.exists || verbose) {
						files[filesProcessed++] = fileObj;
					}
				}
			}
		}

		function initPaths(projectJSON) {
			try {
				var index = projectJSON,
					iOS = index.build.input.ios,
					android = index.build.input.android,
					iOSImages = iOS.images,
					iOSScripts = iOS.scripts,
					androidImages = android.images,
					androidScripts = android.scripts,
					androidManifest = android.manifest,
					packageProfiles = android.packageProfiles;

				iOSImagesPath = !iOSImages ? 'images/iOS' : iOSImages;
				iOSScriptsPath = !iOSScripts ? 'scripts' : iOSScripts;
				androidImagesPath = !androidImages ? 'images/Android' : androidImages;
				androidScriptsPath = !androidScripts ? 'scripts' : androidScripts;
				androidManifestPath = !androidManifest ? 'config/Android/AndroidManifest.xml' : androidManifest;
				packageProfilesPath = !packageProfiles ? 'config/Android/PackageProfiles.xml' : packageProfiles;
			}
			catch (ex) {
				iOSImagesPath = 'images/iOS';
				iOSScriptsPath = 'scripts';
				androidImagesPath = 'images/Android';
				androidScriptsPath = 'scripts';
				androidManifestPath = 'config/Android/AndroidManifest.xml';
				packageProfilesPath = 'config/Android/PackageProfiles.xml';
			}
		}

		function walkSync(dir, filelist) {
			var files = fs.readdirSync(dir);
			filelist = filelist || [];
			files.forEach(function(file) {
				if (fs.statSync(dir + '/' + file).isDirectory()) {
					filelist = walkSync(dir + '/' + file, filelist);
				}
				else {
					filelist.push(path.relative(projectRoot, path.join(dir, file)));
				}
			});
			return filelist;
		}

		/**
		 * @param {string} projectRoot - Root dir
		 * @param {string} filePath - Relative path of the file
		 * @return {object} - Returns a fileObject
		 */
		function fileExists(projectRoot, filePath) {
			var fullPath = path.join(projectRoot, filePath);

			fileObject = {
				path: filePath,
				exists: null,
				isDir: null,
				isImage: null,
				isJson: null,
				isValid: null,
				errors: null,
				warnings: null
			};

			try {
				fs.accessSync(fullPath, fs.F_OK);
				fileObject.isDir = fs.lstatSync(fullPath).isDirectory();
				fileObject.exists = true;
			}
			catch (ex) {
				fileObject.exists = false;
			}

			return fileObject;
		}

		/**
		 * - If the object represents a source code, check for syntax errors but
		 * treat them as warnings.
		 * - If the file is app.js then treat them as errors.
		 * @param {string} projectRoot - Root dir of the workspace
		 * @param {string} srcPath - Relative path of the source code directory
		 */
		function checkSyntax(projectRoot, srcPath) {
			try {
				fs.accessSync(path.join(projectRoot, srcPath), fs.F_OK);
			}
			catch (e) {
				return;
			}

			var fileNames = [];
			walkSync(path.join(projectRoot, srcPath), fileNames);

			for (var fi = 0; fi < fileNames.length; ++fi) {
				if (fileNames[fi].indexOf("node_modules") > -1) {
					continue;
				}
				if (isSourceCode(fileNames[fi])) {
					var src = fs.readFileSync(path.join(projectRoot, fileNames[fi])),
						checkReport = syntaxErrorChecker(src, fileNames[fi]),
						warnings = [],
						errors = [];

					if (checkReport) {
						checkReport = checkReport.toString();
						if (checkReport.indexOf('app.js:') > -1) {
							errors.push(checkReport);
						}
						else {
							warnings.push(checkReport);
						}
					}

					fileObject = {
						path: fileNames[fi - filesProcessed],
						exists: true,
						isDir: false,
						isImage: false,
						isJson: false,
						isValid: true,
						errors: errors,
						warnings: warnings
					};

					if (verbose) {
						files[filesProcessed++] = fileObject;
					}
					else if (!verbose && (errors.length || warnings.length)) {
						files[filesProcessed++] = fileObject;
					}
				}
			}
		}

		/**
		 * @param {string} projectRoot - Full path of the workspace
		 * @param {string} imagePath - Relative path of the image directory
		 */
		function checkImages(projectRoot, imagePath) {
			try {
				fs.accessSync(path.join(projectRoot, imagePath), fs.F_OK);
			}
			catch (e) {
				return;
			}

			var imageNames = [];
			walkSync(path.join(projectRoot, imagePath), imageNames);

			for (var im = 0; im < imageNames.length; ++im) {
				var result = isValidImage(imageNames[im]);

				fileObject = {
					path: imageNames[im],
					exists: true,
					isDir: false,
					isImage: true,
					isJson: false,
					isValid: result.isValid,
					errors: result.errors,
					warnings: []
				};

				if (verbose) {
					files[filesProcessed++] = fileObject;
				}
				else if (!verbose && !fileObject.isValid) {
					files[filesProcessed++] = fileObject;
				}
			}
		}

		/**
		 * Checks the json file, finds the errors and warnings
		 * @param {string} projectRoot - Full path of the workspace
		 * @param {string} relPath - Relative path of the folder which includes json files
		 */
		function checkProjectJSON(projectRoot, relPath, callback) {
			var jsonValidator,
				fileNames = [],
				jsonFile,
				exception = null,
				reportObj = {
					errors: [],
					warnings: []
				};

			try {
				fs.accessSync(path.join(projectRoot, relPath), fs.F_OK);
				walkSync(path.join(projectRoot, relPath), fileNames);
			}
			catch (e) {
				return callback(e);
			}

			// Perform json lint checking
			fileNames.map(function(file) {
				if (isJsonFile(file)) {
					jsonFile = fs.readFileSync(path.join(projectRoot, file)).toString();
					try {
						jsonlint.parse(jsonFile);
					}
					catch (ex) {
						exception = ex;
						fileObject = {
							path: file,
							exists: true,
							isDir: false,
							isImage: false,
							isJson: true,
							isValid: false,
							errors: [ex.toString()],
							warnings: []
						};
						if ((!verbose && (fileObject.errors.length || fileObject.warnings.length)) || verbose) {
							files[filesProcessed++] = fileObject;
						}
					}
				}
			});
			// If json lint detects an error, don't perform further checkings
			if (exception) {
				return callback(exception);
			}
			else {
				try {
					projectJSONCombiner.getProjectJSON(path.join(projectRoot, relPath), fs, function(err, jsonObj) {
						if (!err) {
							jsonValidator = new projectJSONValidator.ProjectJSONValidator(jsonObj, "local");
							jsonValidator.fillOptionals();
							reportObj = jsonValidator.checkRequirements();
							fileObject = {
								path: 'project.json',
								exists: true,
								isDir: false,
								isImage: false,
								isJson: true,
								isValid: reportObj.errors.length === 0,
								errors: reportObj.errors,
								warnings: reportObj.warnings
							};
							if ((!verbose && (fileObject.errors.length || fileObject.warnings.length)) || verbose) {
								files[filesProcessed++] = fileObject;
							}
							return callback(null, jsonObj);
						}
						else {
							var jsonPath;
							err.currentFile ?
								jsonPath = path.relative(projectRoot, err.currentFile) :
								jsonPath = relPath;
							reportObj.errors.push(jsonPath + "Operation of combining the json files have failed");
							reportObj.errors.push(jsonPath + err.toString());
							fileObject = {
								path: jsonPath,
								exists: true,
								isDir: false,
								isImage: false,
								isJson: true,
								isValid: false,
								errors: reportObj.errors,
								warnings: reportObj.warnings
							};
							if ((!verbose && (fileObject.errors.length || fileObject.warnings.length)) || verbose) {
								files[filesProcessed++] = fileObject;
							}
							return callback(err);
						}
					});
				}
				catch (e) {
					fileObject = {
						path: 'project.json',
						exists: true,
						isDir: false,
						isImage: false,
						isJson: true,
						isValid: false,
						errors: ["Parsing have failed"],
						warnings: []
					};
					if ((!verbose && (fileObject.errors.length || fileObject.warnings.length)) || verbose) {
						files[filesProcessed++] = fileObject;
					}
					return callback(e);
				}
			}
		}

		/**
		 * Returns if the given relative path denotes a js source code or not
		 * @param {string} relPath - Relative path of the file (also could be full path)
		 */
		function isSourceCode(relPath) {
			var extension = path.extname(relPath);
			return extension === '.js';
		}

		/**
		 * Returns if the given relative path denotes a json file or not
		 * @param {string} relPath - Relative path of the file (also could be full path)
		 */

		function isJsonFile(relPath) {
			var extension = path.extname(relPath);
			return extension === '.json';
		}

		/**
		 * Returns an object with following properties:
		 * - isValid {bool}
		 * - errors {string[]}
		 * @param {string} relPath - Relative path of the image, something like:
		 * images/iOS/smartface.png
		 */
		function isValidImage(relPath) {
			relPath = relPath.split("/");

			var os = relPath[1];
			var imageName = relPath[relPath.length - 1];
			var extension = path.extname(imageName);
			var imageNameRaw = path.basename(imageName, extension);
			var result = {
				isValid: true,
				errors: []
			};

			if (extension !== '.png') {
				result.isValid = false;
				result.errors.push("Invalid image format, only png supported.");
			}
			if (os == "Android") {
				if (/\d/.test(imageName.charAt(0)) && imageName.charAt(0) !== '_') {
					result.isValid = false;
					result.errors.push("On Android, image name must begin with a small letter or an underscore.");
				}
				else if (!/^[a-z_][a-z0-9_]*([a-z0-9_]+)*$/.test(imageNameRaw)) {
					result.isValid = false;
					result.errors.push("On Android, image name can contain only lowercase letters, numbers and underscore.");
				}
			}
			return result;
		}
	}

	/**
	 * Gets the files or directories, performs error checking with the help of ErrorChecker
	 * @param {string} projectRoot - Full path of the workspace
	 * @param {requestCallback} callback - The callback that returns the report
	 */
	function getErrorReport(args, callback) {
		var errorChecker = new ErrorChecker(args);
		errorChecker.done(function() {
			callback(null, errorChecker.getReport());
		});
	}

	return {
		error: _errorJson,
		getMessage: getMessage,
		getObject: getObject,
		getMsgForLogger: getMsgForLogger,
		getMsgForLoggerFromErr: getMsgForLoggerFromErr,
		getErrorReport: getErrorReport
	};
})();

module.exports = _Error;
