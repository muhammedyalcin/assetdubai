Array.prototype.diff || (Array.prototype.diff = function(a) {
    return this.filter(function(i) { return a.indexOf(i) < 0; });
});

const fs = require("fs");
const path = require("path");

const jsonlint = require("jsonlint");

const reAsset = /\w+\.(?:imageset|appiconset|launchimage)/g;

const CONTENTSJSON_NAME = "Contents.json";

var REQUIRED_IMAGESET_FOLDER = [
    "AppIcon.appiconset",
    "LaunchImage.launchimage"
];

const tempalteFileObject = {
    path: "",
    exists: true,
    isDir: false,
    isImage: false,
    isJson: false,
    isValid: false,
    errors: [],
    warnings: []
};

function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

function getNameRegex(setFolderName) {
    return new RegExp(`${escapeRegExp(setFolderName)}(@\dx){0,1}`, "g");
}
/*
function getiOSImageInfo(name) {
    var fileInfo = path.parse(name);
    var multiplier = 1;
    reAsset.lastIndex = 0; //requires reset before any reuse
    if (reAsset.test(name)) { //is an asset image
        var contents = getContentsJSON(name);
        var imageRecord;
        var assetName = path.parse(path.dirname(name)).name;

        for (var i = 0; i < contents.images.length; i++) {
            imageRecord = contents.images[i];
            if (imageRecord.filename === fileInfo.base) {
                multiplier = Number(imageRecord.scale[0]);
                var ret = {
                    multiplier: multiplier,
                    name: assetName,
                    assetName: assetName
                };
                return ret;
            }
        }
    }
}
*/
function checkAssetImageOneSet(imageFolder, setFolder) {
    var results = [],
        contentJSonExist = false,
        imageFiles = [],
        contentJsonImages;
    const setFolderPath = path.join(imageFolder, setFolder);
    reAsset.lastIndex = 0;
    if (reAsset.test(setFolder)) {
        var files = fs.readdirSync(setFolderPath);
        files.forEach(file => {
            if (file === CONTENTSJSON_NAME) {
                contentJSonExist = true;
                var contentsJsonRes = checkContentsJson(path.join(setFolderPath, file));
                if (contentsJsonRes.errors.length || contentsJsonRes.warnings.length) {
                    results.push(Object.assign({}, tempalteFileObject, {
                        path: path.join(setFolderPath, file),
                        isJson: true,
                        errors: contentsJsonRes.errors,
                        warnings: contentsJsonRes.warnings
                    }));
                }
                else {
                    contentJsonImages = contentsJsonRes.images;
                }
            }
            else {
                var stats = fs.statSync(path.join(setFolderPath, file));
                if (path.extname(file) !== '.png' || stats.isDirectory()) {
                    results.push(Object.assign({}, tempalteFileObject, {
                        path: path.join(setFolderPath, file),
                        isDir: stats.isDirectory(),
                        isImage: true,
                        errors: ["Invalid image format, only png supported."]
                    }));
                }
                else {
                    imageFiles.push(file);
                }
            }
        });
        if (!contentJSonExist) {
            results.push(Object.assign({}, tempalteFileObject, {
                path: path.join(setFolderPath, CONTENTSJSON_NAME),
                exists: false,
            }));
        }
    }
    else {
        results.push(Object.assign({}, tempalteFileObject, {
            path: setFolderPath,
            isImage: true,
            isDir: true,
            errors: ["Invalid imageset folder "]
        }));
    }

    if (contentJsonImages) {
        var folderName = path.parse(setFolder).name;
        var nameRegex = getNameRegex(folderName);
        imageFiles = REQUIRED_IMAGESET_FOLDER.indexOf(setFolder) === -1 ? imageFiles.filter(imageFile => {
            nameRegex.lastIndex = 0;
            var imageName = path.parse(imageFile).name;
            if (nameRegex.test(imageName)) {
                return true;
            }
            results.push(Object.assign({}, tempalteFileObject, {
                path: path.join(setFolderPath, imageFile),
                isImage: true,
                errors: [`invalid name -> '${imageName}'! name must be '${folderName}'`]
            }));
            return false;
        }) : imageFiles;
        var diff1 = contentJsonImages.diff(imageFiles);
        var diff2 = imageFiles.diff(contentJsonImages);
        diff1.forEach(item => {
            results.push(Object.assign({}, tempalteFileObject, {
                path: path.join(setFolderPath, item),
                isImage: true,
                warnings: [`This is missing in '${setFolder}'! Check '${setFolder}/Contents.json'`]
            }));
        });
        diff2.forEach(item => {
            results.push(Object.assign({}, tempalteFileObject, {
                path: path.join(setFolderPath, item),
                isImage: true,
                warnings: [`This is missing in '${setFolder}/Contents.json'!`]
            }));
        });
    }

    return results;
}

function checkAssetImageSets(imageFolder) {
    var results = [];
    var resRequiredFolder = {
        "AppIcon.appiconset": false,
        "LaunchImage.launchimage": false
    };
    var folders = fs.readdirSync(imageFolder);
    folders.forEach(folder => {
        results = results.concat(checkAssetImageOneSet(imageFolder, folder));
        REQUIRED_IMAGESET_FOLDER.indexOf(folder) !== -1 && (resRequiredFolder[folder] = true);
    });
    for (var key in resRequiredFolder) {
        !resRequiredFolder[key] && results.push(Object.assign({}, tempalteFileObject, {
            path: path.join(imageFolder, key),
            exists: false,
            isDir: true
        }));
    }
    return results;
}

function checkContentsJson(_path) {
    var result = { errors: [], images: [], warnings: [] },
        contentsJson;
    try {
        contentsJson = jsonlint.parse(fs.readFileSync(_path, "utf8"));
    }
    catch (exp) {
        result.errors.push(exp.toString());
        return result;
    }
    var images = contentsJson.images;
    if (typeof images === "object" && (images instanceof Array)) {
        images.forEach((image, index) => {
            image.filename ? result.images.push(image.filename) :
                result.errors.push(`'filename' property of the ${index+1}. image is missing`);
        });
    }
    else {
        result.errors.push("'images' property is missing or invalid (must be an array)");
    }
    return result;
}

module.exports = {
    checkImages: checkAssetImageSets
};
