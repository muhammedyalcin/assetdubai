const fs = require("fs");

const cmncCmd = require("./wsCommunaciationCmd");
const util = require("../utility");
const ProgressInfo = require('../progressinfo.js');

const COMMUNICATION = cmncCmd.COMMUNICATION;
const COMMAND = cmncCmd.COMMAND;


function handleWSCommands(ws, token, outputs, cloudBuildConfig) {

  const channels = cloudBuildConfig.config.channels,
    writer = cloudBuildConfig.writer,
    saveBinary = cloudBuildConfig.saveBinary,
    playerPath = cloudBuildConfig.playerPath;

  return new Promise((resolve, reject) => {

    var timeOutObj = new TimeOut(10 * 60000, () => {
      reject(new Error("The connection with the Cloud Machine has timed out. Please try again. "));
    });

    ws.on('open', function open() {
      ws.send('CONNECT' + cmncCmd.BRACKET + token);
    });

    var wrtStream;
    var expectedLen = outputs.length;
    var countOutput = 0;
    var error = null,
      fatal = null;
    var ouputPaths = [];
    var keepAliveTimer;
    var completed = false;
    var proginfo = null;
    var binaryReceiving = false;

    ws.on('message', function(data, flags) {
      var cmnc;
      timeOutObj.keepAlive();
      if (!flags.binary) {
        //console.log("RECEIVED: " + data);
        cmnc = cmncCmd.parse(data);
      }
      else {
        proginfo && (proginfo.update(data.length));
        wrtStream.write(data);
      }
      cmnc && messageCommandHandler(cmnc);

    });

    ws.on('close', function close() {
      timeOutObj.end();
      clearInterval(keepAliveTimer);
      if (fatal) {
        reject(new Error("Fatal Error -> " + fatal));
      }
      else if (error) {
        reject(new Error("Cloud Build Error -> " + error));
      }
      else if (completed) {
        resolve(ouputPaths);
      }
      else {
        reject(new Error("Cloud Build Machine Error -> connection lost."));
      }
    });

    function messageCommandHandler(cmnc) {
      var type = cmnc.type;
      var cmd = cmnc.cmd;

      switch (type) {
        case COMMUNICATION.COMMAND:
          switch (cmd) {
            case COMMAND.READY: // CBM ready for binary creation.
              keepAliveTimer = sendKeepAlive();
              timeOutObj.start();
              util.writeJsonMsgToStdout("Starting Cloud Build...");
              ws.send(cmncCmd.createCmd(COMMAND.RUN));
              break;
            case COMMAND.GET_BINARY: // get binary from CBM
              util.writeJsonMsgToStdout("Custom player sending...");
              var stats = fs.statSync(playerPath);
              proginfo && (proginfo.finish());
              proginfo = new ProgressInfo(stats["size"], "Player sending", writerProgress);
              proginfo.start();
              sendBinary(ws, playerPath, err => {
                err;
              });
              break;
            case COMMAND.COMPLETED: // binary creation completed.
              if (saveBinary) {
                ws.send(cmncCmd.createCmd(COMMAND.SAVE_BINARY)); // store submission from CBM to storage
                completed = true;
              }
              else {
                ws.send(cmncCmd.createCmd(COMMAND.GET_BINARY));
                binaryReceiving = true;
              }
              break;
            case COMMAND.FILE_START: // binary will be received
              var outputfile = outputs.shift();
              ouputPaths.push(outputfile);
              wrtStream = fs.createWriteStream(outputfile);
              break;
            case COMMAND.FILE_END: // binary received
              wrtStream.end();
              writer(ouputPaths[countOutput], channels[countOutput]);
              ++countOutput;
              if (countOutput === expectedLen) {
                ws.send(cmncCmd.createCmd(COMMAND.END));
                completed = true;
                ws.close();
              }
              else {
                ws.send(cmncCmd.createCmd(COMMAND.GET_BINARY));
                binaryReceiving = true;
              }
              break;
            case COMMAND.KEEPALIVE: // keepalive...
              timeOutObj.keepAlive();
              break;
            case COMMAND.OK: // run command reply
              break;
            default:
              util.writeJsonToStdout({
                warning: "Unhandled Command",
                msg: "received command from CBM -> " + cmd
              });
          }
          break;
        case COMMUNICATION.FILE: // file chunk or full size.
          if (binaryReceiving) {
            proginfo && (proginfo.finish());
            proginfo = new ProgressInfo(cmd, "Receiving binary", writerProgress);
            proginfo.start();
          }
          else if (proginfo) {
            proginfo.update(Number(cmd));
          }
          break;
        case COMMUNICATION.INFO: // info messages from CBM
          util.writeJsonMsgToStdout(cmd, "CBM");
          break;
        case COMMUNICATION.ERROR: // error message
          error = cmd;
          ws.close();
          break;
        case COMMUNICATION.FATAL: // fatal error message
          fatal = cmd;
          ws.close();
          break;
        case COMMUNICATION.DONE: // done all process.
          ws.close();
          break;
        default:
          util.writeJsonToStdout({
            warning: "Unhandled Comunaciation Type",
            msg: "received comunaciation type from CBM -> " + type
          });
      }
    }

  });

  //check keepalve
  function sendKeepAlive() {
    return setInterval(() => {
      ws.send(cmncCmd.createCmd(COMMAND.KEEPALIVE));
    }, 30000);
  }

}
//send binary
function sendBinary(ws, filePath, onEndFile) {
  ws.send(cmncCmd.createCmd(COMMAND.FILE_START));
  const rdStream = fs.createReadStream(filePath);
  rdStream
    .on('data', function(chunk) {
      ws.send(chunk, {
        binary: true
      });
    })
    .on('end', function() {
      ws.send(cmncCmd.createCmd(COMMAND.FILE_END), onEndFile);
    });
}

//timeout obj.
function TimeOut(ms, timeOut) {
  var timeisup = false;
  var stopped = false;
  var interval = null;
  var _timeOut = (typeof timeOut === "function") ? timeOut : () => {

  };

  this.keepAlive = () => {
    //util.writeJsonMsgToStdout("keeped alive .. " + timeisup);
    timeisup = false;
  };

  this.stop = (bool) => {
    stopped = bool;
  };

  this.start = () => {
    interval = setInterval(() => {
      //util.writeJsonMsgToStdout("INTERVAL_TIMEOUT: " + timeisup);
      if (stopped)
        return;
      if (timeisup) {
        _timeOut();
      }
      else {
        timeisup = true;
      }
    }, ms);
  };

  this.end = function() {
    if (interval) {
      clearInterval(interval);
    }
  };

}

function writerProgress(data) {
  if (util.LogStatus.getOutJson()) {
    util.writeJsonMsgToStdout(data.replace(/\s+/g, " "));
  }
  else {
    process.stdout.write(data);
  }
}

module.exports = handleWSCommands;
