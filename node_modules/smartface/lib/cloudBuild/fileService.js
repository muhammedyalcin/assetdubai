const path = require("path");
const https = require("https");

const rmdir = require("rmdir");
const fs = require("fs-extra");
const forge = require("node-forge");

const util = require("../utility");

const OK = 200;
/**
 * @function downloadFile
 * download file.
 * @param url {string|object} url of source file | options
 * @param dest {string} path of dest file
 * @param options {object} you can pass your https.
 * @return {object} promise of result.
 */

function downloadFile(url, dest, _opt) {

  var opt = _opt || {};
  var myHttps = opt.https || https;

  return new Promise(function(resolve, reject) {
    util.mkdirpSync(path.dirname(dest));
    var file = fs.createWriteStream(dest);

    myHttps.get(url, function(response) {
      if (response.statusCode === OK) {
        response.pipe(file);
        file.on('finish', function(err) {
          if (err) {
            //log("files is not downloaded " + path.basename(dest));
            return reject(err);
          }
          //log("files is downloaded " + path.basename(dest));
          resolve(response.headers);
        });
      }
      else {
        var str = "";
        response.on("data", (chunk) => {
          str += chunk;
        });
        response.on("end", () => {
          str = util.parseJSONForMessage(str);
          reject(new Error("Cloud Build API Service For Android Error -> " + str));
        });
      }
    }).on('error', function(err) {
      fs.unlink(dest);
      reject(err);
    });

  });

}
/**
 * @function move
 * move src file to dest .
 * @param src {string} path of source file
 * @param dest {string} path of dest file
 * @return {object} promise of result.
 */
function move(src, dest) {
  return new Promise(function(resolve, reject) {
    fs.move(src, dest, (err) => {
      if (err) {
        reject(err);
      }
      else {
        resolve(dest);
      }
    });

  });
}


/**
 * @function md5
 * md5 of file.
 * @param src {string} path of source file
 * @return {object} promise of result.
 */
function md5(_filePath, callback) {
    var md = forge.md.md5.create();
    var resPromise, resolver, rejecter;
    if (!callback) {
        resPromise = new Promise((resolve, reject) => {
            resolver = resolve;
            rejecter = reject;
        });
    }
    var rdStream = fs.createReadStream(_filePath, {
        encoding: "binary"
    });
    
    rdStream.on("data", (data) => {
        md.update(data);
    });
    
    rdStream.on("end", () => {
        var res = md.digest().toHex();
        if (resPromise) {
            resolver(res);
        }
        else {
            callback(null, res);
        }
    });
    
    rdStream.on("error", err =>{
        if (resPromise) {
            rejecter(err);
        }else{
          callback(err);
        }
    });
    
    return resPromise;
}


/**
 * @function getReadStream
 * readable stream.
 * @param _filePath {string} path of source file
 * @return {object} readable stream
 */
function getReadStream(_filePath) {
  const readStream = fs.createReadStream(_filePath);
  return readStream;
}

/**
 * @function readFile
 * read file
 * @param _filePath {string} path of source file
 * @param encoding {string} encoding
 * @return {object} promise of result
 */
function readFile(filePath, encoding) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, encoding, (err, res) => {
      if (err) {
        reject(err);
      }
      else {
        resolve(res);
      }
    });
  });
}

/**
 * @function writeFile
 * write file
 * @param _filePath {string} path of source file
 * @param data {string|buffer} data will be wirtten.
 * @return {object} promise of result
 */
function writeFile(filePath, data) {
  return new Promise((resolve, reject) => {
    fs.writeFile(filePath, data, (err) => {
      if (err) {
        reject(err);
      }
      else {
        resolve(null);
      }
    });
  });
}
/**
 * @function clearSafelyDirFile
 * if fileDir is exists  then remove it
 * @param dirFile {string} path of fileDir that will be removed.
 * @return {object} promise of result
 */
function clearSafelyDirFile(dirFile) {
  return new Promise((resolve, reject) => {
    util.isExistsFileDir(dirFile).then(stat => {
      if (stat.file) {
        fs.unlink(dirFile, (err) => {
          if (err) {
            return reject(err);
          }
          resolve("file is removed.");
        });
      }
      else if (stat.dir) {
        rmdir(dirFile, (err) => {
          if (err) {
            return reject(err);
          }
          resolve("directory is removed.");
        });
      }
      else {
        resolve("fileOrDir ENOENT");
      }
    }, reject);
  });
}




module.exports = {
  clearSafelyDirFile: clearSafelyDirFile,
  readFile: readFile,
  writeFile: writeFile,
  downloadFile: downloadFile,
  move: move,
  md5: md5,
  getReadStream: getReadStream
};
