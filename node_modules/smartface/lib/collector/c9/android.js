const fs = require('fs');
const path = require('path');
const _ = require('underscore');
const TAG = require('../tag');
const Parser = require('../../xmltojson');
const killProcess = require('../../utility').killProcess;
const utility = require('../../utility');
const error = require('../../error');

const SFPX = TAG.SFPX;
const LICENSE = TAG.LICENSE;
const PACKAGE_PROFILES = TAG.PACKAGE_PROFILES;

const PLATFORM = require("os").platform();
const ZIP_ALING = {
	"win32": "zipalign-win32.exe",
	"linux": "zipalign-linux",
	"darwin": "zipalign-darwin"
};

// update config object from sfpx file.
function configUpdateFromConfigJson(config, processedArgs) {
	const project = config.user.project;
	var manifest = config.androidConfig.input.manifest;
	var edit = manifest.edit;
	const config2 = config.config2;
	const config_json = processedArgs.config_json;
	try {
		manifest.data = fs.readFileSync(project.root + '/' + config_json.build.input.android.manifest, 'utf8');
	}
	catch (e) {
		killProcess(_.extend(error.getObject('android.manifest'), {
			"fullPath": path.normalize(project.root + '/' + config_json.build.input.android.manifest)
		}));
	}
	if (config_json.build.output.android.packageName && config_json.build.output.android.packageName != "") {
		edit.packageName = config_json.build.output.android.packageName;
	}
	else {
		var jsonObj = {
			err: "output.android.packageName is not defined",
			msg: "packageName in package.json file must be defined to publish android projects"
		};
		utility.killProcess(jsonObj);
	}
	//TODO: change this call to globalData.set
	_.extend(edit, {
		"appName": config_json.info.name,
		"googleMapKey": config_json.api.googleMaps.androidKey,
		"appVersion": config2.appVersion,
		"appDescription": config2.appDescription,
		"orientation": decideScreenOriention(config2.orientation)
	});
}

function decideScreenOriention(orientation) {
	// orientation rules. control function return orientation value.
	var res = '';
	if ((orientation.portrait || orientation.upsideDown) &&
		(orientation.landScapeLeft || orientation.landScapeRight)) {
		res = 'fullSensor';
	}
	else if (orientation.portrait && orientation.upsideDown) {
		res = 'sensorPortrait';
	}
	else if (orientation.landScapeLeft && orientation.landScapeRight) {
		res = 'sensorLandscape';
	}
	else if (orientation.portrait) {
		res = 'portrait';
	}
	else if (orientation.upsideDown) {
		res = 'reversePortrait';
	}
	else if (orientation.landScapeLeft) {
		res = 'landscape';
	}
	else if (orientation.landScapeRight) {
		res = 'reverseLandscape';
	}
	else {
		killProcess(error.getObject('orientation'));
	}
	return res;
}

// application license from license file.
function configUpdateFromLicense(config, license) {
	const licenseObj = new Parser().parse(license);
	const appLicenseObj = licenseObj.findObjectHasTargetObject(LICENSE.APP_PACKAGE_LICENSE_TAG, LICENSE.PACKAGE_TYPE_TAG, 'Android');
	var input = config.androidConfig.input;
	//TODO: change this call to globalData.set
	_.extend(input.license, {
		"data": appLicenseObj.createXmlString(),
		"type": appLicenseObj.findObject(LICENSE.LICENSE_TYPE_TAG).getContent(),
		"name": appLicenseObj.findObject(LICENSE.LICENSE_NAME_TAG).getContent(),
		"bundle": config.androidConfig.input.manifest.edit.packageName
	});
}

function configUpdateFromArgs(config, processedArgs) {
	var input = config.androidConfig.input;
	var output = config.androidConfig.output;
	const root = config.user.project.root + '/';
	const config_json = processedArgs.config_json;
	const buildInput = config_json.build.input.android;
	//TODO: change this call to globalData.set
	_.extend(input, {
		"config": path.normalize(root + "config/Android"),
		"assets": path.normalize(root + buildInput.assets),
		"scripts": path.normalize(root + buildInput.scripts),
		"images": path.normalize(root + buildInput.images),
		"packageProfileFile": path.normalize(root + buildInput.packageProfiles),
		"apkTool": path.normalize(processedArgs.APK_TOOL),
		"plugins": processedArgs.Android_PLUGINS,
		"inputApk": processedArgs.INPUT_APK
			// "inputApk": path.normalize(processedArgs.INPUT_APK),
			// "inputApkx86": path.normalize(processedArgs.INPUT_APK_x86) || path.normalize(processedArgs.INPUT_APK.replace('.apk', '-x86.apk'))
	});

	const inputFolder = processedArgs.COMP_INPUT_FOLDER;
	input.extractor.inputApk = processedArgs.DECOMP_INPUT_APK; // decompiler.
	const tmpFolder = inputFolder.replace('SmartfacePlayer', '');
	//TODO: change this call to globalData.set
	_.extend(input.builder, {
		"inputFolder": inputFolder, // compiler.
		"tmpFolder": tmpFolder,
		"smfData": tmpFolder + 'data.smf',
		"smfSplash": tmpFolder + 'splash.smf',
		"sqlite": input.assets + '/database.sqlite',
		"defaultsXml": path.normalize(root + 'config/defaults.xml')
	});
	//TODO: change this call to globalData.set
	_.extend(input.sign, {
		"inputApk": path.normalize(processedArgs.COMP_OUTPUT_APK), // signer.
		"signer": path.normalize(processedArgs.SIGNER),
		"keystoreFile": path.normalize(processedArgs.KEYSTORE_FILE),
		"keystorePass": processedArgs.KEYSTORE_PASS,
		"aliasName": processedArgs.ALIAS_NAME,
		"keyPass": processedArgs.KEY_PASS
	});
	if (processedArgs.MAX_JAVA_MEM) {
		const res = /^[0-9]{1,}[gmk]$/.exec(processedArgs.MAX_JAVA_MEM);
		if (!res) {
			var errObj = error.getObject("maxJavaMemory");
			errObj.msg += processedArgs.MAX_JAVA_MEM;
			killProcess(errObj);
		}
	}
	_.extend(input.zipalign, {
		"path": path.join(__dirname, "..", "..", "..", "bin", ZIP_ALING[PLATFORM]),
		"inputApk": path.normalize(processedArgs.ZIPALING_INPUT_APK)
	});
	_.extend(input.java, {
		"path": path.normalize(processedArgs.JAVA),
		"maxMemory": processedArgs.MAX_JAVA_MEM
	});

	output.outputApk = path.normalize(processedArgs.OUTPUT_APK.replace(/smartface.apk/gm, input.license.name + '.apk'));
	output.builder.outputApk = processedArgs.COMP_OUTPUT_APK;
	output.sign.outputApk = processedArgs.SIGN_OUTPUT_APK;
	output.extractor.outputFolder = processedArgs.DECOMP_OUTPUT_FOLDER;
	input.extractor.inputApk = input.inputApk;
}

function getSupportImagesFromPackageProfilesXML(profileObj) { // PackageProfiles.xml get folder names.
	var res = [];
	const andObj = profileObj.findObjects(PACKAGE_PROFILES.FOLDER_TAG);
	for (var i = 0; i < andObj.length; ++i) {
		res.push(andObj[i].getAttribute(PACKAGE_PROFILES.ATTR_FOLDER_NAME_TAG).split('/')[1]);
	}
	return res;
}


function configUpdateFoldersAndProfiles(config) {
	var input = config.androidConfig.input;
	const packageProfilesObj = new Parser().parse(input.packageProfileFile);
	if (!packageProfilesObj.isParsed()) {
		killProcess(_.extend(error.getObject('android.packageProfiles'), {
			"fullPath": input.packageProfileFile
		}));
	}
	const profiles = packageProfilesObj.findObjects(PACKAGE_PROFILES.PROFILE_TAG);
	input.packageProfiles = [];
	_.each(profiles, function(item) {
		if (item.getAttribute(PACKAGE_PROFILES.ATTR_PROFILE_NAME_TAG)) {
			input.packageProfiles.push({
				profile: {
					name: item.getAttribute(PACKAGE_PROFILES.ATTR_PROFILE_NAME_TAG),
					folders: getSupportImagesFromPackageProfilesXML(item)
				}
			});
		}
		else {
			input.packageProfiles.push({
				profile: {
					name: item.getAttribute(PACKAGE_PROFILES.ATTR_PROFILE_NAME_TAG_BC),
					folders: getSupportImagesFromPackageProfilesXML(item)
				}
			});

		}
	});
}

// automatic detect your profiles in your PackageProfiles.xml
function configureProfilesForPublishFromPackageProfilesXML(config) {

	function getProfileCpuTypes(profileObj) {
		var cpu = {
			arm: false,
			x86: false
		};
		const andObj = profileObj.findObject(PACKAGE_PROFILES.ANDROID_TAG);
		cpu.arm = Boolean(Number(andObj.getAttribute(PACKAGE_PROFILES.ATTR_CPU_TYPE_ARM)));
		cpu.x86 = Boolean(Number(andObj.getAttribute(PACKAGE_PROFILES.ATTR_CPU_TYPE_X86)));
		return cpu;
	}

	var input = config.androidConfig.input;
	const packageProfilesObj = new Parser().parse(input.packageProfileFile);
	if (!packageProfilesObj.isParsed()) {
		killProcess(_.extend(error.getObject('android.packageProfiles'), {
			"fullPath": input.packageProfileFile
		}));
	}
	// get profiles.
	const profiles = packageProfilesObj.findObjects(PACKAGE_PROFILES.PROFILE_TAG);
	var userProfiles = config.user.profiles;
	var tempName = "";
	var tempCPU;
	_.each(profiles, function(item) {
		// get profile name.
		tempName = item.getAttribute(PACKAGE_PROFILES.ATTR_PROFILE_NAME_TAG);
		// get cpu types that will be published.
		tempCPU = getProfileCpuTypes(item);
		if (tempCPU.arm || tempCPU.x86) {
			if (_.findIndex(userProfiles, function(o) {
					return o.name == tempName.trim();
				}) !== -1) {
				utility.killProcess(error.getObject("android.profileName", {
					msg: {
						profileName: tempName
					},
					helpForUser: {
						packageProfiles: input.packageProfileFile
					}
				}));
			}
			userProfiles.push({
				name: tempName,
				x86: tempCPU.x86,
				arm: tempCPU.arm
			});
		}

	});

}


module.exports = {
	configUpdateFoldersAndProfiles: configUpdateFoldersAndProfiles,
	configUpdateFromArgs: configUpdateFromArgs,
	configUpdateFromLicense: configUpdateFromLicense,
	configUpdateFromConfigJson: configUpdateFromConfigJson,
	configureProfilesForPublishFromPackageProfilesXML: configureProfilesForPublishFromPackageProfilesXML
};
