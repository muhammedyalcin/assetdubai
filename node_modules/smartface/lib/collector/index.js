const _ = require('underscore');
const argumentParser = require('../argumentparser');
const utility = require('../utility');
const error = require('../error');
const globalData = require('../globalData');

const platformSpecificCollectorModule = {
	'c9': './c9/index',
	'darwin': './c9/index',
	'linux': './c9/index',
	'win32': './windows/index'
};

const taskCollecttor = {
	"create_iOSPlugin": "getConfigForCreateiOSPlugin",
	"generate_iOSPluginZip": "getConfigForGenerateiOSPluginZip",
	"generate_AndroidPluginZip": "getConfigForGenerateAndroidPluginZip"
};

function collect() {
	const args = globalData.get('args');
	const platform = globalData.get('args.platform');
	const collector = require(platformSpecificCollectorModule[platform]);
	const processedArgs = argumentParser();
	globalData.set('processedArgs', processedArgs);
	const publishConfig = globalData.get("publishConfig");
	var config = args;

	if ((processedArgs.TASK === 'Android-publish') || (publishConfig && publishConfig.android)) {
		config = collector.getConfigForAndroidFullPublish(processedArgs);
		globalData.set('androidConfig', config);
	}

	if ((processedArgs.TASK === 'iOS-publish') || (publishConfig && publishConfig.iOS)) {
		config = collector.getConfigForIOSFullPublish(processedArgs);
		globalData.set('iosConfig', config);
	}

	if (taskCollecttor[args.task]) {
		config = collector[taskCollecttor[args.task]](args);
	}
	return config;
}

function profileCollector(argsProfiles, packageProfiles) {
	var res = [];
	const validProfiles = getAllProfilesFromPackageProfiles();
	if (argsProfiles === '*') {
		_.each(packageProfiles, function(item) {
			res.push({
				name: item.profile.name,
				x86: true
			}, {
				name: item.profile.name,
				x86: false
			});
		});
	}
	else {
		const x86AllProfile = (argsProfiles.x86.indexOf('*') !== -1); // all profiles ?
		const armAllProfile = (argsProfiles.arm.indexOf('*') !== -1);
		if (!x86AllProfile) { // x86 profiles not include '*'
			_.each(argsProfiles.x86, function(item) {
				validaterProfile(item);
				res.push({
					name: item,
					x86: true
				});
			});
		}
		if (!armAllProfile) { // arm profiles not include '*'
			_.each(argsProfiles.arm, function(item) {
				validaterProfile(item);
				res.push({
					name: item,
					x86: false
				});
			});
		}
		if (armAllProfile || x86AllProfile) {
			_.each(packageProfiles, function(item) { // all profiles in packageProfiles
				if (armAllProfile) {
					res.push({
						name: item.profile.name,
						x86: false
					});
				}
				if (x86AllProfile) {
					res.push({
						name: item.profile.name,
						x86: true
					});
				}
			});
		}
	}
	return res;

	function getAllProfilesFromPackageProfiles() { // get profiles from PackageProfiles.xml
		var _res = [];
		_.each(packageProfiles, function(item) {
			_res.push(item.profile.name);
		});
		return _res;
	}

	function validaterProfile(_profName) { // validater .
		if (validProfiles.indexOf(_profName) === -1) {
			utility.killProcess(error.getObject('android.profileCheck', {
				msg: {
					profileName: _profName
				}
			}));
		}
	}
}

module.exports = {
	collect: collect,
	profileCollector: profileCollector
};
