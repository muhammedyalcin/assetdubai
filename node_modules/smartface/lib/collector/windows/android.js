const fs = require('fs');
const path = require('path');

const _ = require('underscore');
const TAG = require('../tag');
const Parser = require('../../xmltojson');
const utility = require('../../utility');
const error = require('../../error');

const SFPX = TAG.SFPX;
const LICENSE = TAG.LICENSE;
const PACKAGE_PROFILES = TAG.PACKAGE_PROFILES;

// update config object from sfpx file.
function configUpdateFromSfpx(config) {
	const project = config.user.project;
	utility.throwsNoSuchFile(project.sfpx);
	const sfpxObj = new Parser().parse(project.sfpx); // the most commonly used object.
	var manifest = config.androidConfig.input.manifest;
	var edit = manifest.edit;
	const config2 = config.config2;
	try {
		manifest.data = fs.readFileSync(project.root + '/AndroidManifest.xml', 'utf8');
	} catch (e) {
		utility.killProcess(_.extend(error.getObject('android.manifest'), {
			"fullPath": path.normalize(project.root + '/AndroidManifest.xml')
		}));
	}
	_.extend(edit, {
		"appName": sfpxObj.findObject(SFPX.APP_NAME_TAG).getAttribute(SFPX.ATTR_APP_NAME_TAG),
		"googleMapKey": sfpxObj.findObject(SFPX.MAP_API_TAG).getAttribute(SFPX.ATTR_ANDROID_MAP_KEY_TAG),
		"appVersion": config2.appVersion,
		"appDescription": config2.appDescription,
		"orientation": decideScreenOriention(config2.orientation)
	});
}

function decideScreenOriention(orientation) { // orientation rules. control function return orientation value.
	var res = '';
	if ((orientation.portrait || orientation.upsideDown) &&
		(orientation.landScapeLeft || orientation.landScapeRight)) {
		res = 'fullSensor';
	} else if (orientation.portrait && orientation.upsideDown) {
		res = 'sensorPortrait';
	} else if (orientation.landScapeLeft && orientation.landScapeRight) {
		res = 'sensorLandscape';
	} else if (orientation.portrait) {
		res = 'portrait';
	} else if (orientation.upsideDown) {
		res = 'reversePortrait';
	} else if (orientation.landScapeLeft) {
		res = 'landscape';
	} else if (orientation.landScapeRight) {
		res = 'reverseLandscape';
	} else {
		//logger.fatal(error.getMsgForLogger('orientation'));
		utility.killProcess(error.getObject('orientation'));
	}
	return res;
}

// application license from license file.
function configUpdateFromLicense(config, licenseFilePath) {
	utility.throwsNoSuchFile(licenseFilePath);
	const licenseObj = new Parser().parse(licenseFilePath);
	const appLicenseObj = licenseObj.findObjectHasTargetObject(LICENSE.APP_PACKAGE_LICENSE_TAG, LICENSE.PACKAGE_TYPE_TAG, 'Android');
	var input = config.androidConfig.input;
	_.extend(input.license, {
		"data": appLicenseObj.createXmlString(),
		"type": appLicenseObj.findObject(LICENSE.LICENSE_TYPE_TAG).getContent(),
		"name": appLicenseObj.findObject(LICENSE.LICENSE_NAME_TAG).getContent().replace('&amp;', '&'),
		"bundle": appLicenseObj.findObject(LICENSE.PACKAGE_NAME_TAG).getContent()
	});
	_.extend(input.manifest.edit, {
		"packageName": appLicenseObj.findObject(LICENSE.PACKAGE_NAME_TAG).getContent()
	});
}

function configUpdateFromArgs(config, args) {
	var input = config.androidConfig.input;
	var output = config.androidConfig.output;
	const root = config.user.project.root;

	_.extend(input, {
		"assets": root + '/Assets',
		"scripts": root + '/Scripts',
		"images": root + '/resources/Images/android',
		"apkTool": args.APK_TOOL,
		"plugins": args.Android_PLUGINS,
		"inputApk": args.INPUT_APK,
		"inputApkx86": args.INPUT_APK_x86
	});
	if (args.MAX_JAVA_MEM) {
		const res = /^[0-9]{1,}[gmk]$/.exec(args.MAX_JAVA_MEM);
		if (!res) {
			var errObj = error.getObject("maxJavaMemory");
			errObj.msg += args.MAX_JAVA_MEM;
			utility.killProcess(errObj);
		}
	}
	_.extend(input.java, {
		"path": args.JAVA,
		"maxMemory": args.MAX_JAVA_MEM
	});

	input.extractor.inputApk = args.DECOMP_INPUT_APK; // decompiler.
	input.builder.inputFolder = args.COMP_INPUT_FOLDER; // compiler.

	_.extend(input.sign, {
		"inputApk": args.SIGN_INPUT_APK, // signer.
		"signer": args.SIGNER,
		"keystoreFile": args.KEYSTORE_FILE,
		"keystorePass": args.KEYSTORE_PASS,
		"aliasName": args.ALIAS_NAME,
		"keyPass": args.KEY_PASS
	});
	_.extend(input.zipalign, {
		"path": path.join(__dirname, "..", "..", "..", "bin", "zipalign-win32.exe"),
		"inputApk": path.normalize(args.SIGN_INPUT_APK)
	});
	
	if (args.OUTPUT_APK === 'Smartface Demo.apk') {
		const appName = path.normalize(args.OUTPUT_APK.replace(/Smartface Demo.apk/gm, input.license.name + '.apk'));
		if (process.env.USERPROFILE) {
			getDocumentsPath(function(data){
				 output.outputApk = data+ input.license.name + '/Android/' + appName;
			});
		} else {
			output.outputApk = utility.convertAbsolute.convert('Smartface/Published Projects/' +
				input.license.name +
				'/Android/' + appName);
		}
	} else {
		output.outputApk = args.OUTPUT_APK;
	}
	output.builder.outputApk = args.COMP_OUTPUT_APK;
	output.sign.outputApk = args.SIGN_OUTPUT_APK;
	output.extractor.outputFolder = args.DECOMP_OUTPUT_FOLDER;
}

function getSupportImagesFromPackageProfilesXML(profileObj) { // PackageProfiles.xml get folder names.
	var res = [];
	const andObj = profileObj.findObjects(PACKAGE_PROFILES.FOLDER_TAG);
	for (var i = 0; i < andObj.length; ++i) {
		res.push(andObj[i].getAttribute(PACKAGE_PROFILES.ATTR_FOLDER_NAME_TAG).split('/')[1]);

	}
	return res;
}

function getDocumentsPath(callback){
	try{
		var execSync = require('child_process').execSync('reg query "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders" /v "Personal"');
		var streamOut = execSync.toString().trim();
		var path = streamOut.split('\n')[1];
		path = path.trim();
		path = path.substring(path.indexOf('REG_SZ')+6,path.length);
		path = path.trim();
		callback(path+'/Smartface/Published Projects/');
	}
	catch(e){
		callback(process.env.USERPROFILE +'/Documents/Smartface/Published Projects/');
	}
}


function configUpdateFoldersAndProfiles(config) {
	var input = config.androidConfig.input;
	const root = config.user.project.root;

	_.extend(input, {
		"assets": root + '/Assets',
		"scripts": root + '/Scripts',
		"images": root + '/resources/Images/android'
	});

	const packageProfilesObj = new Parser().parse(root + '/PackageProfiles.xml');
	if (!packageProfilesObj.isParsed()) {
		utility.killProcess(_.extend(error.getObject('android.packageProfiles'), {
			"fullPath": path.normalize(root + '/PackageProfiles.xml')
		}));
	}
	const profiles = packageProfilesObj.findObjects(PACKAGE_PROFILES.PROFILE_TAG);
	input.packageProfiles = [];
	_.each(profiles, function(item) {
		if(item.getAttribute(PACKAGE_PROFILES.ATTR_PROFILE_NAME_TAG)){
			input.packageProfiles.push({
			profile: {
				name: item.getAttribute(PACKAGE_PROFILES.ATTR_PROFILE_NAME_TAG),
				folders: getSupportImagesFromPackageProfilesXML(item)
			}
		});
		}
		else{
			input.packageProfiles.push({
			profile: {
				name: item.getAttribute(PACKAGE_PROFILES.ATTR_PROFILE_NAME_TAG_BC),
				folders: getSupportImagesFromPackageProfilesXML(item)
			}
		});

		}
	});
}

module.exports = {
	configUpdateFoldersAndProfiles: configUpdateFoldersAndProfiles,
	configUpdateFromArgs: configUpdateFromArgs,
	configUpdateFromLicense: configUpdateFromLicense,
	configUpdateFromSfpx: configUpdateFromSfpx
};