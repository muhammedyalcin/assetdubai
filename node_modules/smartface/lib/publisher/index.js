const _ = require('lodash');
var g = require('idle-gc');

const utility = require('../utility');
const commonHelper = require("./common");
const checker = require("./check");
const SERVER_CONFIG = require("../configuration").SERVER;

const logger = require('../log/log4j').getLogger('Publisher'); // logger.
const rauPlayers = require("./rau-store-players");

const globalData = require('../globalData');
const FileManager = require("./managefiles").FileManager;
const uploader = require("./uploader");
const createDummyPromise = utility.createDummyPromise;
const iOSPublish = require("./ios");
const andPublish = require("./android");
const serviceAPI = require("./service/apiService");
const error = require("../error");


globalData.set("moduleGlobals.tempfilemanager", new FileManager());


const OK = 200;
const ACCEPTED = 202;

module.exports = function(publishCallBack) {
  var IDE_TOKEN = globalData.get("publishConfig.token") || (process.env.SMF_TOKEN ? "Bearer " + process.env.SMF_TOKEN : null);
  const TMP_DIR = globalData.get("moduleGlobals.tmpdir");
  const publishConfig = globalData.get("publishConfig");
  var projectjSon = null;
  var mixedRauBinaries = null;
  const isCloudBuildiOS = publishConfig.cloudBuild.provisioningProfileID >= 0 ? true : false;

  publishConfig.IDE_TOKEN = IDE_TOKEN;
  publishConfig.TMP_DIR = TMP_DIR;
  publishConfig.isCloudBuildiOS = isCloudBuildiOS;
  publishConfig.isCloudBuildAndroid = publishConfig.cloudBuild.keystoreID >= 0 ? true : false;
  utility.StdoutLogger.setLogger(logger);

  //console.inspect(globalData.get("iosConfig"));
  function publishForiOS() {
    if (!publishConfig.iOS) {
      return createDummyPromise();
    }
    var iosProjectJSON = _.cloneDeep(projectjSon);
    return new Promise((resolve, reject) => {
      commonHelper
        .prepareTemplateCombinedProjectJSON(iosProjectJSON, mixedRauBinaries, "iOS", publishConfig.configRAU.revision)
        .then(res => {
          res = null;
          global.gc && global.gc();
          iOSPublish(publishConfig, iosProjectJSON, (err, res) => {
            if (err) {
              return reject(err);
            }
            resolve(res);
          });
        }, reject);
    });
  }

  function publishForAndroid() {
    if (!publishConfig.android) {
      return createDummyPromise();
    }
    var androidProjectJSON = _.cloneDeep(projectjSon);
    return new Promise((resolve, reject) => {
      commonHelper
        .prepareTemplateCombinedProjectJSON(androidProjectJSON, mixedRauBinaries, "Android", publishConfig.configRAU.revision)
        .then(res => {
          res = null;
          global.gc && global.gc();
          andPublish(publishConfig, androidProjectJSON, (err, res) => {
            if (err) {
              return reject(err);
            }
            resolve(res);
          });
        }, reject);
    });
  }

  function preparePublish() {
    return Promise.series([ // publishes ios - Android
      utility.createClearDir.bind(null, TMP_DIR),
      commonHelper.combineProjectJSON.bind(null, projectjSon)
    ]);
  }

  function buildiOSAndroid() {
    return Promise.all([publishForiOS(), publishForAndroid()]);
  }

  function publish(callBack) {
  
    g.start(1000 * 30); /*  30 sec interval */
    Promise
      .series([ // publishes ios - Android
        checker.controlProjectJSON.bind(null, publishConfig, projectjSon),
        checker.validatePlugins.bind(null),
        setup.bind(null),
        checker.controlProfile.bind(null, publishConfig),
        checker.controlForRau.bind(null, publishConfig),
        serviceAPI.receiveTokenFromIDE.bind(null, publishConfig),
        serviceAPI.isAuthTestDist.bind(null, publishConfig),
        serviceAPI.receiveRevisionNum.bind(null, publishConfig),
        serviceAPI.checkEnterpriseAppStore.bind(null, publishConfig),
        /*publishForiOS.bind(null),
        publishForAndroid.bind(null),
        */
        buildiOSAndroid.bind(null),
        commonHelper.prepareAndWriteRauJson.bind(null, publishConfig, projectjSon, mixedRauBinaries),
        commonHelper.prepareContentZip.bind(null, publishConfig),
        uploadRAU.bind(null),
        rauPlayersStoreAndCreateNotesMD.bind(null),
        commonHelper.cleanup.bind(null),
      ]).then(res => {
        g.stop();
        callBack(null);
      }, callBack);
  }

  //store rau players. and createrau-notes.md file
  function rauPlayersStoreAndCreateNotesMD() {
    if (publishConfig.justPublish) {
      return createDummyPromise();
    }
    else {
      var promises = [];
      if (publishConfig.iOS) {
        promises.push(stroeForOnerOS("iOS"));
      }
      if (publishConfig.android) {
        promises.push(stroeForOnerOS("Android"));
      }
    }

    function stroeForOnerOS(os) {
      return rauPlayers
        .storePlayer(os, projectjSon)
        .then(res => {
          if (res) {
            return rauPlayers.createRAU_NotesMD(os, projectjSon.info.version, publishConfig.configRAU.revision, res);
          }
          else {
            return new Promise((resolve, reject) => {
              resolve(null);
            });
          }
        }, err => {
          throw err;
        });
    }
    return Promise.all(promises);
  }

  //setup configs, and initializations.
  function setup() {
    var resPromise = createDummyPromise();
    publishConfig.configRAU = _.cloneDeep(projectjSon.config.rau);
    publishConfig.releaseChannels = (publishConfig.justPublish || publishConfig.sendToTest) ?
      (publishConfig.channels !== null) ? publishConfig.channels : [projectjSon.config.rau.currentReleaseChannel] : publishConfig.configRAU.channels;
    mixedRauBinaries = _.cloneDeep(publishConfig.configRAU)["binary"] = {
      "players": {},
      "plugins": {
        "iOS": {},
        "Android": {}
      }
    };
    publishConfig.mixedRauBinaries = mixedRauBinaries;
    publishConfig.willBeUploadedFiles = [];
    if (!isCloudBuildiOS && (publishConfig.sendToTest || publishConfig.sendToStore) && publishConfig.iOS) {
      resPromise = createDummyPromise({
        err: publishConfig.sendToTest ? "Testing Distribution Error" : "App Store Error",
        msg: "For iOS, only IPA file can be sent to " + (publishConfig.sendToTest ? "testing distribution." : "app store."),
        helpForUser: "You should publish with cloud build."
      });
    }
    if (publishConfig.sendToTest || publishConfig.sendToStore) {
      publishConfig.outputNumToTestDist = 0;
      if (publishConfig.android) {
        var profiles = globalData.get("androidConfig.user.profiles");
        publishConfig.outputNumToTestDist += publishConfig.releaseChannels.length * profiles.length;
      }
      if (publishConfig.iOS) {
        publishConfig.outputNumToTestDist += publishConfig.releaseChannels.length;
      }
    }
    return resPromise;
  }

  function uploadRAU() {
    var resPromise = createDummyPromise();
    if (!publishConfig.justPublish) {
      utility.writeJsonMsgToStdout('Preparing output files...');
      resPromise = new Promise((resolve, reject) => {
        uploader(publishConfig.willBeUploadedFiles, getUploadOptions(), (err, jobID) => {
          if (err) {
            return utility.killProcess(getErrObjectIfCodeIsNotOK(err, "rau.server.upload", err.message));
          }
          checkRauUploadResult(publishConfig, jobID).then(res => {
            utility.writeJsonToStdout({
              msg: "Upload successful.",
              responseDone: true,
              allDone: false
            });
            resolve(null);
          }, reject);
        });
      });
    }
    return resPromise;
  }

  function checkRauUploadResult(publishConfig, jobID) {
    return new Promise((resolve, reject) => {
      
      utility.writeJsonMsgToStdout("Checking RAU result...");
      var timer = setInterval(function() {
        utility.writeJsonMsgToStdout("Checking RAU result...");
        serviceAPI.checkRauUploadResult(publishConfig, jobID).then(res => {
          //utility.writeJsonToStdout(res);
          switch (res.statusCode) {
            case 200:
              clearInterval(timer);
              resolve(res.statusMessage);
              break;
            case 202:
              utility.writeJsonMsgToStdout("Still processing...");
              break;
            default:
              clearInterval(timer);
              utility.killProcess(getErrObjectIfCodeIsNotOK(res, "rau.server.upload", res.message));
          }
        }, reject);
      }, 10 * 1000 /* 10 secs */ );
    });
  }
  // detecting errors for response status code
  function getErrObjectIfCodeIsNotOK(res, errDotObj, msg) {
    var err;
    var code = res.statusCode;
    if ((code !== OK) && (code !== ACCEPTED)) {
      if (code >= 500) {
        err = Object.assign(error.getObject("unexpectedServer", {
          msg: {
            "statusCode": res.statusCode,
            "statusMessage": res.statusMessage
          }
        }), {
          detail: parseJSONForMessage(msg)
        });
      }
      else {
        err = error.getObject(errDotObj, {
          msg: {
            "statusCode": res.statusCode,
            "statusMessage": res.statusMessage
          },
          helpForUser: {
            msg: parseJSONForMessage(msg)
          }
        });
      }
    }
    return err;

    function parseJSONForMessage(msg) {
      var res;
      try {
        var parsedObj = JSON.parse(msg);
        res = parsedObj.Message || parsedObj.message;
      }
      catch (e) {}!res && (res = msg);
      return res;
    }
  }

  function getUploadOptions() {
    var host_ = SERVER_CONFIG.portalapi;
    var path_ = "/api/v1/rau/profiles/keys/" + publishConfig.configRAU.profileKey;
    var options = {
      host: host_,
      path: path_,
      headers: {
        Authorization: publishConfig.IDE_TOKEN,
        Prefer: "respond-async"
      },
      method: "post"
    };
    return options;
  }
  // start point.
  preparePublish().then(res => {
    projectjSon = res[1];
    publishConfig.projectjSon = projectjSon;
    publish(publishCallBack);
  }, publishCallBack);

};
