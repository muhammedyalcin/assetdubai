const fs = require('fs');
const path = require('path');
const xpath = require("xpath");
const xmldom = require("xmldom");
const DOMParser = xmldom.DOMParser;
const XMLSerializer = xmldom.XMLSerializer;

if (!String.prototype.startsWith) {
	String.prototype.startsWith = function(searchString, position) {
		position = position || 0;
		return this.indexOf(searchString, position) === position;
	};
}

function handleManifest(pluginContext, pluginManifestDoc, baseManifest) {
	const applicationPackageName = pluginContext.applicationPackageName;
	const pluginPackageName = xpath.select("/manifest/@package", pluginManifestDoc)[0].value;
	var application_name;
	pluginContext.pluginPackageName = pluginPackageName;
	replaceIfValueMatches(pluginManifestDoc, '//permission', startsWithGenerator(pluginPackageName + '.'), function(str) {
		return str.replace(new RegExp('^' + pluginPackageName + '.'), applicationPackageName + '.');
	});
	replaceIfValueMatches(pluginManifestDoc, '//uses-permission', startsWithGenerator(pluginPackageName + '.'), function(str) {
		return str.replace(new RegExp('^' + pluginPackageName + '.'), applicationPackageName + '.');
	});
	replaceIfValueMatches(pluginManifestDoc, '//category', startsWithGenerator(pluginPackageName), function(str) {
		return str.replace(new RegExp('^' + pluginPackageName + '$'), applicationPackageName);
	});
	//handle conflict for provider.
	replaceIfValueMatches(pluginManifestDoc, '//provider', startsWithGenerator(pluginPackageName), function(str) {
		return str.replace(new RegExp('^' + pluginPackageName), applicationPackageName);
	});
	pluginContext.mainActivityReplacer = changeMainActivityToPackageBundleGenerator(pluginContext, pluginManifestDoc, pluginPackageName);
	const nodes = xpath.select("//application", pluginManifestDoc);
	if (nodes.length > 0) {
		application_name = nodes[0].getAttribute('android:name');
	}

	const baseManifestDoc = new DOMParser().parseFromString(baseManifest.doc);
	const mainActivityNode = xpath.select("//activity[intent-filter/category/@*[local-name()='name']='android.intent.category.LAUNCHER']", baseManifestDoc);
	if (mainActivityNode.length > 0) {
		const theme = mainActivityNode[0].getAttribute("android:theme");
		if (theme !== "" && !theme.match(/\/Theme\.AppCompat/g)) {
			checkStylesIfThemeIsAppCompat(pluginContext, theme, function(err) {
				throw (new Error('Plugins can just use Theme.AppCompat as application theme.'));
			});
		}
	}

	if (application_name && application_name !== 'android.support.multidex.MultiDexApplication') {
		changeManifestOfSmartface(pluginContext, application_name, baseManifest);
		pluginContext.moveApplicationSmali = true;
		pluginContext.applicationName = application_name;
	}
}

function changeMainActivityToPackageBundleGenerator(pluginContext, pluginManifestDoc, pluginPackageName) {
	const mainActivity = getMainActivity(pluginManifestDoc, pluginPackageName);
	if (!mainActivity) {
		return false;
	}
	const rgxCommaReplacer = /[.]/gm;
	const pluginActivityWithSlashes = mainActivity.replace(rgxCommaReplacer, '/');
	const smartfaceActivityWithSlashes = pluginContext.applicationPackageName.replace(rgxCommaReplacer, '/');
	const regex_str = '(new\-instance v[0-9]{1,}\, Landroid/content/Intent\;' +
		'[\\\s]{1,}' +
		'const\-class v[0-9]{1,}\, L)(' + pluginActivityWithSlashes + ')';
	const rgxPluginActivityWithSlashes = new RegExp(regex_str, 'gm');
	return function(str) {
		return str.replace(rgxPluginActivityWithSlashes, '$1' + smartfaceActivityWithSlashes + '/A');
	};
}

function changeManifestOfSmartface(pluginContext, application_name, baseManifest) {
	if (pluginContext.applicationManifestPluginChangedName === 1) {
		throw (new Error('Cannot have 2 plugins that act as an application.'));
	}
	pluginContext.applicationManifestPluginChangedName = 1;
	const pluginManifest = baseManifest.doc;
	const pluginManifestDoc = new DOMParser().parseFromString(pluginManifest);
	const nodes = xpath.select("//application", pluginManifestDoc);
	nodes[0].setAttribute('android:name', application_name);
	const s = new XMLSerializer();
	baseManifest.doc = s.serializeToString(pluginManifestDoc);
}

function replaceIfValueMatches(pluginManifestDoc, xquery, check, replace) {
	const results = xpath.select(xquery, pluginManifestDoc);
	for (var i = 0; i < results.length; i++) {
		var result = results[i];
		if (result.attributes) {
			for (var j = 0; j < result.attributes.length; j++) {
				var attribute = result.attributes[j];
				if (check(attribute.value)) {
					attribute.value = replace(attribute.value);
				}
			}
		}
	}
}

function startsWithGenerator(str) {
	return function(val) {
		if (val && val.startsWith(str)) {
			return true;
		}
		return false;
	};
}

function getMainActivity(doc, pluginPackageName) {
	const selector = "//activity[intent-filter/category/@*[local-name()='name']='android.intent.category.LAUNCHER']";
	const nodes = xpath.select(selector, doc);
	var mainActivity = nodes[0].getAttribute('android:name');
	if (mainActivity[0] === '.') {
		mainActivity = pluginPackageName + mainActivity;
	}
	return mainActivity;
}

function checkStylesIfThemeIsAppCompat(pluginContext, theme, callback) {
	const themeNameArr = /@style\/(.*)/.exec(theme);
	if (!themeNameArr) {
		return;
	}
	const themeName = themeNameArr[1];
	walkStyles(pluginContext, path.join(pluginContext.path, "res"), function(results) {
		results.forEach(function(file) {
			const doc = fs.readFileSync(file, "utf-8");
			if (!checkStyleFileThemeCompatibility(doc, themeName, true)) {
				throw (new Error('Plugins can just use Theme.AppCompat as application theme.'));
			}
		});
	});
}

function checkStyleFileThemeCompatibility(stylesDoc, theme, firstTime) {
	if (!stylesDoc.match(new RegExp("name=\\\"" + theme + "\\\""))) {
		if (firstTime) {
			return true;
		}
		else {
			return false;
		}
	}
	const resultArr = (new RegExp("name=\\\"" + theme + "\\\" parent=\\\".*\\/(.*)\\\"")).exec(stylesDoc);
	if (!resultArr) {
		return false;
	}
	if (resultArr[1].match(/^Theme.AppCompat/g)) {
		return true;
	}
	else {
		return checkStyleFileThemeCompatibility(stylesDoc, resultArr[1], false);
	}
}

function walkStyles(pluginContext, dir, done) {
	var list = fs.readdirSync(dir);
	var stylesList = [];
	for (var i = 0; i < list.length; i++) {
		if (list[i].match(/^values.*/)) {
			var valuesList = fs.readdirSync(path.join(dir, list[i]));
			valuesList.forEach(function(file) {
				if (file.match(/^styles\.xml$/)) {
					stylesList.push(path.join(dir, list[i], file));
				}
			});
		}
		else {
			list.splice(i--, 1);
		}
	}
	done(stylesList);
}

module.exports = {
	handleManifest: handleManifest
};
