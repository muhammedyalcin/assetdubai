const path = require("path");

const rmdir = require('rmdir');
const _ = require('lodash');

const utility = require('../../utility');
const createDummyPromise = utility.createDummyPromise;
const globalData = require('../../globalData');
const logger = require('../../log/log4j').getLogger('Publisher'); // logger.
const copy = require("../../copy.js");
const error = require("../../error");
const cloudBuild = require("../../cloudBuild");
const doSendToServer = require("../sendtoserver");
const doCloudBuildForAndroid = require("./docloudBuild");

const AndroidPublisher = require('./androidpublisher');
const DELAY = 5000;

function andPublish(publishConfig, projectjSon, publishCallback) {
  const andPublisher = new AndroidPublisher();

  publishConfig.apkOutputs = [];
  var releaseChannels = publishConfig.releaseChannels;
  const IDE_TOKEN = publishConfig.IDE_TOKEN;
  const TMP_DIR = publishConfig.TMP_DIR;

  const cpuTypeMessages = ["ARM", "x86", "ARM - x86"];
  var config = globalData.get('androidConfig');
  var configAnd = globalData.get('androidConfig.androidConfig');
  var output = globalData.get('androidConfig.androidConfig.output');
  var alreadyLibCopied = false;
  const libFolder = {
    "ARM": "armeabi",
    "x86": "x86"
  };
  var libFolderDeletedStatus = {
    "ARM": false,
    "x86": false
  };
  const PLAYER_LIB_FOLDER = path.join(configAnd.output.extractor.outputFolder, "lib");
  // if  x86 & ARM no need copy/delete libs.
  var profiles = _.sortBy(config.user.profiles, function(p) {
    return !(p.x86 && p.arm);
  });
  profiles = _.sortBy(profiles, function(p) {
    return !p.arm;
  });
  setCorrectProfileForTestingDistribution(publishConfig, projectjSon);
  if (publishConfig.androidCloudBuild) {

    return Promise
      .all([doCloudBuildForAndroid(publishConfig, projectjSon),
        prepareScriptsForRAUAndroid(publishConfig, andPublisher)
      ])
      .then(results => {
        var cloudRes = results[0];
        publishConfig.apkOutputs = cloudRes.slice();
        publishConfig.willBeUploadedFiles = publishConfig.willBeUploadedFiles.concat(cloudRes.slice());
        finalize();
      }, err => {
        publishCallback(err.err ? err : {
          err: "Cloud Build Android Error",
          msg: err.stack ? err.stack : err.toString()
        });
      });
  }
  andPublisher.startPublish();
  utility.writeJsonToStdout({
    msg: "Starting Android Publish...",
    nextProfile: true
  });
  utility.writeJsonMsgToStdout("Extracting Player archive...");
  andPublisher.apkExtractor();
  utility.writeJsonMsgToStdout("Collecting project files...");
  //start profile publish.
  global.gc && global.gc();
  configureSignBytheKeystore(publishConfig).then(res => {
    profilePublish(publishCallback);
  }, publishCallback);

  function profilePublish(profileCallback) { // profile publish recursively.
    const currentProfile = profiles.shift();
    const currentCPUType = detectCpuType(currentProfile);
    const profileIndex = getProfileIndex(currentProfile,
      config.androidConfig.input.packageProfiles);
    var msg = 'Profile: ';
    if (currentProfile.arm && currentProfile.x86) {
      msg += cpuTypeMessages[2];
    }
    else if (currentProfile.arm) {
      msg += cpuTypeMessages[0];
    }
    else {
      msg += cpuTypeMessages[1];
    }
    msg += currentProfile.name + ' ...';
    logger.debug(msg);
    utility.writeJsonToStdout({
      nextProfile: currentProfile.name,
      cpuType: currentCPUType
    });

    if (isNeedCopyLibs(currentCPUType)) {
      copyLibsToTempDir();
      alreadyLibCopied = true;
    }
    //remove unused ib if needed
    removeUnusedLib(currentCPUType, function(err) {
      if (err) {
        return publishCallback(err);
      }
      //copy lib if needed
      copyLibToPublishFolder(currentCPUType);
      utility.writeJsonMsgToStdout("Updating Android manifest file...");
      andPublisher.updateManifest();
      utility.writeJsonMsgToStdout("Creating config file...");
      andPublisher.createConfig2Bin();
      utility.writeJsonMsgToStdout("Copying scripts...");
      andPublisher.updateScripts(); // copy
      utility.writeJsonMsgToStdout("Copying assets...");
      andPublisher.updateAssets(); // copy
      utility.writeJsonMsgToStdout("Copying misc files...");
      andPublisher.updateOtherFiles(config); // copy
      utility.writeJsonMsgToStdout("Copying images...");
      andPublisher.updateImages(profileIndex); // copy
      utility.writeJsonMsgToStdout("Copying license file...");
      if(global.gc) {
        utility.writeJsonMsgToStdout("Garbage Collector is working...");
        global.gc();
      }
      andPublisher.updateLicenseXML(function() { // create license.xml
        andPublisher.finishPublish(function() {
          andPublisher.clearUnusedFilesSync();
          _.each(releaseChannels, function(channel) {
            projectjSon.config.rau.currentReleaseChannel = channel;
            andPublisher.writeCombinedProjectJSON(projectjSon);
            utility.writeJsonMsgToStdout("Updating project.json...");
            prepareOutputApkName(channel, currentProfile);
            utility.writeJsonMsgToStdout("Collected all project files. Building binary...");
            delayIfNeed();
            andPublisher.apkBuilder();
            delayIfNeed();
            utility.writeJsonMsgToStdout("Binary build complete. Signing binary...");
            andPublisher.apkSigner(); // sign
            delayIfNeed();
            utility.writeJsonMsgToStdout("Binary sign complete. Aligning binary...");
            andPublisher.apkAlign();
            utility.writeJsonToStdout({
              msg: "Binary (APK) creation complete.",
              responseDone: true,
              finishedTask: {
                os: "Android",
                releaseChannel: channel,
                cpu: currentCPUType,
                downloadFilePath: output.zipalign.outputApk
              },
              allDone: false
            });
            //console.inspect(projectjSon);
          });

          if (profiles.length == 0) {
            return finalize();
          }
          else {
            profilePublish(publishCallback);
          }
        });
      });
    });
  }
  //detect current cpu type.
  function detectCpuType(profile) {
    var res;
    if (profile.x86 && profile.arm) {
      res = "all";
    }
    else if (profile.x86) {
      res = "x86";
    }
    else {
      res = "ARM";
    }
    return res;
  }
  //prepare output apk name by release channels
  function prepareOutputApkName(channel, profile) {
    var output = globalData.get("androidConfig.androidConfig.output");
    var outputPath = utility.createOutPathByTheProfile(output.outputApk, profile);
    output.zipalign.outputApk = utility.outputPathByChannel(outputPath, channel);
    publishConfig.apkOutputs.push(output.zipalign.outputApk);
    publishConfig.willBeUploadedFiles.push(output.zipalign.outputApk);
  }
  //is need to copy libs
  function isNeedCopyLibs(currentCPUType) {
    var res = false;
    if (!alreadyLibCopied) {
      if (currentCPUType !== "all") {
        var oppIndex = _.findIndex(profiles, function(o) {
          return o[getOpposite(currentCPUType)];
        });
        if (oppIndex !== -1) {
          res = true;
        }
      }
    }
    return res;
  }
  // get profile index in packageProfiles.
  function getProfileIndex(profile, packageProfiles) {
    var res = -1;
    for (var i = 0; i < packageProfiles.length; ++i) {
      if (profile.name === packageProfiles[i].profile.name) {
        res = i;
        break;
      }
    }
    return res;
  }
  // copying armeabi/ x86/ files to tmp
  function copyLibsToTempDir() {

    var dest = path.join(TMP_DIR, "lib");
    //utility.writeJsonMsgToStdout("Libs is chached...");
    copy.copyDirectory(PLAYER_LIB_FOLDER, dest, null, null, true);
  }
  //remove unused lib
  function removeUnusedLib(currentCPUType, _cb) {

    var oppCpuType = getOpposite(currentCPUType);

    if ((currentCPUType !== "all") && (!libFolderDeletedStatus[oppCpuType])) {
      libFolderDeletedStatus[oppCpuType] = true;
      rmdir(path.join(PLAYER_LIB_FOLDER, libFolder[oppCpuType]), (err) => {
        if (err && err.code !== "ENOENT") {
          _cb(err);
        }
        else {
          _cb(null);
        }
      });
    }
    else {
      _cb(null);
    }
  }
  //copying lib to folder for publishing if needed.
  function copyLibToPublishFolder(currentCPUType) {

    if ((currentCPUType !== "all") && libFolderDeletedStatus[currentCPUType]) {
      var source = path.join(TMP_DIR, "lib", libFolder[currentCPUType]);
      var dest = path.join(PLAYER_LIB_FOLDER, libFolder[currentCPUType]);

      copy.copyDirectory(source, dest, null, null, true);

      libFolderDeletedStatus[currentCPUType] = false;
    }
  }
  //get opposite cpu type
  function getOpposite(currentCPUType) {
    if (currentCPUType === "x86") {
      return "ARM";
    }
    else {
      return "x86";
    }
  }

  function finalize() {
     if(publishConfig.saveBinary)
            utility.writeJsonToStdout({
              finishedTask:{
                os:"Android",
                releaseChannel: publishConfig.releaseChannels[0],
                downloadFilePath: "NONE"
              }
            });
    if (publishConfig.sendToTest || publishConfig.sendToStore) {
      sendOutputToDist(publishConfig, publishCallback);
    }
    else {
      publishCallback(null, "finished.");
    }
  }

  function delayIfNeed() {
    if (publishConfig.isCloudBuildiOS) {
      utility.delay(DELAY);
    }
  }
}

// check & configure testProfile.
function setCorrectProfileForTestingDistribution(publishConfig, projectjSon) {
  if (publishConfig.sendToTest) {
    var testingDistribution = projectjSon.build.output.android.testingDistribution;
    var profiles = globalData.get("androidConfig.user.profiles");
    if (testingDistribution && (typeof testingDistribution.packageProfileName === "string")) {
      var testProfileName = testingDistribution.packageProfileName;
      var profileIndex = _.findIndex(profiles, function(o) {
        return o.name === testProfileName;
      });
      if (profileIndex !== -1) { // create arrray with testprofile.
        globalData.set("androidConfig.user.profiles", [profiles[profileIndex]]);
      }
      else {
        utility.killProcess(error.getObject("test.notExistsProfile", {
          msg: {
            profileName: testProfileName
          }
        }));
      }
    }
    else {
      utility.killProcess(error.getObject("test.profileProp"));
    }
  }
}

function configureSignBytheKeystore(publishConfig) {
  var resPromise = createDummyPromise();
  if (publishConfig.isCloudBuildAndroid && publishConfig.android) {
    resPromise = cloudBuild(publishConfig.IDE_TOKEN, "Android", {
      id: publishConfig.cloudBuild.keystoreID
    }).then(res => {
      return res;
    }, err => {
      throw (err.err ? err : {
        err: "Cloud Build Android Error",
        msg: err.stack ? err.stack : err.toString()
      });
    });
  }
  return resPromise;
}

function sendOutputToDist(publishConfig, _callBack) {
  var type = publishConfig.sendToTest ? "test" : "store";
  return doSendToServer({
    type: type,
    android: publishConfig.android,
    androidPID: type === "test" ? publishConfig.androidTPID : publishConfig.androidEPID,
    apks: publishConfig.apkOutputs
  }, publishConfig.IDE_TOKEN, _callBack);
}

function prepareScriptsForRAUAndroid(publishConfig, andPublisher) {
  return new Promise((resolve, reject) => {
    if (!publishConfig.justPublish) {
      andPublisher.startPublish();
      andPublisher.updateScripts();
    }
    resolve(null);
  });
}


module.exports = andPublish;
