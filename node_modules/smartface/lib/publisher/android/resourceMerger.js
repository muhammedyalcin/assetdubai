const fs = require("fs");
const path = require("path");

var mergedArrayInformations = [];
var currentArrayNames = [];
var mergedSingleValueArrayInformations = [];
var currentSingleValueHex = [];

function mergeResourceSmaliFiles(pluginSmaliDoc, playerSmaliDoc, publicXmlPath, smaliName) {
    // Get files' lines
    const pluginLines = pluginSmaliDoc.split('\n');
    const playerLines = playerSmaliDoc.split('\n');
    var playerMergeInfo = {};
    var pluginMergeInfo = {};
    var pluginIndex = 0;
    var playerIndex = 0;
    var resourceType = "";
    for(; pluginIndex < pluginLines.length; pluginIndex++) {
        if (pluginLines[pluginIndex].match(/^\.class public final.*\/R\$/g)) {
            var regExp = /\.class public final.*\/R\$(.*)\;/g;
            var result = regExp.exec(pluginLines[pluginIndex]);
            resourceType = result[1];
            pluginIndex++;
            break;
        }
    }
    // Skip until fields section start
    for (; pluginIndex < pluginLines.length; pluginIndex++) {
        if (pluginLines[pluginIndex].match(/^#\s*static fields/g)) {
            pluginIndex++;
            break;
        }
    }
    for (; playerIndex < playerLines.length; playerIndex++) {
        if (playerLines[playerIndex].match(/^#\s*static fields/g)) {
            playerIndex++;
            break;
        }
    }
    // Save fields until methods section starts
    pluginIndex = collectResourceFieldsForMerging(pluginMergeInfo, pluginIndex, pluginLines);
    playerIndex = collectResourceFieldsForMerging(playerMergeInfo, playerIndex, playerLines);
    // Get prologue from file
    pluginIndex = collectResourcePrologue(pluginMergeInfo, pluginIndex, pluginLines);
    playerIndex = collectResourcePrologue(playerMergeInfo, playerIndex, playerLines);
    // Get methods section until array definitions or end of the file
    pluginIndex = collectResourceMethodsForMerging(pluginMergeInfo, pluginIndex, pluginLines);
    playerIndex = collectResourceMethodsForMerging(playerMergeInfo, playerIndex, playerLines);
    // Get array definitions until end of the file
    pluginIndex = collectResourceArrayDefinitionsForMerging(pluginMergeInfo, pluginIndex, pluginLines);
    playerIndex = collectResourceArrayDefinitionsForMerging(playerMergeInfo, playerIndex, playerLines);
    // Clear fields from plugins' info if it exists on players too
    clearResourceStaticFields(pluginMergeInfo, playerMergeInfo);
    clearResourceMethods(pluginMergeInfo, playerMergeInfo);
    fixLineNumbersForMerging(pluginMergeInfo, playerMergeInfo);
    // Merge plugin to player
    const playerLinesMerged = mergePluginToPlayer(pluginMergeInfo, playerMergeInfo, playerLines, smaliName);
    addFieldsToPublicXml(pluginMergeInfo, resourceType, publicXmlPath);
    var mergedDoc = "";
    for (var i = 0; i < playerLinesMerged.length; i++) {
        mergedDoc += playerLinesMerged[i] + "\n";
    }
    return mergedDoc;
}

function collectResourceFieldsForMerging(infoObject, startIndex, lineList) {
    var i = startIndex;
    infoObject.staticFields = [];
    infoObject.staticArrays = {};
    infoObject.staticArrayFields = {};
    for (; i < lineList.length; i++) {
        if (lineList[i].match(/^#\s*direct methods/g)) {
            i++;
            break;
        }
        // If current line is an empty line skip
        if (lineList[i] === "" || lineList[i].match(/^\s$/g)) {
            continue;
        }
        // If current line is an array definition add it to static arrays and create
        // an array for it fields in static array fields
        if (lineList[i].match(/^\.field public static final.*:\x5BI/g)) {
            var line = lineList[i];
            // Get array class name and create array for its fields
            var regExpStr = /^\.field\spublic\sstatic\sfinal\s(\w*)\x3A\x5BI$/gm;
            var arrayName = regExpStr.exec(line);
            var arrayNameStr = arrayName[1];
            infoObject.staticArrayFields[arrayNameStr] = [];
            infoObject.staticArrays[arrayNameStr] = {
                arrayName: arrayNameStr,
                line: line
            };
            continue;
        }
        // If current line is a field check; if an array field add it to static array
        // fields if it is a standalone field add it to fields
        if (lineList[i].match(/^\.field public static final.*:I/g)) {
            var isArrayField = false;
            // Check if an array field
            for (var key in infoObject.staticArrayFields) {
                var regExpStr = '^\x2Efield public static final ' + key + '\x5F.*';
                var regExp = new RegExp(regExpStr, 'g');
                if (lineList[i].match(regExp)) {
                    infoObject.staticArrayFields[key].push(lineList[i]);
                    isArrayField = true;
                    break;
                }
            }
            // If is not an array field split field name and hex value and add it to 
            // static fields
            if (!isArrayField) {
                var parts = lineList[i].split('=');
                infoObject.staticFields.push({
                    name: parts[0],
                    value: parts[1]
                });
            }
            continue;
        }
    }
    return i;
}

function collectResourcePrologue(infoObject, startIndex, lineList) {
    var i = startIndex;
    infoObject.prologue = {};

    for (; i < lineList.length; i++) {
        if (lineList[i].match(/\x2Eline [0-9]+/g)) {
            i++;
            break;
        }

        if (lineList[i].match(/const\/4 v[0-9]/g)) {
            var regExp = /const\/4 (v[0-9]),\s*(0x[0-9a-fA-F])/g;
            var result = regExp.exec(lineList[i]);
            if(!result) {
                continue;
            }

            infoObject.prologue[result[1]] = result[2];
        }
    }

    return i;
}

function collectResourceMethodsForMerging(infoObject, startIndex, lineList) {
    var i = startIndex;
    infoObject.sputObjectLines = {};

    // Read sput_object lines until array definitions started
    for (; i < lineList.length; i++) {
        if (lineList[i].match(/return-void/g)) {
            i++;
            break;
        }

        if (lineList[i].match(/\x2Eline [0-9]+/g)) {
            var arrayNumber = ""; // Will be filled while reading lines
            var arrayName = ""; // Will be filled while reading lines
            var lineNumber = ""; // Will be filled while reading lines
            var readLines = [];
            var ignoreReadLines = true;
            var regExp = /\x2Eline ([0-9]+)\s*/g;
            var lineNumberArr = regExp.exec(lineList[i]);
            lineNumber = lineNumberArr[1];
            readLines.push(lineList[i]);
            i++; // Increment to go to next line
            while (lineList[i].match(/^\s$/g) || !lineList[i].match(/\x2Eline [0-9]+/g)) {
                if (lineList[i].match(/return-void/g)) {
                    ignoreReadLines = true;
                    break;
                }
                if (lineList[i].match(/sput-object.*L.*\/R\x24.*\x3B\x2D\x3E.*I/g)) { // match e.g: sput-object v0, Lsmartface/facebookplugin/R$styleable;->View:[I
                    var regExp = /.*\x3B\x2D\x3E(.*)\x3A\x5BI/g;
                    var arrayNameArr = regExp.exec(lineList[i]);
                    arrayName = arrayNameArr[1];
                    readLines.push(lineList[i]);
                    ignoreReadLines = false;
                    break;
                }
                if (lineList[i].match(/fill-array-data.*\x3Aarray.*/g)) { // match e.g: fill-array-data v0, :array_16
                    var regExp = /fill-array-data.*\x3Aarray\x5F([0-9a-fA-F]+)\s*/g;
                    var arrayNumberArr = regExp.exec(lineList[i]);
                    arrayNumber = arrayNumberArr[1];
                }
                readLines.push(lineList[i]);
                i++;
            }
            i--; // Decrement, because for loop will increment to catch 'line'

            if (!ignoreReadLines) {
                var key = lineNumber;
                infoObject.sputObjectLines[key] = {
                    arrayName: arrayName,
                    arrayNumber: arrayNumber,
                    lineNumber: lineNumber,
                    lines: readLines
                };
            }
        }
    }

    return i;
}

function collectResourceArrayDefinitionsForMerging(infoObject, startIndex, lineList) {
    var i = startIndex;
    infoObject.arrayDefinitionLines = {};

    // Read array definitions until end method
    for (; i < lineList.length; i++) {
        if (lineList[i].match(/\x2Eend method/g)) { // match e.g: .end method
            i++;
            break;
        }

        if (lineList[i].match(/\x2Eline [0-9]+/g)) { // match e.g:.line 2145
            var lineNumber = ""; // will be filled while reading lines
            var arrayNumber = ""; // will be filled while reading lines
            var readLines = [];
            var ignoreReadLines = true;

            var regExp = /\x2Eline ([0-9]+)\s*/g;
            var lineNumberArr = regExp.exec(lineList[i]);
            lineNumber = lineNumberArr[1];

            readLines.push(lineList[i]);
            i++;
            while (lineList[i].match(/^\s$/g) || !lineList[i].match(/\x2Eline [0-9]+/g)) {
                if (lineList[i].match(/return-void/g) || lineList[i].match(/\x2Eend method/g)) {
                    ignoreReadLines = true;
                    break;
                }   

                if (lineList[i].match(/\x2Eend array\x2Ddata/g)) {
                    readLines.push(lineList[i]);
                    ignoreReadLines = false;
                    break;
                }

                if (lineList[i].match(/\x3Aarray\x5F[0-9a-fA-Z]+/g)) {
                    var regExp = /\x3Aarray\x5F([0-9a-fA-Z]+)\s*/g;
                    var arrayNumberArr = regExp.exec(lineList[i]);
                    arrayNumber = arrayNumberArr[1];
                }

                readLines.push(lineList[i]);
                i++;
            }
            i--;

            if (!ignoreReadLines) {
                var key = lineNumber;
                infoObject.arrayDefinitionLines[key] = {
                    arrayNumber: arrayNumber,
                    lineNumber: lineNumber,
                    lines: readLines
                };
            }
        }
    }

    return i;
}

function clearResourceStaticFields(pluginInfo, playerInfo) {
    // Find biggest hex number in static fields of playerInfo
    var maxForStaticFields = 0;
    for (var i = 0; i < playerInfo.staticFields.length; i++)
        if (parseInt(playerInfo.staticFields[i].value, 16) > maxForStaticFields)
            maxForStaticFields = parseInt(playerInfo.staticFields[i].value, 16);

    // Clear fields if it exists on player side
    for (var i = 0; i < pluginInfo.staticFields.length; i++) {
        for (var j = 0; j < playerInfo.staticFields.length; j++) {
            if (pluginInfo.staticFields[i].name == playerInfo.staticFields[j].name) {
                pluginInfo.staticFields.splice(i--, 1);
                break;
            }
        }
    }

    for (var pluginKey in pluginInfo.staticArrays) {
        for (var playerKey in playerInfo.staticArrays) {
            if (pluginInfo.staticArrays[pluginKey].line === playerInfo.staticArrays[playerKey].line) {
                if (pluginInfo.staticArrayFields[pluginKey]) 
                    delete pluginInfo.staticArrayFields[pluginKey];
                delete pluginInfo.staticArrays[pluginKey];
                break;
            }
        }
    }

    // Update values of remaining static fields according to max static fields
    for (var i = 0; i < pluginInfo.staticFields.length; i++) {
        maxForStaticFields++;
        pluginInfo.staticFields[i].value = "0x" + maxForStaticFields.toString(16);
    }
}

function clearResourceMethods(pluginInfo, playerInfo) {
    // Find biggest hex number in arrays
    var maxForArrays = 0;
    for (var key in playerInfo.sputObjectLines) {
        var hex = playerInfo.sputObjectLines[key].arrayNumber;
        if (hex !== "" && parseInt(hex, 16) > maxForArrays)
            maxForArrays = parseInt(hex, 16);
    }

    // Clear arrays if it exists on player side
    for (var pluginKey in pluginInfo.sputObjectLines) {
        for (var playerKey in playerInfo.sputObjectLines) {
            if (pluginInfo.sputObjectLines[pluginKey].arrayName === playerInfo.sputObjectLines[playerKey].arrayName) {
                // If there is array definition for this object delete it too
                if (pluginInfo.arrayDefinitionLines[pluginKey]) {
                    delete pluginInfo.arrayDefinitionLines[pluginKey];
                }
                delete pluginInfo.sputObjectLines[pluginKey];
                break;
            }
        }
    }

    // Update values of remaining objects array numbers
    for (var pluginKey in pluginInfo.sputObjectLines) {
        if (pluginInfo.sputObjectLines[pluginKey].arrayNumber !== "") {
            maxForArrays++;
            pluginInfo.sputObjectLines[pluginKey].arrayNumber = maxForArrays.toString(16);
            if (pluginInfo.arrayDefinitionLines[pluginKey]) {
                pluginInfo.arrayDefinitionLines[pluginKey].arrayNumber = maxForArrays.toString(16);
            }
        }

        // Update v[0-9] values according to new prologue
        for (var i = 0; i < pluginInfo.sputObjectLines[pluginKey].lines.length; i++) {
            if (pluginInfo.sputObjectLines[pluginKey].lines[i].match(/new\-array v0, (v[0-9]), \[I/)) {
                var regExp = /new\-array v0, (v[0-9]), \[I/;
                var result = regExp.exec(pluginInfo.sputObjectLines[pluginKey].lines[i]);
                if (!result || result[1] === "v0") {
                    continue;
                }

                var newVName = findNewVName(result[1], pluginInfo.prologue, playerInfo.prologue);
                if (newVName === "v0") {
                    var newLine = "const/4 v0, " + pluginInfo.prologue[result[1]];
                    pluginInfo.sputObjectLines[pluginKey].lines.splice(i++, 0, newLine);
                    pluginInfo.sputObjectLines[pluginKey].lines.splice(i++, 0, "");
                }
                pluginInfo.sputObjectLines[pluginKey].lines[i] = pluginInfo.sputObjectLines[pluginKey].lines[i].replace(result[1], newVName);
            } else if (pluginInfo.sputObjectLines[pluginKey].lines[i].match(/aput v[0-9], v[0-9],/)) {
                var regExp = /aput v[0-9], v[0-9], (v[0-9])/;
                var result = regExp.exec(pluginInfo.sputObjectLines[pluginKey].lines[i]);
                if (!result) {
                    continue;
                }

                var newVName = findNewVName(result[1], pluginInfo.prologue, playerInfo.prologue);
                if (newVName === "v0") {
                    newVName = pluginInfo.prologue[result[1]];
                }
                pluginInfo.sputObjectLines[pluginKey].lines[i] = pluginInfo.sputObjectLines[pluginKey].lines[i].replace(result[1], newVName);
            }
        }
    }
}

function findNewVName(oldVName, oldPrologue, newPrologue) {
    var hexValue = oldPrologue[oldVName];
    for (var key in newPrologue) {
        if (hexValue === newPrologue[key]) {
            return key;
        }
    }

    return "v0";
}

function fixLineNumbersForMerging(pluginInfo, playerInfo) {
    var playerMaxLineNumber = 0;
    for (var key in playerInfo.sputObjectLines) {
        if (parseInt(key) > playerMaxLineNumber) {
            playerMaxLineNumber = parseInt(key);
            if (playerInfo.arrayDefinitionLines[key])
                playerMaxLineNumber += playerInfo.arrayDefinitionLines[key].lines.length - 4;
        }
    }

    var lastLineNumber = playerMaxLineNumber + 1000;
    var newSputObjectLines = {};
    var newArrayDefinitionLines = {};
    for (var pluginKey in pluginInfo.sputObjectLines) {
        var lastLineNumberStr = lastLineNumber.toString();;
        newSputObjectLines[lastLineNumber] = pluginInfo.sputObjectLines[pluginKey];
        newSputObjectLines[lastLineNumber].lineNumber = lastLineNumberStr;
        newSputObjectLines[lastLineNumber].lines[0] = newSputObjectLines[lastLineNumber].lines[0].replace(pluginKey, lastLineNumberStr);

        if (pluginInfo.arrayDefinitionLines[pluginKey]) {
            newArrayDefinitionLines[lastLineNumber] = pluginInfo.arrayDefinitionLines[pluginKey];
            newArrayDefinitionLines[lastLineNumber].lineNumber = lastLineNumberStr;
            newArrayDefinitionLines[lastLineNumber].lines[0] = newArrayDefinitionLines[lastLineNumber].lines[0].replace(pluginKey, lastLineNumberStr);
            lastLineNumber += newArrayDefinitionLines[lastLineNumber].lines.length - 4;
        }
        lastLineNumber += 50;
    }
    pluginInfo.sputObjectLines = newSputObjectLines;
    pluginInfo.arrayDefinitionLines = newArrayDefinitionLines;
}

function mergePluginToPlayer(pluginInfo, playerInfo, playerLines, smaliName) {
    // Update lines
    for (var playerIndex = 0; playerIndex < playerLines.length; playerIndex++) {
        if (playerLines[playerIndex].match(/^#\s*direct methods/g)) {
            playerIndex--;
            for (var i = 0; i < pluginInfo.staticFields.length; i++) {
                var line = pluginInfo.staticFields[i].name + "= ";
                line += pluginInfo.staticFields[i].value;
                var emptyLine = "";
                playerLines.splice(playerIndex, 0, line, emptyLine);
                playerIndex += 2;
            }
            for (var key in pluginInfo.staticArrays) {
                var line = pluginInfo.staticArrays[key].line;
                var emptyLine = "";
                playerLines.splice(playerIndex, 0, line, emptyLine);
                playerIndex += 2;

                for(var j = 0; j < pluginInfo.staticArrayFields[key].length; j++) {
                    var line = pluginInfo.staticArrayFields[key][j];
                    var emptyLine = "";
                    playerLines.splice(playerIndex, 0, line, emptyLine);
                    playerIndex += 2;
                }

            }
            playerIndex++;
        }

        if (playerLines[playerIndex].match(/return\x2Dvoid/g)) {
            mergedSingleValueArrayInformations[smaliName] = { hexValues: [] };
            for (var key in pluginInfo.sputObjectLines) {
                playerLines.splice(playerIndex++, 0, "");
                for (var i = 0; i < pluginInfo.sputObjectLines[key].lines.length; i++) {
                    var line = pluginInfo.sputObjectLines[key].lines[i];
                    if (line.match(/.*\x3Aarray\x5F[0-9a-fA-F]+/g)) {
                        line = line.replace(/(.*\x3Aarray\x5F)([0-9a-fA-F]+)/g, "$1" + 
                                            pluginInfo.sputObjectLines[key].arrayNumber);
                    }
                    if (line.match(/const v1, 0x7f[0-9a-fA-F]{6}/g)) {
                        var hexValue = /const v1, (0x7f[0-9a-fA-F]{6})/g.exec(line);
                        hexValue = hexValue[1];
                        mergedSingleValueArrayInformations[smaliName].hexValues.push(hexValue);
                    }
                    playerLines.splice(playerIndex, 0, line);
                    playerIndex++;
                }
            }
        }

        if (playerLines[playerIndex].match(/\x2Eend method/g)) {
            mergedArrayInformations[smaliName] = {arrayNames: []};
            for (var key in pluginInfo.arrayDefinitionLines) {
                mergedArrayInformations[smaliName].arrayNames.push("array_" + 
                    pluginInfo.arrayDefinitionLines[key].arrayNumber);
                playerLines.splice(playerIndex++, 0, "");
                for (var i = 0; i < pluginInfo.arrayDefinitionLines[key].lines.length; i++) {
                    var line = pluginInfo.arrayDefinitionLines[key].lines[i];
                    if (line.match(/\s*\x3Aarray\x5F[0-9a-fA-F]+/g)) {
                        line = line.replace(/(\s*\x3Aarray\x5F)([0-9a-fA-F]+)(.*)/g, "$1" + 
                                            pluginInfo.arrayDefinitionLines[key].arrayNumber + "$3");
                    }
                    playerLines.splice(playerIndex, 0, line);
                    playerIndex++;
                }
            }
            break;
        }
    }

    return playerLines;
}

function addFieldsToPublicXml(pluginInfo, resourceType, valuesPath) {
    const publicXmlLines = fs.readFileSync(valuesPath + "public.xml", "utf-8").split('\n');
    var newPublicXml = [];

    for (var i = 0; i < publicXmlLines.length; i++) {
        if (publicXmlLines[i].match(/\<\/resources\>/g)) {
            for (var j = 0; j < pluginInfo.staticFields.length; j++) {
                var regExp = /\.field.*\s(.*):I/g;
                var result = regExp.exec(pluginInfo.staticFields[j].name);  
                var name = result[1];
                name = findNameInAllValuesXmls(valuesPath.substring(0, valuesPath.indexOf("/values/")), resourceType, name);
                newPublicXml.push("    <public type=\"" + resourceType + "\" name=\"" + 
                    name + "\" id=\"" + pluginInfo.staticFields[j].value + "\" />");
            }
        }
        newPublicXml.push(publicXmlLines[i]);
    }
    fs.writeFileSync(valuesPath + "public.xml", newPublicXml.join('\n') + '\n', "utf-8");
}

function findNameInAllValuesXmls(resFolderPath, resourceType, name) {
    var stat = fs.statSync(resFolderPath);
    if (!stat.isDirectory())
        return name;

    var dirContent = fs.readdirSync(resFolderPath);
    for (var i = 0; i < dirContent.length; i++) {
        if (dirContent[i].match(/^values/)) {
            stat = fs.statSync(path.join(resFolderPath, dirContent[i]));
            var possibleFileName = path.join(resFolderPath, dirContent[i], resourceType + "s.xml");
            if (stat.isDirectory() && fs.existsSync(possibleFileName)) {
                var newName = findNameInValuesXmls(possibleFileName, name);
                if (newName !== name) return newName;
            }
        }
    }

    return name;
}

function findNameInValuesXmls(xmlPath, name) {
    if (fs.existsSync(xmlPath) !== true)
        return name;

    var xmlDoc = fs.readFileSync(xmlPath, "utf-8");
    var regExpStr = ".*name=\\\"" + name + "\\\"";
    var found = (new RegExp(regExpStr)).exec(xmlDoc);
    if (found) {
        return name;
    } else {
        var withDots = name.replace(/_/g, ".");
        regExpStr = ".*name=\\\"" + withDots + "\\\"";
        found = (new RegExp(regExpStr)).exec(xmlDoc);
        if (found)
            return withDots;
    }
    
    return name;
}

function fixHexValuesInSmali(smaliDoc, publicXmlPath, RSmaliPaths) {
    var newSmaliDoc = smaliDoc.replace(/(const|const\/high16) (v[0-9a-fA-F]+,\s*)(0x7f[0-9a-fA-F]{6})/g, function(match, constStr, vStr, hex, offset, string) {
        if (RSmaliPaths) {
            for (var i = 0; i < RSmaliPaths.length; i++) {
                // Find name of the field which owns that hex
                var rSmaliDoc = fs.readFileSync(RSmaliPaths[i], "utf-8");
                var regExStr = "\\.field.*\\s(.*):I.*" + hex + "\\s*";
                var result = (new RegExp(regExStr, "g")).exec(rSmaliDoc);
                if (!result)
                    continue;
                var type = RSmaliPaths[i].substring(RSmaliPaths[i].indexOf('R$')+2,RSmaliPaths[i].indexOf('.smali'));
                // Find new hex value of that field from public xml
                var publicXmlDoc = fs.readFileSync(publicXmlPath, "utf-8");
                regExStr = "<public type=\""+type+"\" name=\\\"" + result[1] + "\\\".*id=\\\"(0x7[f|F][0-9a-fA-F]{6})\\\"";
                var newResult = (new RegExp(regExStr, "g")).exec(publicXmlDoc);
                if (!newResult) {
                    var withDots = result[1]; //.replace(/_/g, ".");
                    regExStr = "<public type=\""+type+"\" name=\\\"" + withDots + "\\\".*id=\\\"(0x7[f|F][0-9a-fA-F]{6})\\\"";
                    newResult = (new RegExp(regExStr, "g")).exec(publicXmlDoc);

                    if (!newResult)
                        continue;
                }

                // Return new hex value we got from public xml
                return "const "+ vStr + newResult[1];
            }
        }

        // If new hex could not found return original
        return constStr+" " + vStr + hex;
    });

    return newSmaliDoc;
}

function fixArrayHexValuesInSmali(smaliDoc, newPublicXmlPath, oldPublicXmlPath, smaliName) {
    var newSmaliDoc = fixArrayHexValuesInSmaliPart1(smaliDoc, newPublicXmlPath, oldPublicXmlPath, smaliName);
    newSmaliDoc = fixArrayHexValuesInSmaliPart2(newSmaliDoc, newPublicXmlPath, oldPublicXmlPath, smaliName);
    return newSmaliDoc;
}

function fixArrayHexValuesInSmaliPart1(smaliDoc, newPublicXmlPath, oldPublicXmlPath, smaliName) {
    if (!mergedArrayInformations[smaliName] || mergedArrayInformations[smaliName].arrayNames.length == 0) 
        return smaliDoc;
    currentArrayNames = mergedArrayInformations[smaliName].arrayNames;

    var newSmaliDoc = smaliDoc.replace(/(\:array_[0-9a-fA-F]*\s*\.array\-data[.|\s|\w]*\.end array\-data)/gi, function(match, array, offset, string) {
        // Check if array is from plugin
        var arrayName = /\:(array_[0-9a-fA-F]*)/g.exec(array);
        arrayName = arrayName[1];
        var found = false;
        for (var i = 0; i < currentArrayNames.length; i++) {
            if (arrayName === currentArrayNames[i]) {
                found = true;
            }
        }
        if(!found) {
            return array;
        }

        var newArray = array.replace(/(0x7f[0-9a-fA-F]{6})/g, function(match, hex, offset, string) {
            // Find value name in old public xml doc
            const oldPublicXmlDoc = fs.readFileSync(oldPublicXmlPath, 'utf8');
            var regExStr = "<public.*name=\\\"(.*)\\\".*id=\\\"" + hex + "\\\"";
            var result = (new RegExp(regExStr, "")).exec(oldPublicXmlDoc);
            if (!result) { return hex; }
            var valueName = result[1];

            // Find new hex of that value in new public xml
            const newPublicXmlDoc = fs.readFileSync(newPublicXmlPath, 'utf8');
            regExStr = "<public.*name=\\\"" + valueName + "\\\".*id=\\\"(0x7[f|F][0-9a-fA-F]{6})\\\"";
            result = (new RegExp(regExStr, "")).exec(newPublicXmlDoc);
            if (!result) { return hex; }

            return result[1];
        });
        return newArray; 
    });
    return newSmaliDoc;   
}

function fixArrayHexValuesInSmaliPart2(smaliDoc, newPublicXmlPath, oldPublicXmlPath, smaliName) {
    if (    !mergedSingleValueArrayInformations[smaliName] || 
            mergedSingleValueArrayInformations[smaliName].hexValues.length == 0) {
        return smaliDoc;
    }
    currentSingleValueHex = mergedSingleValueArrayInformations[smaliName].hexValues;

    var newSmaliDoc = smaliDoc.replace(/const v1, (0x7f[0-9a-fA-F]{6})/gi, function(match, hex, offset, string) {
        var found = false;
        for (var i = 0; i < currentSingleValueHex.length; i++) {
            if (hex === currentSingleValueHex[i]) {
                found = true;
            }
        }
        if (!found) {
            return match;
        }

        const oldPublicXmlDoc = fs.readFileSync(oldPublicXmlPath, 'utf8');
        var regExStr = "<public.*name=\\\"(.*)\\\".*id=\\\"" + hex + "\\\"";
        var result = (new RegExp(regExStr, "")).exec(oldPublicXmlDoc);
        if(!result) {
            return match;
        }
        var valueName = result[1];

        const newPublicXmlDoc = fs.readFileSync(newPublicXmlPath, 'utf8');
        regExStr = "<public.*name=\\\"" + valueName + "\\\".*id=\\\"(0x7[f|F][0-9a-fA-F]{6})\\\"";
        result = (new RegExp(regExStr, "")).exec(newPublicXmlDoc);
        if (!result) {
            return match;
        }
        return "const v1, " + result[1];
    });

    return newSmaliDoc;
}

module.exports = {
    mergeResourceSmaliFiles: mergeResourceSmaliFiles,
    fixHexValuesInSmali: fixHexValuesInSmali,
    fixArrayHexValuesInSmali: fixArrayHexValuesInSmali
};
