/**
 * @file Include Android publisher steps operations.
 * @version 1.0.0
 * @requires module:fs
 * @require module:child_process
 */
const fs = require('fs');
const spawnSync = require('child_process').spawnSync;
const path = require('path');

const AdmZip = require('adm-zip');
const _ = require('underscore');
const fse = require('fs-extra');


const utility = require('../../utility');
const copy = require('../../copy');
const fonts = require('../../fonts');
const ConfigObjects = require('../../config/index');
const Configuration = require('../../configuration').Configuration;
const logger = require('../../log/log4j').getLogger('AndroidPublisher'); // logger.
const Des3 = require('../../3des');
const error = require('../../error');
const pluginManager = require('../pluginmanager');
const changer = require('./changer');
const globalData = require('../../globalData');
const FileManager = require("../managefiles").FileManager;

const drawableRegexp = /drawable(-(small|normal|large|xlarge)){0,1}-(\w+dpi){0,1}/g;

const AndroidConfig = ConfigObjects.android;
const filemanager = new FileManager();

const des3 = new Des3();
const configuration = new Configuration();

var err = {
	err: '',
	msg: '',
	detail: null
};

function commandGenerator(identifier_string, lambda) {
	return function() {
		const child = lambda();

		if (!utility.controlChildProcess(child)) {
			const inputFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
			const cmdErr = error.getObject('android.' + identifier_string);
			_.extend(cmdErr, {
				"detail": reduceLogMessage(child.output.toString('utf8'), path.dirname(inputFolder))
			});
			logger.error(error.getMsgForLogger('android.' + identifier_string) + '\n detail: ' + err.detail);
			utility.killProcess(cmdErr);
		}
		else {
			logger.debug(identifier_string + ' : ' + child && (child.output && (child.output.toString('utf8'))));
		}
		return child;
	};
}

const helpStrNoSuchFileDirInPlayer = "You should be sure that player zip file is correct.";
/**
 *  Android Publisher   extract apk, build apk ...
 * @constructor AndroidPublisher
 */
var AndroidPublisher = function() {

	var KEY = '';
	var licenseType = "Demo";
	const TEMP_FM = globalData.get("moduleGlobals.tempfilemanager");
	var TEMP_FOLDER = '.tmp/';
	var scriptFiles = [];
	var assetsIsWrittenTemp = false;
	var isPluginsAlreadyAdded = false;

	/**
	 * start publish by config object.
	 * @method startPublish
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 * @throws {Error} during the control config object.
	 */
	this.startPublish = function() {

		utility.StdoutLogger.setLogger(logger);

		const config = globalData.get('androidConfig');
		utility.controlConfig(config);
		control_Config2_AndroidConfig(config);
		copy.setFileMager(filemanager);
		//utility.mkdirpSync(path.dirname(config.androidConfig.output.outputApk));
		TEMP_FOLDER = globalData.get("moduleGlobals.tmpdir");
		KEY = globalData.get('androidConfig.tripleDes.key');
		licenseType = globalData.get('androidConfig.androidConfig.input.license.type');
	};
	/**
	 * Apk extract by androidConfig.input | output.extractor objects
	 * @method apkExtractor
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @throws {Error} if none input apk then output folder.
	 * @memberof AndroidPublisher
	 */
	this.apkExtractor = function() {
		const inputApk = globalData.get('androidConfig.androidConfig.input.extractor.inputApk');
		const apkTool = globalData.get('androidConfig.androidConfig.input.apkTool');
		const maxMemory = globalData.get('androidConfig.androidConfig.input.java.maxMemory');
		const javaPath = globalData.get('androidConfig.androidConfig.input.java.path');
		const outputFolder = globalData.get('androidConfig.androidConfig.output.extractor.outputFolder');
		logger.debug('start decompiling ' + inputApk);
		//console.inspect(globalData.get('androidConfig.androidConfig'));
		if (path.extname(inputApk).toLowerCase() == '.apk') {
			utility.throwsNoSuchFile(inputApk, 'apk', "You should be sure that player apk file is exist.");
			commandGenerator('extractor', function() {
				var parameters = ['-Duser.language=en ', '-jar', apkTool, 'd',
					'-f', inputApk, '-o', outputFolder
				];
				addParameterMaxMem(parameters, maxMemory);
				return spawnSync(javaPath, parameters);
			})();
		}
		else if (path.extname(inputApk).toLowerCase() == '.zip') {
			utility.throwsNoSuchFile(inputApk, 'zip', "You should be sure that player zip file is exist.");
			try {
				var zip = new AdmZip(inputApk);
				zip.extractAllTo(path.join(outputFolder, '..'), /*overwrite*/ true);
			}
			catch (ex) {
				utility.killProcess({
					err: "Extraction Error",
					msg: ex,
					fullPath: inputApk
				});
			}
		}
		utility.throwsNoSuchDir(outputFolder, helpStrNoSuchFileDirInPlayer);
		utility.mkdirpSync(outputFolder + '/assets');
		logger.debug('done decompiling ' + outputFolder);
	};
	/**
	 * Apk builder by androidConfig.input | output.builder objects
	 * @method apkBuilder
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @throws {Error} if none input folder then output apk
	 * @memberof AndroidPublisher
	 */
	this.apkBuilder = function() {
		const inputFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		const apkTool = globalData.get('androidConfig.androidConfig.input.apkTool');
		const javaPath = globalData.get('androidConfig.androidConfig.input.java.path');
		const maxMemory = globalData.get('androidConfig.androidConfig.input.java.maxMemory');
		const outputApk = globalData.get('androidConfig.androidConfig.output.builder.outputApk');
		logger.debug('start building ' + inputFolder);
		utility.throwsNoSuchDir(inputFolder, helpStrNoSuchFileDirInPlayer);
		if (utility.safeControlFile(outputApk, 'apk')) { // if file exist clear.
			fs.unlinkSync(outputApk);
		}
		var res = commandGenerator('builder', function() {
			var parameters = ['-Duser.language=en ', '-jar', apkTool, 'b', '-f', inputFolder, '-o', outputApk];
			addParameterMaxMem(parameters, maxMemory);
			return spawnSync(javaPath, parameters);

		})();
		utility.throwsNoSuchFile(outputApk, null, "Build operation was failed. Please, contact us.");
		logger.debug('done building. Output Apk : ' + outputApk);
	};

	/**
	 * Signer Apk file   with androidConfig.input | output. sign objects.
	 * @method apkSigner
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @throws {Error} if none input apk then output apk
	 * @memberof AndroidPublisher
	 */
	this.apkSigner = function() {
		const outputApk = globalData.get('androidConfig.androidConfig.output.sign.outputApk');
		const inputApk = globalData.get('androidConfig.androidConfig.input.sign.inputApk');
		const builderOutputApk = globalData.get('androidConfig.androidConfig.output.builder.outputApk');
		logger.debug('start signing ' + inputApk);
		utility.mkdirpSync(path.dirname(outputApk)); // output folder if need , create.
		utility.throwsNoSuchFile(inputApk, 'apk', "We couldn't find preSigned.apk. You can try again.");
		if (utility.safeControlFile(outputApk, 'apk')) { // if file exist clear.
			fs.unlinkSync(outputApk);
		}
		commandGenerator('signer', function() {
			const sign = globalData.get('androidConfig.androidConfig.input.sign');
			const javaPath = globalData.get('androidConfig.androidConfig.input.java.path');
			const maxMemory = globalData.get('androidConfig.androidConfig.input.java.maxMemory');
			var parameters = ['-jar', sign.signer, '-keystore', sign.keystoreFile,
				sign.keystorePass, sign.aliasName, sign.keyPass, inputApk, outputApk
			];
			addParameterMaxMem(parameters, maxMemory);
			//console.inspect(parameters);
			return spawnSync(javaPath, parameters);
		})();
		if (utility.safeControlFile(builderOutputApk, 'apk')) { // if file exist clear.
			fs.unlinkSync(builderOutputApk);
		}
		utility.throwsNoSuchFile(outputApk, null, "Signing operation was failed. Please, contact us.");
		logger.debug('done signing. Output Apk : ' + outputApk);
	};

	/**
	 * align Apk file   with androidConfig.input | output. zipalign objects.
	 * @method apkAlign
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @throws {Error} if none input apk then output apk
	 * @memberof AndroidPublisher
	 */
	this.apkAlign = function() {
		const outputApk = globalData.get('androidConfig.androidConfig.output.zipalign.outputApk');
		const inputApk = globalData.get('androidConfig.androidConfig.input.zipalign.inputApk');
		logger.debug('start aligning ' + inputApk);
		utility.mkdirpSync(path.dirname(outputApk)); // output folder if need , create.
		utility.throwsNoSuchFile(inputApk, 'apk', "We couldn't find signed.apk. You can try again.");
		if (utility.safeControlFile(outputApk, 'apk')) { // if file exist clear.
			fs.unlinkSync(outputApk);
		}
		commandGenerator('zipalign', function() {
			const zipalign = globalData.get('androidConfig.androidConfig.input.zipalign.path');
			var parameters = ["-f", "4", inputApk, outputApk];
			//console.inspect(parameters);
			return spawnSync(zipalign, parameters);
		})();
		if (utility.safeControlFile(inputApk, 'apk')) { // if file exist clear.
			fs.unlinkSync(inputApk);
		}
		utility.throwsNoSuchFile(outputApk, null, "alignment operation was failed. Please, contact us.");
		logger.debug('done aligment. Output Apk : ' + outputApk);
	};

	/**
	 * Images copy from androidConfig.input.images to player folder.
	 * @method updateImages
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 */
	this.updateImages = function(profileIndex) {
		const inputFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		const images = globalData.get('androidConfig.androidConfig.input.images');
		const packageProfiles = globalData.get('androidConfig.androidConfig.input.packageProfiles');
		logger.debug('start updateImages() ' + images);
		var supportFolder = packageProfiles[profileIndex].profile.folders;
		var playerFolders = findDrawableFolders(inputFolder + '/res/');
		var drawableInfo;

		//walk through player folders.
		playerFolders.forEach(function(folder) {
			if (supportFolder.indexOf(folder) < 0) {
				drawableInfo = getDrawableFolderInfo(folder);
				if (drawableInfo.screenSize)
					return logger.info("skip folder -> " + folder); // skip this folder
				var rootFolder = "drawable";
				if (drawableInfo.resolution) {
					rootFolder += '-' + drawableInfo.resolution;
				}
				if (fs.existsSync(images + '/' + rootFolder) && supportFolder.indexOf(rootFolder) > -1) {
					copy.copyDirectory(images + '/' + rootFolder, inputFolder + '/res/' + folder);
				}
				else {
					logger.warn('No such a directory :dir: ' + images + '/' + folder);
				}
			}
			else {
				if (fs.existsSync(images + '/' + folder)) {
					copy.copyDirectory(images + '/' + folder, inputFolder + '/res/' + folder);
				}
				else {
					logger.warn('No such a directory :dir: ' + images + '/' + folder);
				}
			}
		});

		logger.debug('done updateImages() ');
	};

	function findDrawableFolders(resPath) {
		var folders = fs.readdirSync(resPath);
		var drawableFolders = [];
		folders.forEach(function(folder) {
			if (folder.toString().indexOf('drawable') > -1) {
				drawableFolders.push(folder);
			}
		});
		return drawableFolders;
	}

	function getDrawableFolderInfo(folderPath) {
		drawableRegexp.lastIndex = 0;
		var res = drawableRegexp.exec(folderPath);

		return {
			resolution: res && res[3],
			screenSize: res && res[2]
		};
	}


	/**
	 * create config2.bin by config.config2 object..
	 * @method createConfig2Bin
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 */
	this.createConfig2Bin = function() {
		const inputFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		const key = globalData.get('androidConfig.tripleDes.key');
		const config2 = globalData.get('androidConfig.config2');
		const config2Path = path.join(TEMP_FOLDER, "config2.bin");
		logger.debug('start createConfig2Bin() ');
		if (!TEMP_FM.isIn(config2Path)) {
			fs.writeFileSync( // create config2.bin
				config2Path,
				des3.encryptStrWith3DES_ECB(
					configuration.createConfigXmlString(config2), key)
			);
			TEMP_FM.addFileWithoutCopySync(config2Path);
			copy.copyFile(config2Path, path.join(inputFolder, "assets", "config2.bin"));
		}
		else {
			copy.copyFile(config2Path, path.join(inputFolder, "assets", "config2.bin"));
		}
		logger.debug('done createConfig2Bin() ' + inputFolder + '/assets/config2.bin');
	};
	/**
	 * update AndroidMAnifest.xml by config.androidConfig.input.manifest.edit object..
	 * @method updateManifest
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 */
	this.updateManifest = function() {
		const inputFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		const manifest = globalData.get('androidConfig.androidConfig.input.manifest');
		const manifestPath = path.join(TEMP_FOLDER, 'AndroidManifest.xml');
		if (!TEMP_FM.isIn(manifestPath)) {
			// if not exist in tmpfolder, then create.
			fs.writeFileSync(manifestPath, configuration.editAndroidManifestXML(manifest));
			TEMP_FM.addFileWithoutCopySync(manifestPath);
			copy.copyFile(manifestPath, inputFolder + '/AndroidManifest.xml');
		}
		else {
			copy.copyFile(manifestPath, inputFolder + '/AndroidManifest.xml');
		}
		logger.debug('start updateManifest() ');
		fs.writeFileSync(inputFolder + '/AndroidManifest.xml', configuration.editAndroidManifestXML(manifest));
		logger.debug('done updateManifest() ' + inputFolder + '/AndroidManifest.xml');
	};

	/**
	 * Scripts files from config.androidConfig.input.scripts  to player folder.
	 * @method updateScripts
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 */
	this.updateScripts = function() {
		const inputFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		const scripts = globalData.get('androidConfig.androidConfig.input.scripts');
		const outputFolder = globalData.get('androidConfig.androidConfig.output.extractor.outputFolder');
		logger.debug('start updateScripts() ' + scripts);
		scriptFiles = utility.searchFilesInDirRec(scripts);
		logger.debug('\t  Scripts files with encrypted copying ...  :' + scripts);
		_.each(scriptFiles, function(item) {

			var relativePathDir = path.dirname(path.relative(scripts, item));
			utility.mkdirpSync(path.join(outputFolder, 'assets', relativePathDir));
			var filename = path.join(outputFolder, 'assets', relativePathDir, path.basename(item));
			var tempFilePath = path.join(TEMP_FOLDER, "scripts", relativePathDir, path.basename(filename));
			var fileChangedExt = detectFileExtension(filename);
			if (TEMP_FM.isIn(tempFilePath) === null) { // script file doens't exists in tempfolder
				utility.mkdirpSync(path.dirname(tempFilePath));
				if ([".js", ".json"].indexOf(path.extname(item)) !== -1) {
					if (licenseType !== 'Demo') { // license type isn't demo, encrpt and copy tempfolder.
						des3.encryptFileWith3DES_ECB(item, KEY, tempFilePath);
						TEMP_FM.addFileWithoutCopySync(tempFilePath);
						filemanager.addFileSync(fileChangedExt, tempFilePath);
					}
					else { //script adds tempfolder and player folder
						TEMP_FM.addFileSync(tempFilePath, item);
						copy.copyFile(tempFilePath, filename);
					}
				}
				else {
					TEMP_FM.addFileSync(tempFilePath, item);
					copy.copyFile(tempFilePath, filename);
				}
			}
			else { // script avaiable in tempfolder adds from temp folder to player folder if not exist in player folder. 
				if (licenseType !== 'Demo') {
					copy.copyFile(tempFilePath, fileChangedExt);
				}
				else
					copy.copyFile(tempFilePath, filename);
			}

		});
		logger.debug('done updateScripts() ' + inputFolder + '/assets');

		function detectFileExtension(file) {
			var res = file;
			if (path.extname(file) === '.js')
				if (licenseType !== 'Demo') {
					res = utility.renameFilesType(file, 'jse');
				}
			return res;
		}
	};
	/**Assets files from config.androidConfig.input.scripts  to player folder.
	 * @method updateAssets
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 */
	this.updateAssets = function() {
		var licType = globalData.get('androidConfig.androidConfig.input.license.type');
		const inputFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		const assets = globalData.get('androidConfig.androidConfig.input.assets');

		logger.debug('Started copying font files ...');
		const fontParams = collectFontParams();
		const font_files = fonts.handleFonts(fontParams);
		logger.debug('copied font files ', font_files);
		logger.debug('start updateAssets() ' + assets);
		const tempAssetsDir = path.join(TEMP_FOLDER, "assets");
		if (!assetsIsWrittenTemp) { // if files aldreay is written in tempfolder ? 
			copy.setFileMager(TEMP_FM); // change filemanager .
			copy.copyDirectory(assets, tempAssetsDir);
			var cacertPemPath = path.join(tempAssetsDir, 'cacert.pem');
			var assetsFiles = utility.searchFilesInDirRec(tempAssetsDir);
			if (assetsFiles.indexOf(cacertPemPath) > -1 && licType !== 'Demo') {
				des3.encryptFileWith3DES_ECB(cacertPemPath, KEY, cacertPemPath);
			}
			copy.setFileMager(filemanager);
			assetsIsWrittenTemp = true;
		}
		copy.copyDirectory(tempAssetsDir, inputFolder + '/assets');
		logger.debug('done updateAssets() ' + inputFolder + '/assets');
	};

	function collectFontParams() {
		const inputFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		const targetFolder = path.join(inputFolder, 'assets');
		const deviceType = 'Android';
		const projectRoot = globalData.get('args.projectRoot');
		const platform = globalData.get('args.platform');
		const appStudioProject = (platform === 'c9') ? false : true;
		return fonts.createFontParams(projectRoot, deviceType, targetFolder, appStudioProject);
	}

	/**
	 * pushnotification.json .
	 * @method updateOtherFiles
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 */
	this.updateOtherFiles = function(config) {
		const pushJSON = path.join(config.androidConfig.input.config, "pushnotification.json");
		const destFile = path.join(config.androidConfig.input.builder.inputFolder, "/assets/Android/pushnotification.json");
		const tempPushJSON = path.join(TEMP_FOLDER, "assets/pushnotification.json");
		if (!utility.isExistsFileDirSync(pushJSON)) {
			return logger.warn("pushnotification.json not found ! -> ", pushJSON);
		}
		if (TEMP_FM.isIn(tempPushJSON) === null) {
			TEMP_FM.addFileSync(tempPushJSON, pushJSON);
		}
		copy.copyFile(tempPushJSON, destFile);

	};
	/**
	 * Create license.xml by config.androidConfig.input.license object.
	 * @method updateLicenseXML
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 */
	this.updateLicenseXML = function(callBack) {
		const inputFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		const licenseData = globalData.get('androidConfig.androidConfig.input.license.data');
		const tempLicensePath = path.join(TEMP_FOLDER, "license.xml");
		logger.debug('start updateLicenseXML() ');
		if (TEMP_FM.isIn(tempLicensePath) === null) {
			fs.writeFileSync(tempLicensePath, licenseData);
			TEMP_FM.addFileWithoutCopySync(tempLicensePath);
		}
		filemanager.updateWithoutHashSync(inputFolder + '/assets/license.xml', tempLicensePath);
		logger.debug('done updateLicenseXML() ' + inputFolder + '/assets/license.xml');
		changeBundle(callBack);
	};


	/**
	 * change bundle by the license.
	 * @method changeBundle
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 */

	function changeBundle(callBack) {
		const bundle = globalData.get('androidConfig.androidConfig.input.license.bundle');
		const bundleObj = _.extend({}, {
			'io.smartface.SmartfaceDemo': bundle,
			'io/smartface/SmartfaceDemo': bundle.replace(new RegExp(utility.escapeRegExp('.'), 'gm'), '/')
		});
		const rootFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		const folderRegExp = new RegExp('^smali', 'gm');
		const searchRegExp = new RegExp(utility.escapeRegExp('io.smartface.SmartfaceDemo') + '|' +
			utility.escapeRegExp('io/smartface/SmartfaceDemo'), 'gm');

		changer(rootFolder, folderRegExp, searchRegExp, bundleObj, callBack);
	}
	/**
	 * Async function !  add plugins by config.androidConfig.input.plugins object.
	 * @private
	 * @method addPlugins
	 * @param {function} callBack function that called after addPlugins.
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 */


	function addPlugins(callBack) {
		const tmpdir = globalData.get('moduleGlobals.tmpdir');
		const tempFolder = tmpdir + '/pluginsTempFolder';
		const smartfacePlayerFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		const plugins = globalData.get('androidConfig.androidConfig.input.plugins');

		if (plugins.length !== 0) {
			logger.debug('start addPlugins() ');
			utility.mkdirpSync(tempFolder); // create temp folder.
			pluginManagerInit();
			_addPlugins(beginProcess);
			// beginProcess();
		}
		else {
			logger.debug('none Plugins will be added.');
			callBack();
		}

		function fs_readFileSync(filename, options, flag) {
			const _filePath = path.join(smartfacePlayerFolder, filename);
			return fs.readFileSync(_filePath, options, flag);
		}

		function fs_writeFileSync(filename, content, options, mode, flag) {
			const newPath = path.join(smartfacePlayerFolder, filename);
			fse.mkdirsSync(path.dirname(newPath));
			return fs.writeFileSync(newPath, content, options);
		}

		function pluginManagerInit() {
			const input = globalData.get('androidConfig.androidConfig.input');
			const pluginManagerOptions = {
				applicationManifestFilePath: globalData.get('processedArgs.DECOMP_OUTPUT_FOLDER') + '/AndroidManifest.xml',
				applicationPackageName: (input) ? input.license.bundle : globalData.get('config.androidConfig.input.license.bundle'),
				pfs: {
					readFileSync: fs_readFileSync,
					writeFileSync: fs_writeFileSync
				},
				smaliCounter: (fs.existsSync(smartfacePlayerFolder + '/smali_classes2')) ? 2 : 1,
				target: {
					os: 'Android',
					cpu: [input.currentCpuType]
				},
				temp: tempFolder,
				verbose: false
			};
			pluginManager.init(pluginManagerOptions);
		}

		function _addPlugins(callback) {
			var pluginCount = 0;
			_.each(plugins, function(item) {
				pluginManager.addPlugin(item, "Android", function() {
					logger.debug('\t adding Plugin: ' + item.name);
					if (++pluginCount === plugins.length)
						callback();
				});
			});
		}

		function beginProcess() {
			pluginManager.beginProcess(function allPluginsDone(results) {
				if (results.hasError) {
					logger.debug('\t pluginManager has an error. ');
					logger.debug(JSON.stringify(results, null, "\t"));
				}
				_.each(plugins, function(item) {
					logger.debug('\t Plugin: ' + item.name + ' success: ' + results[item.name].success);
				});
				logger.debug('done addPlugins() ');
				callBack();
			});
		}
	}
	/**
	 * finishPublish calling asenkron method..
	 * @method finishPublish
	 * @this AndroidPublisher
	 * @return {undefined} undefined
	 * @memberof AndroidPublisher
	 */
	this.finishPublish = function(callBack) {
		if (!isPluginsAlreadyAdded) {
			addPlugins(callBack);
			isPluginsAlreadyAdded = true;
		}
		else
			callBack(null);
	};

	this.setIsPluginsWillBeAdded = function(bool) {
		isPluginsAlreadyAdded = !!bool;
	};

	this.clearUnusedFilesSync = function() {
		/* test for debug	
	 _.each(filemanager.getFiles(),function(item){
			console.log(item.getPath() +" --> " + item.get("modified"));	
		});
		*/
		filemanager.clearSync();
	};



	this.writeCombinedProjectJSON = function(prJSON) {
		var bufJSON = new Buffer(JSON.stringify(prJSON), "utf8");
		const inputFolder = globalData.get('androidConfig.androidConfig.input.builder.inputFolder');
		if (licenseType !== 'Demo') { // encrypt 
			bufJSON = des3.encryptStrWith3DES_ECB(bufJSON, KEY);
		}
		fs.writeFileSync(path.join(inputFolder, "assets", "project.json"), bufJSON);
	};


};

// android config object control.
function controlAndroidConfig() {
	const androidConfig = globalData.get('androidConfig.androidConfig');
	var errObj;
	if (androidConfig == null) {
		errObj = error.getObject('undefinedNull', {
			err: {
				OBJ: 'null'
			},
			msg: {
				obj: 'config.androidConfig',
				OBJ: 'null'
			}
		});
	}
	else if (!(androidConfig instanceof AndroidConfig)) {
		errObj = error.getObject('object', {
			err: {
				OBJ: 'AndroidConfig'
			},
			msg: {
				obj: 'config.androidConfig',
				OBJ: 'AndroidConfig'
			}
		});
	}
	else {
		const javaPath = globalData.get('androidConfig.androidConfig.input.java.path');
		const apkTool = globalData.get('androidConfig.androidConfig.input.apkTool');
		const signer = globalData.get('androidConfig.androidConfig.input.sign.signer');
		const childJava = spawnSync(javaPath, ['-jar', '-version']);
		if (!utility.controlChildProcess(childJava)) {
			errObj = error.getObject('android.javaPath');
			errObj.msg += ' path: ' + javaPath;
		}
		else {
			/*const outputJava = childJava.output.toString('utf8');
			if (outputJava.search(/1.8.\d/gm) === -1) {
				errObj = error.getObject('android.javaVersion', {
					msg: {
						version: outputJava.substr(outputJava.search(/\d.\d.\d/gm), 8)
					}
				});
			}
			else*/
			if (!utility.controlChildProcess(spawnSync(javaPath, ['-jar', apkTool, '-version']))) {
				errObj = _.extend(error.getObject('android.apktoolPath'), {
					"fullPath": apkTool
				});
			}
			else if (!utility.controlChildProcess(spawnSync(javaPath, ['-jar', signer, '-version']))) {
				errObj = _.extend(error.getObject('android.signerPath'), {
					"fullPath": signer
				});
			}
		}
	}
	if (errObj) {
		logger.error(error.getMsgForLoggerFromErr(errObj));
		utility.killProcess(errObj);
	}

	const plugins = globalData.get('androidConfig.androidConfig.input.plugins');
	const scripts = globalData.get('androidConfig.androidConfig.input.scripts');
	const images = globalData.get('androidConfig.androidConfig.input.images');
	const assets = globalData.get('androidConfig.androidConfig.input.assets');
	const packageProfiles = globalData.get('androidConfig.androidConfig.input.packageProfiles');
	const helpStrNoSuchFileDirInProject = "You should check project folders out in workspace.";
	utility.throwsNoSuchDir(scripts, helpStrNoSuchFileDirInProject);
	utility.throwsNoSuchDir(assets, helpStrNoSuchFileDirInProject);
	utility.throwsNoSuchDir(images, helpStrNoSuchFileDirInProject);
	utility.pngImagesControl(images, packageProfiles);
	_.each(plugins, function(item) {
		utility.throwsNoSuchFile(item.path, 'zip');
	});
	//TODO check players.
}

//control input files.
function control_Config2_AndroidConfig(config) {
	const androidConfig = globalData.get('androidConfig.androidConfig');
	const config2 = globalData.get('androidConfig.config2');
	const key = globalData.get('androidConfig.tripleDes.key');
	if (key.length !== 24) {
		var errObj = error.getObject('tripleDesKey');
		errObj.msg += ' Key Length: ' + key.length;
		logger.error(error.getMsgForLoggerFromErr(errObj));
		utility.killProcess(errObj);
	}
	else {
		utility.controlProperties(config2, 'config.config2');
		utility.controlProperties(androidConfig, 'config.androidConfig');
	}
	controlAndroidConfig();
}

function addParameterMaxMem(param, value) {
	if (value !== null) {
		param.unshift('-Xmx' + value);
	}
}

function reduceLogMessage(output, inputFolder) {
	var warningCleanerReg = /^W:((?!error).)*\n/gmi;
	var inputfolderReg = new RegExp(utility.escapeRegExp(inputFolder), "gmi");
	return output
		.replace(warningCleanerReg, "")
		.replace(inputfolderReg, "");
}

module.exports = AndroidPublisher;
