if (!String.prototype.startsWith) {
	String.prototype.startsWith = function(searchString, position) {
		position = position || 0;
		return this.indexOf(searchString, position) === position;
	};
}

if (!String.prototype.endsWith) {
	String.prototype.endsWith = function(searchString, position) {
		const subjectString = this.toString();
		if (position === undefined || position > subjectString.length) {
			position = subjectString.length;
		}
		position -= searchString.length;
		const lastIndex = subjectString.indexOf(searchString, position);
		return lastIndex !== -1 && lastIndex === position;
	};
}

/**
 * Plugin manager for Smartface CLI
 * @module pluginmanager
 */

/**
 * Target platform information
 * @typedef {Object} targetPlatformInfo
 * @property {string} os - Name of the operating system. (iOS | Android)
 * @property {string[]} cpu - CPU Type (ARM | ARM64 | x86)
 */

/**
 * Synchronously reads the entire contents of a file.
 * @function fs_readFileSync
 * @param {string} filename - Relative path and name of the file to read
 * @param {Object} options - File reading options
 * @param {string|null} options.encoding - default = null
 * @param {string} options.flag - default - 'r'
 * @returns {string|buffer} If the encoding option is specified then this function returns a string. Otherwise it returns a buffer.
 */

/**
 * Synchronously writes the entire contents of a file. If file does not exists, automatically cretes a new file with the given name
 * @function fs_writeFileSync
 * @param {string} filename - Relative path and name of the file to write.
 * @param {string|Buffer} data - Data to write
 * @param {Object} options - File write options
 * @param {string|null} options.encoding - default = 'utf8'
 * @param {number} options.mode - Default = 438 (aka 0666 in Octal)
 * @param {string} options.flag - default - 'w'
 */

/**
 * File System for interacting with output
 * @typedef {Object} PackageFileSystem
 * @property {module:pluginmanager~fs_readFileSync} readFileSync - Synchronously reads the entire contents of a file
 * @property {module:pluginmanager~fs_writeFileSync} writeFileSync - Synchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer.
 */

/**
 * Options object used with initialization of plugin manager
 * @typedef {Object} PluginManagerOptions
 * @property {module:pluginmanager~targetPlatformInfo} target - Target platform info
 * @property {string} temp - Temporary files path
 * @property {module:pluginmanager~PackageFileSystem} pfs - Package file system
 * @property {boolean} verbose - Logs information to console
 */

/**
 * @callback BeginProcessCallback
 * @param {Object} results - Provides results. Check examples
 */

/**
 * @typedef {Object} PluginInfo
 * @property name - name of the plugin
 * @property path - path of the plugin zip
 */


var pluginmanager = {
	options: null,
	plugins: []
};

const fs = require("fs");
const path = require("path");
const mix = require("./mix-objects");
const xmlmerge = require("smf-xmlmerge-js");
const EventEmitter = require("events").EventEmitter;
const xpath = require("xpath");
const xmldom = require("xmldom");
const DOMParser = xmldom.DOMParser;
const XMLSerializer = xmldom.XMLSerializer;
const exec = require("child_process").exec;
const checkApplicationClass = require("../plugin/checkApplicationClass");
const escape = require('../utility').escapeRegExp;
const AndroidPluginParser = require('./android/pluginParser');
const ResourceMerger = require('./android/resourceMerger');
const iosPluginParser = require('./ios/pluginParser');
const globalData = require('../globalData');
const utility = require('../utility');
const error = require("../error");

const FILE_OPTIONS_BINARY = {
	encoding: "binary"
};
const FILE_OPTIONS_UTF8 = {
	encoding: "utf8"
};
const AdmZip = require('adm-zip');
const fs_extra = require('fs-extra');
const jsonlint = require("jsonlint");

/**
 * Initializes plugin manager
 * @param {module:pluginmanager~PluginManagerOptions} options
 */
exports.init = function init(options) {
	pluginmanager.options = options;
	pluginmanager.plugins = [];
};


/**
 * Adds name of the plugin to integrate with package
 * @param {module:pluginmanager~PluginInfo} pluginInfo - Plugin name and path
 */
exports.addPlugin = function addPlugin(pluginInfo, os, callback) {
	if (!pluginInfo.path) throw Error("Plugin path has to be supplied");
	if (!pluginInfo.name) throw Error("Plugin name has to be supplied");

	if (os === "Android") {
		checkZipForEnvironment('android', pluginInfo.path, function(data) {
			if (data) {
				pluginmanager.plugins.push(pluginInfo);
			}
			callback();
		});
	}
	else if (os === "iOS") {
		checkZipForEnvironment('ios', pluginInfo.path, function(data) {
			if (data) {
				pluginmanager.plugins.push(pluginInfo);
			}
			callback();
		});
	}
	else {
		pluginmanager.plugins.push(pluginInfo);
		callback();
	}
};
/**
 * Starts integration with plugins. When this is called, it may has modified some content of output
 * @param {BeginProcessCallback} callback - Called after completing integration
 */
exports.beginProcess = function beginProcess(callback) {
	processObject[pluginmanager.options.target.os](callback);
};

function iOSArguments(options) {
	applyCommonParameters(this);
	mix(this, [options]);
}

function AndroidArguments(options) {
	applyCommonParameters(this);
	mix(this, [options]);
}
const contextCreator = {
	iOS: iOSArguments,
	Android: AndroidArguments
};
var contextStore = {};

function applyCommonParameters(target) {
	mix(target, [{
			cpu: pluginmanager.options.target.cpu,
			os: pluginmanager.options.target.os,
			hasCustomProcessor: false
		},
		new EventEmitter()
	]);
}

function processAndroid(callback) {
	const pfs = pluginmanager.options.pfs;
	var baseManifest = pfs.readFileSync("AndroidManifest.xml", FILE_OPTIONS_UTF8);
	var smaliCounter = pluginmanager.options.smaliCounter - 0;
	const DECOMP_OUTPUT_FOLDER = globalData.get('processedArgs.DECOMP_OUTPUT_FOLDER');
	var smaliFolderArr, ioSmartfacePath, fitSmaliFolder;

	findSmaliFolders().then(function(res) {
		smaliFolderArr = res.smaliFolderArr;
		ioSmartfacePath = res.ioSmartfacePath;
		fitSmaliFolder = res.fitSmaliFolder;
		extractPlugins(pluginCallback, allDone);
	}, function(err) {
		utility.killProcess(err);
	});

	const SEP = "\\" + path.sep;

	function pluginCallback(pluginContext) {
		log("processing plugin " + pluginContext.name);
		pluginContext.applicationPackageName = pluginmanager.options.applicationPackageName;
		pluginContext.data = pluginmanager.options.data;
		pluginContext.applicationManifestFilePath = pluginmanager.options.applicationManifestFilePath;
		const actions = new ExpActionList(pluginContext);
		const lastActions = new ExpActionList(pluginContext);

		//Handle Manifest File
		actions.add("AndroidManifest.xml", function(pluginContext, file, pluginFile) {
			const checkResult = checkApplicationClass({
				readFileSync: fs.readFileSync,
				basePath: path.dirname(pluginFile)
			});
			if (!checkResult) {
				pluginContext.error = checkApplicationClass.errorText;
				return true;
			}
			var pluginManifest = fs.readFileSync(pluginFile, "utf8");

			const config = [{
				nodename: "manifest",
				attrname: "*"
			}, {
				nodename: "application",
				attrname: "*"
			}, {
				nodename: "activity",
				attrname: "android:name"
			}, {
				nodename: "uses-permission",
				attrname: "android:name"
			}, {
				nodename: "meta-data",
				attrname: "android:name"
			}];

			const pluginManifestDoc = new DOMParser().parseFromString(pluginManifest);
			const param = {
				doc: baseManifest
			};
			AndroidPluginParser.handleManifest(pluginContext, pluginManifestDoc, param);
			baseManifest = param.doc;
			const nodes = xpath.select("//activity[intent-filter/category/@*[local-name()='name']='android.intent.category.LAUNCHER']", pluginManifestDoc);
			nodes.forEach(function(element, index, array) {
				element.parentNode.removeChild(element);
			});
			const s = new XMLSerializer();
			pluginManifest = s.serializeToString(pluginManifestDoc);

			xmlmerge.merge(baseManifest, pluginManifest, config, function(xml) {
				baseManifest = xml;
			});

			return true;
		});

		actions.add(new RegExp("^(smali[.]*)"), function(pluginContext, file, pluginFile) {
			if ((new RegExp(/^smali.*[\\|\/]R[\x24|\x2E][a-zA-Z]*\x2E?smali$/)).test(file)) {
				return false;
			}
			return true;
		});

		//Handle smali
		lastActions.add(new RegExp("^(smali[.]*)"), function(pluginContext, file, pluginFile) {
			const skipList = ["SMFJS.smali", "SMFJSObject.smali"];
			var skip = false;
			skipList.forEach(function(element, index, array) {
				if (skip) return;
				skip = file.startsWith(element);
			});
			if (skip) {
				return true;
			}
			pluginContext.smali = pluginContext.smali || {};
			const index = file.indexOf(path.sep);
			const originalSmaliFolderName = file.substring(0, index);
			const restOfPath = file.substring(index);
			if (!pluginContext.smali[originalSmaliFolderName]) {
				smaliCounter++;
				pluginContext.smali[originalSmaliFolderName] = "smali_classes" + smaliCounter;
			}

			const newFilePath = pluginContext.smali[originalSmaliFolderName] + restOfPath;

			// Nosaiba said that if plugin has its own application class, that package
			// should be in the first smali folder
			if (pluginContext.moveApplicationSmali) {
				const rgxReplacer = /[\.]/g;
				const smaliName = path.sep + pluginContext.applicationName.replace(rgxReplacer, path.sep) + ".smali";
				if (smaliName === restOfPath) {
					pluginContext.moveApplicationSmaliSourceFolder = newFilePath.substring(0, newFilePath.indexOf(path.sep));
				}
			}

			if (!newFilePath.match(/android[\/|\\]support/) && !(newFilePath.match(/com[\/|\\]google[\/|\\]android[\/|\\]gms/) || newFilePath.match(/com[\/|\\]google[\/|\\]ads/)) &&
				!newFilePath.match(/[\\|\/]R[\x24|\x2E]/)) {

				const fileContentR = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
				const replace = "L" + pluginContext.applicationPackageName.replace(new RegExp("\\.", 'g'), "\/") + "/R$";
				const publicXmlPath = globalData.get('processedArgs.DECOMP_OUTPUT_FOLDER') +
					"/res/values/public.xml";
				const fileContentW = ResourceMerger.fixHexValuesInSmali(fileContentR, publicXmlPath, pluginContext.RSmaliFiles);
				fs.writeFileSync(pluginFile, fileContentW.replace(/L.*\/R\$/g, replace));
			}
			else if (!newFilePath.match(/android[\/|\\]support/) && !(newFilePath.match(/com[\/|\\]google[\/|\\]android[\/|\\]gms/) || newFilePath.match(/com[\/|\\]google[\/|\\]ads/)) &&
				newFilePath.match(/[\\|\/]R[\x24|\x2E]/)) {
				const replace2 = "L" + pluginContext.applicationPackageName.replace(new RegExp("\\.", 'g'), "\/") + "/R$";
				const smaliname = file.substring(file.lastIndexOf(path.sep) + 1);
				var smalipath = "";
				smalipath = path.join(fitSmaliFolder, smaliname);
				const oldPublicXmlPath = path.join(pluginContext.path, 'res', 'values', 'public.xml');
				const newPublicXmlPath = path.join(globalData.get('processedArgs.DECOMP_OUTPUT_FOLDER'), 'res', 'values', 'public.xml');
				try {
					const fileContentH = fs.readFileSync(smalipath, FILE_OPTIONS_UTF8);
					const fileContentX = ResourceMerger.fixArrayHexValuesInSmali(fileContentH, newPublicXmlPath, oldPublicXmlPath, smaliname);
					fs.writeFileSync(smalipath, fileContentX);
				}
				catch (e) {
					if (e.code === 'ENOENT') {
						fs.writeFileSync(smalipath, fs.readFileSync(pluginFile, "utf8").replace(/L.*\/R\$/g, replace2), "utf8");
					}
					else {
						throw e;
					}
				}
			}

			if (typeof pluginContext.mainActivityReplacer === 'function') {
				const smali_file_contentR = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
				const smali_file_contentW = pluginContext.mainActivityReplacer(smali_file_contentR);
				pfs.writeFileSync(newFilePath, smali_file_contentW, FILE_OPTIONS_UTF8);
				return true;
			}

			return actions.defaultAction.action(pluginContext, newFilePath, pluginFile);
		});

		actions.add(new RegExp(/^smali.*[\\|\/]R[\x24|\x2E][a-zA-Z]*\x2E?smali$/), function(pluginContext, file, pluginFile) {
			const packagePath = pluginContext.pluginPackageName.replace(/([a-zA-Z])\x2E([a-zA-Z])/g, "$1" + path.sep + "$2");
			const regExpStr = "^.*" + escape(packagePath) + "[\\x5C|\\x2F](R[\\x24|\\x2E][a-zA-Z]*\\x2E?smali)";
			const regExp = new RegExp(regExpStr);
			const result = regExp.exec(file);
			if (!result)
				return false;

			if (!pluginContext.RSmaliFiles) {
				pluginContext.RSmaliFiles = [];
			}
			pluginContext.RSmaliFiles.push(pluginFile);

			const smaliFile = result[1];
			// found  smalifile under smali folders or null.
			var playerSmaliPath = findRSmaliFile(smaliFile);

			const publicXmlPath = DECOMP_OUTPUT_FOLDER + "/res/values/";
			var pluginSmaliContent, search, replace;
			if (playerSmaliPath) {
				var playerSmaliContent;
				playerSmaliContent = fs.readFileSync(playerSmaliPath, FILE_OPTIONS_UTF8);
				pluginSmaliContent = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
				playerSmaliContent = ResourceMerger.mergeResourceSmaliFiles(pluginSmaliContent, playerSmaliContent,
					publicXmlPath, smaliFile);
				search = "L" + pluginContext.pluginPackageName.replace(new RegExp("\\.", 'g'), "\/") + "/R";
				replace = "L" + pluginContext.applicationPackageName.replace(new RegExp("\\.", 'g'), "\/") + "/R";
				fs.writeFileSync(playerSmaliPath, playerSmaliContent.replace(new RegExp(escape(search), 'g'), replace), FILE_OPTIONS_UTF8);
			}
			else {
				pluginSmaliContent = fs.readFileSync(pluginFile, "utf-8");
				search = "L" + pluginContext.pluginPackageName.replace(new RegExp("\\.", 'g'), "\/") + "/R";
				replace = "L" + pluginContext.applicationPackageName.replace(new RegExp("\\.", 'g'), "\/") + "/R";
				fs.writeFileSync(path.join(fitSmaliFolder, smaliFile), pluginSmaliContent.replace(new RegExp(escape(search), 'g'), replace), FILE_OPTIONS_UTF8);
			}

			return true;
		});

		//Handle res
		actions.add(new RegExp("^res[.]*"), function(pluginContext, file, pluginFile) {
			const skipExp = new RegExp(escape("^res" + SEP + "drawable.*|layout.*|menu.*|raw.*|anim|color|xml)" + SEP));
			if (skipExp.test(file) || !file.endsWith(".xml")) {
				return false; // will not handle those
			}
			if (file.indexOf(path.join('res', 'values', 'public.xml')) > -1) {
				return false;
			}

			const config = [{
				nodename: "*",
				attrname: "name"
			}];

			const pfs = pluginmanager.options.pfs;
			const fileContent = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
			var targetFileContent = null;
			try {
				targetFileContent = pfs.readFileSync(file, FILE_OPTIONS_UTF8);
			}
			catch (ex) {}
			if (targetFileContent === null || typeof targetFileContent === "undefined") {

				pfs.writeFileSync(file, fileContent, FILE_OPTIONS_UTF8);
			}
			else {
				xmlmerge.merge(targetFileContent, fileContent, config, function(xml) {
					targetFileContent = xml;
					pfs.writeFileSync(file, targetFileContent, FILE_OPTIONS_UTF8);
				});
			}
			return true;
		});
		/*
				//Add plugin running information file
				actions.add(path.join("assets", "PluginConfig.JSON"), function(pluginContext, file, pluginFile) {
					const pfs = pluginmanager.options.pfs;
					const fileContent = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
					var targetFileContent = null;
					try {
						targetFileContent = pfs.readFileSync(file, FILE_OPTIONS_UTF8);
					}
					catch (ex) {}
					if (targetFileContent === null || typeof targetFileContent === "undefined") {

						pfs.writeFileSync(file, fileContent, FILE_OPTIONS_UTF8);
					}
					else {
						var basePluginsObject = {};
						try {
							basePluginsObject = JSON.parse(targetFileContent);
						}
						catch (ex) {}
						var newPluginObject = {};
						try {
							newPluginObject = JSON.parse(fileContent);
						}
						catch (ex) {}
						basePluginsObject.classes = basePluginsObject.classes || [];
						newPluginObject.classes = newPluginObject.classes || [];

						for (var i = 0; i < basePluginsObject.classes.length; i++) {
							if (newPluginObject.classes.indexOf(basePluginsObject.classes[i]) > -1) {
								newPluginObject.classes.splice(newPluginObject.classes.indexOf(basePluginsObject.classes[i]), 1);
							}
						}

						basePluginsObject.classes = basePluginsObject.classes.concat(newPluginObject.classes);

						const newContent = JSON.stringify(basePluginsObject);
						pfs.writeFileSync(file, newContent, FILE_OPTIONS_UTF8);
					}
					return true;
				});
		*/
		//Skipped original folder
		actions.add(new RegExp("^original"), function() {
			return true;
		});

		actions.add(new RegExp("^res[.]*"), function(pluginContext, file, pluginFile) {
			const skipExp = new RegExp(escape("^res" + SEP + "drawable.*|layout.*|menu.*|raw.*|anim|color|xml)" + SEP));
			if (skipExp.test(file) || !file.endsWith(".xml")) {
				return false; // will not handle those
			}
			if (file.indexOf(path.join('res', 'values', 'public.xml')) > -1) {
				return false;
			}
			const pfs = pluginmanager.options.pfs;
			// TODO: Replace all below into a function, cache RegExp into const above
			// Are they being read over and over? work on the string and save once?
			var fileContent = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
			var searchRegExp = new RegExp("\"@id", "gm");
			var changeObj = {
				'"@id': '"@+id'
			};
			fs.writeFileSync(pluginFile, fileContent.replace(searchRegExp, function(matched) {
				return changeObj[matched];
			}), FILE_OPTIONS_UTF8);

			fileContent = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
			searchRegExp = new RegExp("\"@drawable", "gm");
			changeObj = {
				'"@drawable': '"@+drawable'
			};
			fs.writeFileSync(pluginFile, fileContent.replace(searchRegExp, function(matched) {
				return changeObj[matched];
			}), FILE_OPTIONS_UTF8);

			fileContent = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
			searchRegExp = new RegExp("\"@color", "gm");
			changeObj = {
				'"@color': '"@+color'
			};
			fs.writeFileSync(pluginFile, fileContent.replace(searchRegExp, function(matched) {
				return changeObj[matched];
			}), FILE_OPTIONS_UTF8);

			fileContent = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
			searchRegExp = new RegExp("\"@string", "gm");
			changeObj = {
				'"@string': '"@+string'
			};
			fs.writeFileSync(pluginFile, fileContent.replace(searchRegExp, function(matched) {
				return changeObj[matched];
			}), FILE_OPTIONS_UTF8);

			fileContent = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
			searchRegExp = new RegExp("\"@attr", "gm");
			changeObj = {
				'"@attr': '"@+attr'
			};
			fs.writeFileSync(pluginFile, fileContent.replace(searchRegExp, function(matched) {
				return changeObj[matched];
			}), FILE_OPTIONS_UTF8);

			fileContent = fs.readFileSync(pluginFile, FILE_OPTIONS_UTF8);
			searchRegExp = new RegExp("\"@anim", "gm");
			changeObj = {
				'"@anim': '"@+anim'
			};
			fs.writeFileSync(pluginFile, fileContent.replace(searchRegExp, function(matched) {
				return changeObj[matched];
			}), FILE_OPTIONS_UTF8);

			//fs.writeFileSync(file, fileContent, FILE_OPTIONS_UTF8);
			return false;
		});

		//skipping certain images
		actions.add(new RegExp("^res" + SEP + "drawable.*" + SEP + " (?:action_item_selected|arrow_down|arrow_up|buttom_bar|bottom_bar_highlight.9|close|clear|delete|defaultsplash|down|drawer_shadow.9|ic_action_search|icon|popup|pin|up).png$", "gi"), function(pluginContext, file, pluginFile) {
			return true;
		});

		//skipping certain layouts
		actions.add(new RegExp("^res" + SEP + "layout.*" + SEP + "(?:action_item_horizontal|action_item_vertical|activity_main|bubble|main|popup_horizontal|popup_vertical|pull_to_refresh_header_horizontal|pull_to_refresh_header_vertical|vertical_seperator).xml$", "gi"), function(pluginContext, file, pluginFile) {
			return true;
		});

		//skipping certain menu
		actions.add(new RegExp("^res" + SEP + "menu.*" + SEP + "(?:activity_main|\\\\editmenu).xml$", "gi"), function(pluginContext, file, pluginFile) {
			return true;
		});

		//skipping certain xml
		actions.add(new RegExp("^res" + SEP + "xml.*searchable.xml$", "gi"), function(pluginContext, file, pluginFile) {
			return true;
		});

		//skipping support libraries
		actions.add(new RegExp("^smali" + SEP + "(?:com" + SEP + "google" + SEP + "(?:ads|android" + SEP + "gms)|android" + SEP + "support" + SEP + "(?:annotation|multidex|v4|v7)).*", "gi"), function(pluginContext, file, pluginFile) {
			return true;
		});

		removeUnusedLib(path.join(DECOMP_OUTPUT_FOLDER, "lib"),
			path.join(pluginContext.path, "lib")).then(res => {
			walk(pluginContext, pluginContext.path, function(err, results) {
				if (err) {
					throw err;
				}
				log(results);
				results.forEach(function(file, index, array) {
					actions.handleAll(file);
				});
				results.forEach(function(file, index, array) {
					lastActions.handleAll(file);
				});
				const hfs = require("fs-extra");
				if (pluginContext.moveApplicationSmali) {
					fs.renameSync(DECOMP_OUTPUT_FOLDER + path.sep + "smali", DECOMP_OUTPUT_FOLDER + path.sep + "smali_temp");
					fs.renameSync(DECOMP_OUTPUT_FOLDER + path.sep + pluginContext.moveApplicationSmaliSourceFolder, DECOMP_OUTPUT_FOLDER + path.sep + "smali");
					hfs.copySync(DECOMP_OUTPUT_FOLDER + path.sep + "smali_temp/android", DECOMP_OUTPUT_FOLDER + path.sep + "smali/android", {
						clobber: true
					});
					hfs.removeSync(DECOMP_OUTPUT_FOLDER + path.sep + "smali_temp/android");
					hfs.copySync(DECOMP_OUTPUT_FOLDER + path.sep + "smali_temp/io", DECOMP_OUTPUT_FOLDER + path.sep + "smali/io", {
						clobber: true
					});
					hfs.removeSync(DECOMP_OUTPUT_FOLDER + path.sep + "smali_temp/io");
					hfs.renameSync(DECOMP_OUTPUT_FOLDER + path.sep + "smali_temp", DECOMP_OUTPUT_FOLDER + path.sep + pluginContext.moveApplicationSmaliSourceFolder);
				}
				var files;
				try {
					files = fs.readdirSync(path.join(pluginContext.path, "assets"));
				}
				catch (exp) {}
				files && files.forEach(file => {
					log("copied asssets file: " + file);
					hfs.copySync(path.join(pluginContext.path, "assets", file), path.join(DECOMP_OUTPUT_FOLDER, "assets", file));
				});
				log("finished processing plugin " + pluginContext.name);
				pluginContext.emit(pluginContext.hasCustomProcessor ? "postProcess" : "done", pluginContext);
			});
		}, err => {
			utility.killProcess(error.getObject("unexpected", {
				msg: {
					err: err.toString('utf8')
				}
			}));
		});
	}

	function allDone(results) {
		pfs.writeFileSync("AndroidManifest.xml", baseManifest, FILE_OPTIONS_UTF8);
		log("done processing all plugins");
		callback && callback(results);
	}

	//find and detect fit smali folder if is there it and all smaliFolders. 
	function findSmaliFolders() {

		var regexRSmali = /R\$.*\.smali/gi;

		return new Promise(function(resolve, reject) {
			var ioSmartfacePath, isResolved = false;
			var smaliFolderArr = [];
			var fitSmaliFolder = null;
			var processCount = 0;
			if (globalData.get('args').inputApkPackageSuffix) {
				ioSmartfacePath = "io/smartface/" + globalData.get('args').inputApkPackageSuffix;;
			}
			else {
				/*
				ioSmartfacePath = globalData.get("processedArgs.config_json").build.output.android.packageName;
				ioSmartfacePath = ioSmartfacePath.replace(/\./gm, "/");
				*/
				ioSmartfacePath = path.join("io", "smartface", "SmartfaceDemo");
			}
			fs.readdir(DECOMP_OUTPUT_FOLDER, (err, list) => {
				if (err) {
					done(error.getObject("unexpected", {
						msg: {
							err: err.toString('utf8')
						}
					}));
				}
				else {
					var item;
					for (var i = 0; i < list.length; ++i) {
						item = list[i];
						if (/^smali/.test(item)) {
							var fullPath = path.join(DECOMP_OUTPUT_FOLDER, item, ioSmartfacePath);
							checkSmaliFolder(fullPath, done);
						}
						else {
							done();
						}
					}
				}
				// handling each process results. 
				function done(_err, fitFolder) {
					processCount++;

					if (fitFolder) {
						fitSmaliFolder = fitFolder;
					}
					if (_err) {
						reject(_err);
					}
					else if (processCount == list.length) {
						if (smaliFolderArr.length === 0) {
							var errObj = error.getObject("plugin.smaliFolder", {
								msg: {
									msg: "We could not find '" + ioSmartfacePath + "'in any smali folder."
								}
							});
							reject(errObj);
						}
						else {
							if (!fitSmaliFolder) {
								fitSmaliFolder = smaliFolderArr[0];
							}
							resolve({
								smaliFolderArr: smaliFolderArr,
								ioSmartfacePath: ioSmartfacePath,
								fitSmaliFolder: fitSmaliFolder
							});
						}
					}
				}

				//check smali Folder
				function checkSmaliFolder(folderPath, _done) {
					fs.stat(folderPath, (err, stats) => {
						if (!err && stats.isDirectory()) {
							smaliFolderArr.push(folderPath);
							detectFitSmaliFolder(folderPath, _done);
						}
						else {
							_done(null);
						}
					});
				}

			});

		});
		// detect directory which has at least one  R$..smali file.
		function detectFitSmaliFolder(folder, _done) {

			fs.readdir(folder, (err, list) => {
				if (err) {
					_done(error.getObject("unexpected", {
						msg: {
							err: err.toString('utf8')
						}
					}));
				}
				else {
					list.forEach(function(item) {
						if (regexRSmali.test(item)) {
							return _done(null, folder);
						}
					});
					_done(null);
				}
			});

		}
	}

	function findRSmaliFile(RSmaliFile) {
		var res = null,
			temp;

		smaliFolderArr.forEach(function(item) {
			temp = path.join(item, RSmaliFile);
			try {
				fs.statSync(temp);
				res = temp;
				return;
			}
			catch (e) {
				// RSmaliFile doesn't exist.
			}
		});
		return res;
	}
}

function removeUnusedLib(playerLibFolderPath, pluginLibFolderPath) {
	return new Promise((resolve, reject) => {
		var taskCount = 0;
		utility
			.isExistsFileDir(pluginLibFolderPath)
			.then(res => {
				if (!res.existing) {
					return resolve(null);
				}
				var playerlibFolders = fs.readdirSync(playerLibFolderPath),
					pluginLinFolders = fs.readdirSync(pluginLibFolderPath),
					validLibFolders = [];


				pluginLinFolders.forEach((folder, index) => {
					if (playerlibFolders.indexOf(folder) === -1) {
						++taskCount;
						fs_extra.remove(path.join(pluginLibFolderPath, folder), done);
					}
					else {
						validLibFolders.push(folder);
					}
				});

				validLibFolders.forEach((folder) => {
					fs
						.readdirSync(path.join(pluginLibFolderPath, folder))
						.forEach((file) => {
							++taskCount;
							utility
								.isExistsFileDir(path.join(playerLibFolderPath, folder, file))
								.then(res => {
									if (res.existing) {
										++taskCount;
										fs_extra.remove(path.join(pluginLibFolderPath, folder, file), done);
									}
									done();
								}, done);
						});
				});

				done();
			});


		function done(err) {
			if (err)
				return reject(err);
			if (--taskCount === -1) {
				resolve(null);
			}
		}

	});


}



function processiOS(callback) {
	//TODO: search other pfs
	var pfs = pluginmanager.options.pfs;

	extractPlugins(pluginCallback, allDone);

	function pluginCallback(pluginContext) {

		iosPluginParser.handlePluginDiffs(pluginContext, pfs).then(function(res) {
			pluginContext.emit(pluginContext.hasCustomProcessor ? "postProcess" : "done", pluginContext);
		}, function(err) {
			callback(err);
		});

	}

	function allDone(results) {
		function spliceSlice(str, index, count, add) {
			return str.slice(0, index) + (add || "") + str.slice(index + count);
		}
		if (!results.hasError) {
			const filePath = "Smartface.xcodeproj/project.pbxproj";
			var pbxproj;
			pfs
				.getPbxProject()
				.then(function(data) {
					pbxproj = data;
					const lookup = "shellScript = \"# unzip plugin frameworks to their related folders\\nPLUGIN_ROOT=${SOURCE_ROOT}/Smartface/Plugins";

					const start = pbxproj.indexOf(lookup);
					const end = pbxproj.indexOf("\";", start);

					var commands = [lookup];
					for (var pluginName in contextStore) {
						var pluginContext = contextStore[pluginName];
						var zipFiles = pluginContext.pkg.zipFiles;
						if (zipFiles) {
							if (typeof zipFiles === "string") zipFiles = [zipFiles];
							zipFiles.forEach(zipFileName => {
								commands.push("\\n\\nunzip -o \\\"${PLUGIN_ROOT}/" + zipFileName + "\\\" -d \\\"${PLUGIN_ROOT}/\\\"\\nrm -rf \\\"$PLUGIN_ROOT/" + zipFileName + "\\\"");
								var sourceZipPath = path.join(pluginContext.path, zipFileName);
								var targetZipPath = "Smartface/Plugins/" + zipFileName;
								var fileContent = fs.readFileSync(sourceZipPath, FILE_OPTIONS_BINARY);
								pfs.writeFileSync(targetZipPath, fileContent, FILE_OPTIONS_BINARY);
							});
						}
					}
					pbxproj = spliceSlice(
						pbxproj,
						start,
						end - start,
						commands.join("")
					);
					pfs.writeFileSync(filePath, pbxproj, "utf8");
					finalize();
				}, function(err) {
					callback(err);
				});
		}
		else {
			finalize();
		}

		function finalize() {
			iosPluginParser.handleAllPluginsDone(pfs);
			log("done processing all plugins");

			if (callback) {
				callback(results);
			}
		}

	}

}
var processObject = {
	Android: processAndroid,
	iOS: processiOS
};

function ExpAction(exp, action) {
	this.exp = exp;
	this.action = action;
}
ExpAction.prototype.handle = function handle(pluginContext, file, pluginFile) {
	if (!(this.exp && this.action)) {
		throw Error("Invalid ExpAction");
	}
	if (typeof this.exp === "string") {
		return this.exp === file && this.action(pluginContext, file, pluginFile);
	}
	else if (this.exp instanceof RegExp) {
		this.exp.lastIndex = 0;
		if (this.exp.test(file))
			return this.action(pluginContext, file, pluginFile);
		else
			return false;
	}
	else {
		throw Error("Expression is not supported");
	}
};

function ExpActionList(pluginContext, list) {
	if (!pluginContext) throw Error("pluginContext is required");
	var internalList = [];
	this.defaultAction = new ExpAction(new RegExp(".*", "gi"), function(pluginContext, file, pluginFile) {
		const pfs = pluginmanager.options.pfs;
		var targetFileContent = null;
		try {
			targetFileContent = pfs.readFileSync(file, FILE_OPTIONS_BINARY);
		}
		catch (ex) {}
		if (targetFileContent === null || typeof targetFileContent === "undefined") {
			var fileContent = fs.readFileSync(pluginFile, FILE_OPTIONS_BINARY);
			pfs.writeFileSync(file, fileContent, FILE_OPTIONS_BINARY);
		}
		else {
			log("skipped file: " + file);
		}
		return true;
	});
	if (!list) {
		if (list instanceof ExpAction)
			list = [list];
		internalList.concat(list);
	}
	//needs to be last
	internalList.push(this.defaultAction);

	this.add = function add(item) {
		if (item instanceof ExpAction)
			return internalList.unshift(item);
		const exp = arguments[0];
		const action = arguments[1];
		const newExpAction = new ExpAction(exp, action);
		return internalList.unshift(newExpAction);
	};
	this.handleAll = function handleAll(file) {
		const pluginFile = path.join(pluginContext.path, file);
		var handled = false;
		internalList.forEach(function(element, index, array) {
			if (handled) return;
			if (pluginContext.error) return;
			handled = element.handle(pluginContext, file, pluginFile);
			if (typeof handled === "undefined") {
				utility.writeJsonMsgToStdout("warning: May have forgotten return handled situation?");
			}
		});
	};
}

function walk(pluginContext, dir, done) {
	const baseStripLength = pluginContext.path.length + 1;
	var results = [];
	fs.readdir(dir, function(err, list) {
		if (err) return done(err);
		var pending = list.length;
		if (!pending) return done(null, results);
		list.forEach(function(file) {
			file = path.resolve(dir, file);
			fs.stat(file, function(err, stat) {
				if (err) throw err;
				if (stat && stat.isDirectory()) {
					walk(pluginContext, file, function(err, res) {
						if (err) throw err;
						results = results.concat(res);
						if (!--pending) done(null, results);
					});
				}
				else {
					const filePathToAdd = file.substring(baseStripLength);
					filePathToAdd && results.push(filePathToAdd);
					if (!--pending) done(null, results);
				}
			});
		});
	});
}

function removeSmaliFilesFromPluginExistingInPlayer(decompiledPlayerPath, decompiledPluginPath) {
	var rootPlayerFolders = fs.readdirSync(decompiledPlayerPath);
	//var rootPluginFolders = fs.readdirSync(decompiledPluginPath);
	var smaliPlayerFolders = [];
	rootPlayerFolders.forEach(function(folder) {
		if (folder.toString().indexOf('smali') > -1) {
			smaliPlayerFolders.push(folder);
		}
	});
	smaliPlayerFolders.forEach(function(smaliFolder) {
		var currentPluginSmaliFolder = path.join(decompiledPluginPath, smaliFolder);
		if (fs.existsSync(currentPluginSmaliFolder)) {
			checkRemoveSmaliFiles(path.join(decompiledPlayerPath, smaliFolder), currentPluginSmaliFolder);
		}
	});
}

function checkRemoveSmaliFiles(playerSmaliFolder, pluginSmaliFolder) {
	var playerSmaliFiles = [];
	var pluginSmaliFiles = [];
	var pluginSmaliFolders = [];
	var playerSmaliFolderRead = utility.readDirSyncRecursively(playerSmaliFolder);
	var pluginSmaliFolderRead = utility.readDirSyncRecursively(pluginSmaliFolder);
	playerSmaliFolderRead.forEach(function(item) {
		if (fs.statSync(path.join(playerSmaliFolder, item)).isFile()) {
			playerSmaliFiles.push(item);
		}
	});
	pluginSmaliFolderRead.forEach(function(item) {
		if (fs.statSync(path.join(pluginSmaliFolder, item)).isFile()) {
			pluginSmaliFiles.push(item);
		}
		if (fs.statSync(path.join(pluginSmaliFolder, item)).isDirectory()) {
			pluginSmaliFolders.push(item);
		}
	});
	playerSmaliFiles.forEach(function(item) {
		if (pluginSmaliFiles.indexOf(item) > -1) {
			fs_extra.removeSync(path.join(pluginSmaliFolder, item));
		}
	});
	pluginSmaliFolders.forEach(function(folder) {
		//remove empty folders
		var fol = fs.readdirSync(path.join(pluginSmaliFolder, folder));
		if (fol.length === 0) {
			fs_extra.removeSync(path.join(pluginSmaliFolder, folder));
		}
	});
}

function extractPlugins(pluginCallback, allDone) {
	var pluginReadyCount = 0;
	var pluginExecutionResults = {
		hasError: false
	};
	pluginmanager.plugins.forEach(function(pluginInfo, index, array) {
		const pluginName = pluginInfo.name;
		const tempExtractPath = path.join(pluginmanager.options.temp, pluginmanager.options.target.os, pluginName);
		var zip = new AdmZip(pluginInfo.path);
		zip.extractAllTo(tempExtractPath, true);
		const filesPath = pluginmanager.options.target.os === "Android" ? path.join(tempExtractPath, "apk") : tempExtractPath;
		if (pluginmanager.options.target.os === 'Android') {
			changeBundle(tempExtractPath);
			var decompiledPlayerPath = globalData.get('processedArgs.DECOMP_OUTPUT_FOLDER');
			removeSmaliFilesFromPluginExistingInPlayer(decompiledPlayerPath, filesPath);
		}

		var pluginContext = new contextCreator[pluginmanager.options.target.os]({
			index: index,
			info: pluginInfo,
			name: pluginName,
			path: filesPath,
			pfs: pluginmanager.options.pfs
		});
		contextStore[pluginName] = pluginContext;

		pluginContext.once("start", function() {
			pluginCallback(pluginContext);
		});
		pluginContext.once("done", function(e) {
			signalDone(e);
		});

		try {
			const pkg = JSON.parse(fs.readFileSync(path.join(tempExtractPath, "package.json"), "utf8"));
			pluginContext.pkg = pkg;
			if (pkg.main) {

				const node_modulesDir = path.join(tempExtractPath, "node_modules");
				if (!fs.existsSync(node_modulesDir)) {
					fs.mkdirSync(node_modulesDir);
				}
				const cmd = "npm install";
				exec(cmd, {
					cwd: tempExtractPath
				}, function(error, stdout, stderr) {
					if (!error) {
						pluginContext.on("postProcess", function pluginContext_postProcess() {
							try {
								const require_path = path.join(tempExtractPath, pkg.main);
								const pluginHandler = require(require_path);
								pluginHandler(pluginContext);
							}
							catch (ex) {
								pluginContext.error = ex;
							}
							pluginContext.emit("done", pluginContext);
						});
						pluginContext.hasCustomProcessor = true;
						pluginContext.emit("start");
					}
					else {
						pluginContext.error = error;
						pluginContext.emit("done", pluginContext);
					}
				});

			}
			else {
				pluginContext.emit("start");
			}

		}
		catch (ex) {
			pluginContext.emit("start");
		}
	});

	function PostProcessAllPlugins() {
		var error = null;

		function walk(basePath, dir, done) {
			const baseStripLength = basePath.length + 1;
			var results = [];
			fs.readdir(dir, function(err, list) {
				if (err) return done(err);
				var pending = list.length;
				if (!pending) return done(null, results);
				list.forEach(function(file) {
					file = path.resolve(dir, file);
					fs.stat(file, function(err, stat) {
						if (err) throw err;
						if (stat && stat.isDirectory()) {
							walk(basePath, file, function(err, res) {
								if (err) throw err;
								results = results.concat(res);
								if (!--pending) done(null, results);
							});
						}
						else {
							var filePathToAdd = file.substring(baseStripLength);
							filePathToAdd && results.push(filePathToAdd);
							if (!--pending) done(null, results);
						}
					});
				});
			});
		}
		if (pluginmanager.options.target.os === "Android") {
			const reSmali = /^smali.*\x2Esmali$/g;
			const playerPath = path.dirname(pluginmanager.options.applicationManifestFilePath);
			var smalies = {};
			walk(playerPath, playerPath, function(err, results) {
				if (err) throw err;
				results.forEach(function(file, index, array) {
					if (error) {
						return;
					}
					if (reSmali.test(file)) { //it is a smali file
						const position = file.indexOf(path.sep);
						const smaliFolderName = file.substr(0, position);
						if (!smalies[smaliFolderName]) {
							smalies[smaliFolderName] = [];
						}
						const restOfPath = file.substr(position + 1);

						const listOfSmaliFolders = Object.keys(smalies);
						for (var i = 0; i < listOfSmaliFolders.length; i++) {
							var currentSmaliFolderName = listOfSmaliFolders[i];
							if (currentSmaliFolderName === smaliFolderName) {
								continue;
							}
							var otherSmaliFolder = smalies[currentSmaliFolderName];
							if (otherSmaliFolder.indexOf(restOfPath) > -1) {
								var pluginName1 = "Player";
								var pluginName2 = "Player";
								for (var pluginName in contextStore) {
									var pluginContext = contextStore[pluginName];
									for (var smaliKeyName in pluginContext.smali) {
										var smaliValue = pluginContext.smali[smaliKeyName];
										if (smaliValue === smaliFolderName)
											pluginName1 = pluginContext.name;
										if (smaliValue === currentSmaliFolderName)
											pluginName2 = pluginContext.name;
									}
								}
								error = "'" + restOfPath + "' exists both in '" + smaliFolderName + "(" + pluginName1 + ")' and '" + currentSmaliFolderName + "(" + pluginName2 + ")'";
								break;
							}
						}
						if (!error) {
							smalies[smaliFolderName].push(restOfPath);
						}
					}
				});
			});
		}
		return error;
	}

	function signalDone(pluginContext) {
		const result = {
			success: !Boolean(pluginContext.error),
			error: pluginContext.error,
		};
		pluginExecutionResults[pluginContext.name] = result;
		if (!result.success) {
			pluginExecutionResults.hasError = true;
		}
		pluginReadyCount++;
		if (pluginReadyCount === pluginmanager.plugins.length) {
			const error = PostProcessAllPlugins();
			if (error) {
				pluginExecutionResults.hasError = true;
				pluginExecutionResults.SmaliConflict = error;
			}
			if (typeof allDone === "function") {
				allDone(pluginExecutionResults);
			}
		}
	}
}

function log(content) {
	if (pluginmanager.options.verbose) {
		utility.writeJsonMsgToStdout(content);
	}
}

function checkZipForEnvironment(platform, zippath, callback) {
	var zip = new AdmZip(zippath);
	var packageJsonTxt;
	var packageJson;
	const PLATFORM = {
		ios: "iOS",
		android: "Android"
	};
	try {
		packageJsonTxt = zip.readAsText("package.json");
		packageJson = jsonlint.parse(packageJsonTxt);
	}
	catch (e) {
		if (!packageJsonTxt) { //package.json not exists.
			utility.killProcess(error.getObject("plugin.packageJSON.notExists", {
				err: {
					os: PLATFORM[platform]
				},
				msg: {
					pluginPath: zippath
				},
				helpForUser: {
					pluginPath: zippath
				}
			}));
		}
		utility.killProcess(error.getObject("plugin.packageJSON.parse", {
			err: {
				os: PLATFORM[platform]
			},
			msg: {
				msg: e
			},
			helpForUser: {
				packageJSONPath: path.join(zippath, "package.json")
			}
		}));
	}
	if ((packageJson.os && packageJson.os.toLowerCase() === platform) || (packageJson.OS && packageJson.OS.toLowerCase() === platform)) {
		callback(true);
	}
	else {
		utility.killProcess(error.getObject("plugin.packageJSON.invalid", {
			err: {
				os: PLATFORM[platform]
			},
			msg: {
				packageJSONPath: path.join(zippath, "package.json"),
				msg: "'os' or 'OS' property is missing or invalid -> " + (packageJson.os || packageJson.OS)
			},
			helpForUser: {
				packageJSONPath: path.join(zippath, "package.json")
			}
		}));
		callback(false);
	}
}

function changeBundle(extractPath) {
	var read = utility.readDirSyncRecursively(extractPath);
	var files = [];
	var bundle = globalData.get('androidConfig.androidConfig.input.license.bundle');
	var bundleDash = bundle.replace(/\./g, "\/");

	read.forEach(function(item) {
		if (fs.statSync(path.join(extractPath, item)).isFile() && path.basename(item).toLowerCase().indexOf("smali") >= 0) {
			files.push(path.join(extractPath, item));
		}
	});

	files.forEach(function(file) {
		var fileContent = fs.readFileSync(file).toString();
		var fileContentNew = fileContent.replace(/io\.smartface\.SmartfaceDemo/g, bundle);
		fileContentNew = fileContentNew.replace(/io\/smartface\/SmartfaceDemo/g, bundleDash);
		fs.writeFileSync(file, fileContentNew);
	});
}
