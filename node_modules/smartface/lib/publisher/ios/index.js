const path = require("path");
const async = require("async");
const utility = require('../../utility');
const globalData = require('../../globalData');
const IosPublisher = require('./iosPublisher');
const logger = require('../../log/log4j').getLogger('Publisher'); // logger.
const cloudBuild = require("../../cloudBuild");
const doSendToServer = require("../sendtoserver");

//console.inspect(globalData.get("iosConfig"));
function iOSPublish(publishConfig, projectjSon, callBack) {
  const iosPublisher = new IosPublisher();

  var willBeUploadedFiles = publishConfig.willBeUploadedFiles;
  const isCloudBuildiOS = publishConfig.isCloudBuildiOS;
  var releaseChannels = publishConfig.releaseChannels;
  const IDE_TOKEN = publishConfig.IDE_TOKEN;
  const TMP_DIR = publishConfig.TMP_DIR;

  logger.debug("iOS-publish is started.");
  utility.writeJsonMsgToStdout("Indexing workspace...");
  logger.debug("\tTemplateprojectJSON is prepared.");
  utility.writeJsonMsgToStdout("Preparing Xcode Project Files...");
  iosPublisher
    .startPublish(isCloudBuildiOS)
    .then(function(res) {
      utility.writeJsonMsgToStdout("Preparing License File...");
      iosPublisher.createLicenseXml();
      utility.writeJsonMsgToStdout("Preparing Config File...");
      iosPublisher.createConfig2Bin();
      utility.writeJsonMsgToStdout("Copying Binary Files...");
      iosPublisher.copyOthersToSmfRes();
      utility.writeJsonMsgToStdout("Copying Resource Files...");
      iosPublisher.copyResourcesToSmfRes();
      iosPublisher.moveImageSets();
      utility.writeJsonMsgToStdout("Updating info.plist...");
      return iosPublisher.updateInfoPlist();
    }, callBack).then(function(res) {
      iosPublisher.addFileToPbxProj("project.json");
      return iosPublisher.updatePbxProj();
    }, callBack).then(function(res) {
      iosPublisher.addPlugins(function() {
        utility.writeJsonMsgToStdout("Finalizing project...");
        finalize();
      });
    }, callBack);

  // publish for channels.
  function handleChannels(calbackHandleChannels) {
    var i = 0,
      channel;

    if (publishConfig.saveBinary)
      return calbackHandleChannels(null);
      utility.mkdirpSync(path.dirname(globalData.get('iosConfig.iosConfig.output.outputZip')));
      async.whilst(
          function test() {
            return i++ < releaseChannels.length;
          },
          function(_cb) {
        channel = releaseChannels[i - 1];
        projectjSon.config.rau.currentReleaseChannel = channel;
        //console.inspect(projectjSon);
        iosPublisher.writeCombinedProjectJSON(projectjSon);
        utility.writeJsonMsgToStdout("Updating project.json...");
        iosPublisher
          .finishPublishOneRelease(channel)
          .then(function(outputZip) {
            willBeUploadedFiles.push(outputZip);
            if (channel) {
              utility.writeJsonMsgToStdout("Completing channel: " + channel);
            }
            utility.writeJsonToStdout({
              msg: "Xcode project creation complete.",
              responseDone: true,
              finishedTask: {
                os: "iOS",
                releaseChannel: channel,
                cpu: null,
                downloadFilePath: outputZip
              },
              allDone: false
            });
            setTimeout(_cb.bind(null, null), 2500);
          }, function(err) {
            _cb(err);
          });
      }, (err, res) => {
        if (err) {
          return calbackHandleChannels(err);
        }
        calbackHandleChannels(null, res);
      });
  }
  // do cloudBuild.
  function doCloudBuild(calbackDoCloudBuild) {
    if (isCloudBuildiOS) {
      iosPublisher.writeCombinedProjectJSON(projectjSon);
      iosPublisher
        .createContentZipForCloudBuild(path.join(TMP_DIR, "cloudBuild.zip"))
        .then(iOSContentZipPath => {
          var cldCfg = prePareCloudBuildConfig(iOSContentZipPath);
          return cloudBuild(IDE_TOKEN, "iOS", cldCfg);
        }, calbackDoCloudBuild).then(outputs => {
          if(publishConfig.saveBinary)
            utility.writeJsonToStdout({
              finishedTask:{
                os:"iOS",
                releaseChannel: publishConfig.releaseChannels[0],
                downloadFilePath: "NONE"
              }
            });
          if (publishConfig.sendToTest || publishConfig.sendToStore) {
            publishConfig.ipaOutputs = outputs;
          }
          else {
            publishConfig.willBeUploadedFiles = willBeUploadedFiles.concat(outputs);
          }
          calbackDoCloudBuild(null);
        }, err => {
          calbackDoCloudBuild(err.err ? err : {
            err: "Cloud Build iOS Error",
            msg: err.stack ? err.stack : err.toString()
          });
        });
    }
    else {
      calbackDoCloudBuild(null);
    }

    function prePareCloudBuildConfig(contentZipPath) {
      var licenseType = globalData.get('iosConfig.iosConfig.input.license.type');
      var cfg = {
        "tripleDesKey": licenseType !== "Demo" ? globalData.get("iosConfig.tripleDes.keyBase") : null,
        "appName": globalData.get("iosConfig.iosConfig.input.infoPlist.edit.productName"),
        "cliVersion": utility.getCliVersion(),
        "provisioningID": publishConfig.cloudBuild.provisioningProfileID,
        "channels": releaseChannels
      };

      if (publishConfig.saveBinary) {
        var iconPath = path.join(globalData.get('iosConfig.iosConfig.input.images'), "AppIcon.appiconset",'Icon.png');
        utility.throwsNoSuchFile(iconPath, null, 'Icon.png must be there');
        cfg.storeSubmission = {
          name: projectjSon.info.name,
          version: projectjSon.info.version,
          bundleId: projectjSon.build.output.ios.bundleIdentifier,
          imageBase64: utility.convertToBase64(iconPath)
        };
      }
      var cldConfig = {
        contentZip: contentZipPath,
        config: cfg,
        outputPath: globalData.get('iosConfig.iosConfig.output.outputZip'),
        outputExt: "ipa",
        playerPath: globalData.get('iosConfig.iosConfig.input.playerZip'),
        writer: writerForOutput,
        saveBinary: publishConfig.saveBinary
      };
      return cldConfig;
    }

    function writerForOutput(ipaPath, channel) {
      utility.writeJsonToStdout({
        msg: "Binary (IPA) creation complete.",
        responseDone: true,
        finishedTask: {
          os: "iOS",
          releaseChannel: channel,
          cpu: null,
          downloadFilePath: ipaPath
        },
        allDone: false
      });
    }
  }

  function finalize() {
    async.parallel([
      handleChannels,
      doCloudBuild
    ], (err, results) => {
      if (err) {
        return callBack(err);
      }
      if (publishConfig.sendToTest || publishConfig.sendToStore) {
        sendOutputToDist(publishConfig, callBack);
      }
      else {
        callBack(null, results);
      }
    });
  }
}

function sendOutputToDist(publishConfig, _callBack) {
  var type = publishConfig.sendToTest ? "test" : "store";
  return doSendToServer({
    type: type,
    iOS: publishConfig.iOS,
    iosPID: type === "test" ? publishConfig.iosTPID : publishConfig.iosEPID,
    ipas: publishConfig.ipaOutputs,
  }, publishConfig.IDE_TOKEN, _callBack);
}

module.exports = iOSPublish;
