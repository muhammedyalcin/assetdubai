/**
 * @file IOS publisher.
 * @version 1.0.0
 * @requires module:fs
 * @requires module:child_process
 * @requires module:underscore
 * @requires module:jszip
 */
const fs = require('fs');
const path = require('path');

const _ = require('underscore');
var plist = require('plist');

const PlayerZipService = require('./iosPlayerZipService.js');
const Zipper = require('../../zipper');
const utility = require('../../utility');
const updateMerge = require("../../mergeObjects");
const IOSConfig = require('../../config/ios');
const copy = require('../../copy');
const Configuration = require('../../configuration').Configuration;
const Des3 = require('../../3des');
const IOSStringBuilder = require('./pbxbuild');
const StringBuilder = require('./iosPbxStringBuilder');
const plistCreator = require('./plist');
const logger = require('../../log/log4j').getLogger('IosPublisher'); // logger.
const error = require('../../error');
const pluginManager = require('../pluginmanager');
const fonts = require('../../fonts');
const globalData = require('../../globalData');
const configureBuildSettings = require("./configureBuildSettings");

const strBuilder = new StringBuilder();
const REPLACE_PRODUCT_NAME_FIRST = new RegExp(escapeRegExp('PRODUCT_NAME = "$(TARGET_NAME)"'), 'gm');
const REPLACE_PRODUCT_NAME_SECOND = new RegExp(escapeRegExp('PRODUCT_NAME = "Smartface-Demo"'), 'gm');
const REPLACE_PRODUCT_NAME_THIRD = new RegExp(escapeRegExp('productName = "Smartface-Demo"'), 'gm');
const REPLACE_PRODUCT_NAME_FOURTH = new RegExp(escapeRegExp('name = "Smartface-Demo"'), 'gm');
const REPLACE_GCC_GENERATE_DEBUGGING_SYMBOLS = new RegExp(escapeRegExp("GCC_GENERATE_DEBUGGING_SYMBOLS = NO;"), "gm");

const DEST_FOLDER = 'Smartface/smfres';
const IMAGE_DEST_FOLDER = 'Smartface/Assets.xcassets';
const SEARCH_FIRST = '/* Begin PBXBuildFile section */';
const SEARCH_SECOND = '/* Begin PBXFileReference section */';
const SEARCH_THIRD = '/* Begin PBXGroup section */'; //children
const SEARCH_THIRD_B = 'children = (';
const SEARCH_FOURTH = '/* Begin PBXResourcesBuildPhase section */'; //files
const SEARCH_FOURTH_B = 'files = (';
const SEARCH_FIFTH = '/* Begin PBXShellScriptBuildPhase section */'; //files
const SEARCH_FIFTH_B = 'shellScript';
const SEARCH_NATIVETARGET_BUILDSECTION = "/* Begin PBXNativeTarget section */";
const SEARCH_NATIVETARGET_BUILDSECTION_B = "buildPhases = (";
const SEARCH_NATIVETARGET_BUILDSECTION_C = "/* Embed Frameworks */,";
const SEARCH_SHELLSCRIPT_BUILDPHASE = "/* Begin PBXShellScriptBuildPhase section */";
const SEARCH_SHELLSCRIPT_BUILDPHASE_B = "};";
const DOUBLE_TAB_INDENTATION = '\r\n\t\t';
const FOURTH_TAB_INDENTATION = '\r\n\t\t\t\t';
const SHELL_SCRIPT_TEXT = ' = "# unzip plugin frameworks to their related folders\\nPLUGIN_ROOT=${SOURCE_ROOT}/Smartface/Plugins/';

function GET_SHELL_PLUGIN(pluginZip) {
	return '\\n\\nunzip -o \\"${PLUGIN_ROOT}/' + pluginZip +
		'\\" -d \\"${PLUGIN_ROOT}/\\"\\nrm -rf \\"$PLUGIN_ROOT/' + pluginZip + '\\"';
}

function escapeRegExp(string) {
	return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}
/**
 * IosPublisher class.
 * @constructor IosPublisher
 *
 */
function IosPublisher() {
	const des3 = new Des3();
	const configuration = new Configuration();
	const zipper = new Zipper();
	const contentZip = new Zipper();
	var KEY = '';
	var licenseType = 'Demo';

	const TEMP_FM = globalData.get("moduleGlobals.tempfilemanager");
	var TEMP_FOLDER = '.tmp/';

	var files = [];
	var err = {
		msg: ''
	};
	var _cloudBuild = false;
	/**
	 * start publishing --> set and control config object.
	 * @method startPublish
	 * @param {	Config}
	 * @return {Promise} promise object.
	config config object.*@memberof IosPublisher
	 */
	this.startPublish = function(cloudBuild) {
		_cloudBuild = !!cloudBuild;
		utility.controlConfig(globalData.get('iosConfig'));
		control_Config2_IosConfig();
		logger.debug('start publishing.');
		const playerZip = globalData.get('iosConfig.iosConfig.input.playerZip');
		const outputZip = globalData.get('iosConfig.iosConfig.output.outputZip');
		utility.mkdirpSync(path.dirname(outputZip));

		TEMP_FOLDER = globalData.get("moduleGlobals.tmpdir");
		KEY = globalData.get('iosConfig.tripleDes.key');
		licenseType = globalData.get('iosConfig.iosConfig.input.license.type');

		return new Promise(function(resolve, reject) {
			zipper.readZip(playerZip);
			globalData.set('iosPlayerZip', zipper);
			resolve(null);
		});
	};
	/**
	 * resources files copy operation --> by config.iosConfig object
	 * if license type not Demo, Script files encrypts.
	 * @method copyResourcesToSmfRes
	 * @memberof IosPublisher
	 */
	this.copyResourcesToSmfRes = function() {
		logger.debug('start copyResourcesToSmfRes() ');
		const KEY = globalData.get('iosConfig.tripleDes.key');
		if (licenseType === '' || KEY === '') {
			err.msg = ' Check config object invalid value.';
			logger.error('Checks License Type: ' + licenseType + ' TripleDesKey : ' + KEY);
			throw err;
		}
		const iosPlayerZip = globalData.get('iosPlayerZip');
		const scripts = globalData.get('iosConfig.iosConfig.input.scripts');
		var assets = globalData.get('iosConfig.iosConfig.input.assets');
		var scriptsFolderPath = path.relative(globalData.get('args.projectRoot'), scripts);
		var scriptFiles = utility.searchFilesInDirRec(scripts);
		var data;

		_.each(scriptFiles, function(item) {
			var relativePathDir = path.dirname(path.relative(scripts, item));
			var filename = path.basename(item);
			//TODO scripts folder For collecting.
			var tempFilePath = path.join(TEMP_FOLDER, "scripts", relativePathDir, path.basename(filename));
			if (TEMP_FM.isIn(tempFilePath) === null) { // script file doens't exists in tempfolder
				utility.mkdirpSync(path.dirname(tempFilePath));
				if ([".js", ".json"].indexOf(path.extname(item)) !== -1) {
					if (licenseType !== 'Demo') { // license type isn't demo, encrpt and copy tempfolder.
						des3.encryptFileWith3DES_ECB(item, KEY, tempFilePath);
						TEMP_FM.addFileWithoutCopySync(tempFilePath);
					}
					else { //script adds tempfolder and player folder
						TEMP_FM.addFileSync(tempFilePath, item);
					}
				}
				else {
					TEMP_FM.addFileSync(tempFilePath, item);
				}
			}
			item = detectFileExtension(item);

			// script avaiable in tempfolder adds from temp folder to player folder if not exist in player folder. 
			data = fs.readFileSync(tempFilePath);
			iosPlayerZip.file(path.join(DEST_FOLDER, scriptsFolderPath, path.relative(scripts, item)), data);
			addFileOrFolderToContentZip(path.join(DEST_FOLDER, scriptsFolderPath, path.relative(scripts, item)), data);
		});

		const tempAssetsDir = path.join(TEMP_FOLDER, "assets");
		const cacertPemPath = path.join(tempAssetsDir, 'cacert.pem');

		if (TEMP_FM.isIn(cacertPemPath) === null) { // if files aldreay is written in tempfolder ? 
			copy.setFileMager(TEMP_FM); // change filemanager .
			copy.copyDirectory(assets, tempAssetsDir);
			var assetsFiles = utility.searchFilesInDirRec(tempAssetsDir);
			if (assetsFiles.indexOf(cacertPemPath) > -1 && licenseType !== 'Demo') {
				des3.encryptFileWith3DES_ECB(cacertPemPath, KEY, cacertPemPath);
			}
		}
		iosPlayerZip.addFolderToFolder(path.join(DEST_FOLDER, "assets"), assets);
		addFileOrFolderToContentZip(path.join(DEST_FOLDER, "assets"), assets, true, true);
		createSmartfaceVersionFile();
		logger.debug('done copyResourcesToSmfRes() ');

		function detectFileExtension(file) {
			var res = file;
			if (path.extname(file) === '.js')
				if (licenseType !== 'Demo') {
					res = utility.renameFilesType(file, 'jsxe');
				}
			else {
				res = utility.renameFilesType(file, 'jsx');
			}
			return res;
		}
	};

	this.moveImageSets = function() {
		logger.debug('start moveImageSets() ');
		const iosPlayerZip = globalData.get('iosPlayerZip');
		const images = globalData.get('iosConfig.iosConfig.input.images');
		iosPlayerZip.addFolderToFolder(IMAGE_DEST_FOLDER, images);
		addFileOrFolderToContentZip(IMAGE_DEST_FOLDER, images, true, true);
		logger.debug('done moveImageSets() ');
	};

	function createSmartfaceVersionFile() {
		const iosPlayerZip = globalData.get('iosPlayerZip');
		const fileVersion = globalData.get('iosConfig.config2.fileVersion');
		const sasVersion = globalData.get('iosConfig.iosConfig.sasVersion');
		const smfVerPath = path.join(DEST_FOLDER, 'SmartfaceVersion.txt');
		var data = '{"runtimeVersion":"' + fileVersion + '", "SASVersion":"' + sasVersion + '"}';
		iosPlayerZip.file(smfVerPath, data);
		files.push('SmartfaceVersion.txt');
		addFileOrFolderToContentZip(smfVerPath, data);
	}

	/**
	 * 'defaults.xml', 'splash.smf', 'data.smf' files copy.
	 * @method copyOthersToSmfRes
	 * @memberof IosPublisher
	 */
	//  may be HARD CODED.
	this.copyOthersToSmfRes = function() {};
	/**
	 * Create config2.bin -> by config.config2 object.
	 * @method createConfig2Bin
	 * @memberof IosPublisher
	 */
	this.createConfig2Bin = function() {
		logger.debug('start createConfig2Bin() ');
		const config2Path = path.join(TEMP_FOLDER, "config2.bin");
		if (KEY === '') {
			err.msg = ' Invalid Key !. \n You should be sure call method of startPublish() !';
			logger.error(' Invalid Key : ' + KEY + '  You should be sure call method of startPublish() ! ');
			throw err;
		}
		const iosPlayerZip = globalData.get('iosPlayerZip');
		const config2 = globalData.get('iosConfig.config2');
		if (!TEMP_FM.isIn(config2Path)) {
			fs.writeFileSync( // create config2.bin
				config2Path,
				des3.encryptStrWith3DES_ECB(
					configuration.createConfigXmlString(config2), KEY)
			);
			TEMP_FM.addFileWithoutCopySync(config2Path);
		}
		const smfConfig2 = path.join(DEST_FOLDER, 'config2.bin');
		const data = fs.readFileSync(config2Path);

		iosPlayerZip.file(smfConfig2, data);
		addFileOrFolderToContentZip(smfConfig2, data);

		files.push('config2.bin');
		logger.debug('done createConfig2Bin() ');
	};
	/**
	 * Create license.xml -> by config.iosConfig.license object.
	 * if license type not Demo, license.xml encrypts.
	 * @method createLicenseXml
	 * @memberof IosPublisher
	 */
	this.createLicenseXml = function() {
		logger.debug('start createLicenseXml() ');
		const license = globalData.get('iosConfig.iosConfig.input.license');
		const xmlStr = license.data;
		logger.debug('\tLicense Type : ' + license.type);
		const iosPlayerZip = globalData.get('iosPlayerZip');

		const smfLicense = path.join(DEST_FOLDER, 'license.xml');

		iosPlayerZip.file(smfLicense, xmlStr);
		addFileOrFolderToContentZip(smfLicense, xmlStr);

		logger.debug('done createLicenseXml() ');
		files.push('license.xml');
	};
	// pbx object creates for updatePbxProj. 
	function createPbxObjects() {
		return _.map(files, function(item) {
			return new IOSStringBuilder(item);
		});
	}
	// create pbx strings from pbx objects for type .
	function createPbxStringArray(iosStringBuilder, type) {
		return _.map(iosStringBuilder, function(item) {
			return item.toIOSString(type);
		});
	}
	// for plugins shell command.
	function createPluginsShell() {
		const plugins = _.map(globalData.get('iosConfig.iosConfig.input.plugins'), function(item) {
			return item.name + '.zip';
		});
		return _.map(plugins, function(item) {
			return GET_SHELL_PLUGIN(item);
		}).join('') + '";';
	}
	/**
	 * add plugins. --> copy zip file and run it's js file.
	 * @method addPlugins
	 * @memberof IosPublisher
	 */
	function addPlugins(callBack) {
		logger.debug('start addPlugins() ');
		const tmpdir = globalData.get('moduleGlobals.tmpdir');
		const tempFolder = tmpdir + '/pluginsTempFolder';
		const plugins = globalData.get('iosConfig.iosConfig.input.plugins');
		const fileService = new PlayerZipService(zipper, contentZip, _cloudBuild);

		if (plugins.length !== 0) {
			logger.debug('start addPlugins() ');
			utility.mkdirpSync(tempFolder); // create temp folder.
			pluginManagerInit();
			_addPlugins(beginProcess);
			//beginProcess();
		}
		else {
			logger.debug('none Plugins will be added.');
			callBack();
		}

		function pluginManagerInit() {
			const pluginManagerOptions = {
				target: {
					os: 'iOS',
					cpu: ['ARM', 'ARM64']
				},
				temp: tempFolder,
				pfs: fileService,
				verbose: true
			};
			pluginManager.init(pluginManagerOptions);
		}

		function _addPlugins(callBack) {
			var pluginCount = 0;
			_.each(plugins, function(item) {
				pluginManager.addPlugin(item, "iOS", function() {
					logger.debug('\t adding Plugin: ' + item.name);
					if (++pluginCount === plugins.length)
						callBack();
				});
			});
		}

		function beginProcess() {
			pluginManager.beginProcess(function allPluginsDone(results) {
				logger.debug('\t pluginManagerError: ' + results.hasError);
				_.each(plugins, function(item) {
					logger.debug('\t Plugin: ' + item.name + ' success: ' + results[item.name].success);
				});
				logger.debug('done addPlugins() ');
				callBack();
			});
		}
	}
	/**
	 * update pbxproj file.
	 * @method updatePbxProj
	 * @memberof IosPublisher
	 * @return {Promise} promise object.
	 * @private
	 */
	function updatePbxProj() {
		const tempPbxPath = path.join(TEMP_FOLDER, "project.pbxproj");
		const iosPlayerZip = globalData.get('iosPlayerZip');
		var pbx_data;

		return new Promise(function(resolve, reject) {
			logger.debug('start updatePbxProj() ');

			if (TEMP_FM.isIn(tempPbxPath) == null) {
				pbx_data = createPbxObjects();
				var projTextInitial = iosPlayerZip.file('Smartface.xcodeproj/project.pbxproj');
				strBuilder.startBuild(projTextInitial);
				logger.debug('\tadding buildFileSection');
				add('buildFileSection', SEARCH_FIRST, DOUBLE_TAB_INDENTATION);

				logger.debug('\tadding fileReferenceSection');
				jump();
				add('fileReferenceSection', SEARCH_SECOND, DOUBLE_TAB_INDENTATION);
				jump();
				strBuilder.addFrom('', SEARCH_THIRD, {
					indentation: DOUBLE_TAB_INDENTATION
				});
				logger.debug('\tadding groupSection');
				add('groupSection', SEARCH_THIRD_B, FOURTH_TAB_INDENTATION);
				jump();
				strBuilder.addFrom('', SEARCH_FOURTH, {
					indentation: DOUBLE_TAB_INDENTATION
				});
				strBuilder.goJumpLines(1);
				strBuilder.goJumpTabs(2);
				logger.debug('\tadding resBuildPhaseSection');
				add('resBuildPhaseSection', SEARCH_FOURTH_B, FOURTH_TAB_INDENTATION);
				jump();
				strBuilder.addFrom('', SEARCH_FIFTH);

				strBuilder.addFrom(SHELL_SCRIPT_TEXT + createPluginsShell(), SEARCH_FIFTH_B);
				jump();
				const productName = globalData.get('iosConfig.iosConfig.input.infoPlist.edit.productName');
				logger.debug('\tadding name , productName PRODUCT_NAME : ' + productName);
				var projText = strBuilder.finishBuild()
					.replace(REPLACE_PRODUCT_NAME_FIRST, 'PRODUCT_NAME = "' + productName + '"')
					.replace(REPLACE_PRODUCT_NAME_SECOND, 'PRODUCT_NAME = "' + productName + '"')
					.replace(REPLACE_PRODUCT_NAME_THIRD, 'productName = "' + productName + '"')
					.replace(REPLACE_PRODUCT_NAME_FOURTH, 'name = "' + productName + '"');
				globalData.get('iosConfig.iosConfig.input.plugins').forEach(item => {
					if (item.fabric) {
						projText = setBuildScriptForFabric(projText, item.fabric)
							.replace(REPLACE_GCC_GENERATE_DEBUGGING_SYMBOLS, "GCC_GENERATE_DEBUGGING_SYMBOLS = YES;");
					}
				});
				projText = configureBuildSettings(
					globalData.get("processedArgs.config_json.build.input.ios.buildSettings") || {},
					projText);
				//fs.writeFileSync('test-files/output/xcode/project_cli_published.pbxproj', projText, 'utf8'); // for debug test.
				//write temp
				fs.writeFileSync(tempPbxPath, projText);
				TEMP_FM.addFileWithoutCopySync(tempPbxPath);
				finalize();
			}
			else {
				finalize();
			}

			function finalize() {
				fs.readFile(tempPbxPath, (err, data) => {
					if (err) {
						return reject(err);
					}
					const smfPbxProj = path.join('Smartface.xcodeproj', 'project.pbxproj');

					iosPlayerZip.file(smfPbxProj, data);
					addFileOrFolderToContentZip(smfPbxProj, data);

					logger.debug('done updatePbxProj() ');
					resolve(null);
				});
			}


		});

		function add(section, search, tab) {
			strBuilder.addFrom(createPbxStringArray(pbx_data, section), search, {
				indentation: tab
			});
		}

		function jump() {
			strBuilder.goJumpLines(1);
			strBuilder.goJumpTabs(2);
			strBuilder.addStrToString('\n\t\t');
		}


	}
	/**
	 * update InfoPlist file. --> by config.iosConfig.infoPlist object.
	 * @method updateInfoPlist
	 * @memberof IosPublisher
	 * @return {Promise} promise object.
	 */
	this.updateInfoPlist = function() {
		logger.debug('start updateInfoPlist() ');
		const iosPlayerZip = globalData.get('iosPlayerZip');
		const infoPlist = globalData.get('iosConfig.iosConfig.input.infoPlist.edit');
		var plistContent = globalData.get('iosConfig.iosConfig.input.infoPlist.data');
		const infoPlistPath = "Smartface/Smartface-Info.plist";
		return new Promise(function(resolve, reject) {

			if (plistContent === null) { // use default info.plist
				plistContent = iosPlayerZip.file(infoPlistPath);
				applyAndWriteChanges();
			}
			else {
				applyAndWriteChanges();
			}

			function applyAndWriteChanges() {
				var defaultPlist = plist.parse(plistContent);
				defaultPlist['CFBundleDisplayName'] = infoPlist.appName;
				defaultPlist['CFBundleExecutable'] = infoPlist.productName;
				defaultPlist['CFBundleIdentifier'] = infoPlist.packageName;
				defaultPlist['CFBundleName'] = infoPlist.appNameShort;
				defaultPlist['CFBundleShortVersionString'] = infoPlist.appVersion;

				const orientation = globalData.get('iosConfig.config2.orientation');
				const urlIdentifier = globalData.get('iosConfig.iosConfig.input.urlIdentifier');
				const urlSchemes = globalData.get('iosConfig.iosConfig.input.urlSchemes');
				const fontParams = collectFontParams();
				const font_files = fonts.handleFonts(fontParams);
				const uiAppFonts = plistCreator.createUiAppFonts(font_files);
				const uiOrientation = plistCreator.createOrientation(orientation);
				const bundleUrlTypes = plistCreator.createURLIdentScheme(urlIdentifier, urlSchemes);

				font_files.forEach(function(font) {
					files.push(font);
				});
				var extraInfo = "<plist><dict>" + uiAppFonts + uiOrientation + bundleUrlTypes + "</dict></plist>";
				extraInfo = plist.parse(extraInfo);
				updateMerge(defaultPlist, extraInfo);

				const data = plist.build(defaultPlist);
				//fs.writeFileSync("/home/ubuntu/workspace/workspace/output/infoedited.plist",data, "utf8");

				iosPlayerZip.file(infoPlistPath, data);
				addFileOrFolderToContentZip(infoPlistPath, data);

				logger.debug('done updateInfoPlist() ');
				resolve(null);
			}
		});
	};
	/**
	 * finish publishing. update pbxProj file.and create new zip file.
	 * @method finishPublish
	 * @memberof IosPublisher
	 */
	this.finishPublish = function(callBack) {
		//updatePbxProj();
		const iosPlayerZip = globalData.get('iosPlayerZip');
		const outputZip = globalData.get('iosConfig.iosConfig.output.outputZip');
		addPlugins(function() {
			iosPlayerZip.createZip(outputZip).then(function(res) {
				utility.throwsNoSuchFile(outputZip, 'zip');
				logger.debug('outputZip : ' + outputZip);
				logger.debug('done publishing');
				callBack(null);
			}, function(err) {
				callBack(err);
			});
		});
	};

	function collectFontParams() {
		const deviceType = 'iOS';
		const projectRoot = globalData.get('args.projectRoot');
		const platform = globalData.get('args.platform');
		const appStudioProject = (platform === 'c9') ? false : true;
		return fonts.createFontParams(projectRoot, deviceType, DEST_FOLDER, appStudioProject, {
			"smartfacePlayerFolder": zipper,
			"contentZip": contentZip,
			"isCloudBuild": _cloudBuild
		});
	}

	this.addPlugins = addPlugins;

	this.updatePbxProj = updatePbxProj;

	this.addFileToPbxProj = function(name) {
		files.push(name);
	};
	/**
	 * finish publishing for one channel. update create new zip file.
	 * @method finishPublishOneRelease
	 * @return  {Promise} promise with ouputZipName..
	 * @memberof IosPublisher
	 */
	this.finishPublishOneRelease = function(channel) {
		const outputZip = globalData.get('iosConfig.iosConfig.output.outputZip');
		const iosPlayerZip = globalData.get('iosPlayerZip');
		var name = utility.outputPathByChannel(outputZip, channel);

		return new Promise(function(resolve, reject) {
			iosPlayerZip.createZip(name).then(function(res) {
				utility.throwsNoSuchFile(name, 'zip');
				resolve(name);
			}, function(err) {
				reject(err);
			});
		});
	};

	this.writeCombinedProjectJSON = function(prJSON) {
		var bufJSON = new Buffer(JSON.stringify(prJSON), "utf8");
		const iosPlayerZip = globalData.get('iosPlayerZip');
		if (licenseType !== 'Demo') { // encrypt 
			bufJSON = des3.encryptStrWith3DES_ECB(bufJSON, KEY);
		}
		const smfProjectJson = path.join(DEST_FOLDER, "project.json");

		iosPlayerZip.file(smfProjectJson, bufJSON);
		addFileOrFolderToContentZip(smfProjectJson, bufJSON);

	};
	// preapre contentZip for cloud build.
	function addFileOrFolderToContentZip(path, data, isFolder, isTree) {
		if (_cloudBuild) {
			if (isFolder) {
				if (isTree)
					contentZip.addFolderToFolder(path, data);
				else
					contentZip.addFilesFromFolderToFolder(path, data /* path2 for folder */ );
			}
			else {
				contentZip.file(path, data);
			}
		}
	}

	this.createContentZipForCloudBuild = function(zipPath) {
		return new Promise(function(resolve, reject) {
			contentZip.createZip(zipPath).then(function(res) {
				utility.throwsNoSuchFile(zipPath, 'zip');
				resolve(zipPath);
			}, function(err) {
				reject(err);
			});

		});
	};

}

function setBuildScriptForFabric(pbxproj, fabric) {
	const strBuilder = new StringBuilder();
	var groupSection = new IOSStringBuilder("ShellScritp");
	strBuilder.startBuild(pbxproj);
	strBuilder.addFrom("", SEARCH_NATIVETARGET_BUILDSECTION);
	strBuilder.addFrom("", SEARCH_NATIVETARGET_BUILDSECTION_B);
	strBuilder.addFrom([groupSection.toIOSString("groupSection")],
		SEARCH_NATIVETARGET_BUILDSECTION_C, FOURTH_TAB_INDENTATION);
	strBuilder.addFrom("", SEARCH_SHELLSCRIPT_BUILDPHASE);
	strBuilder.addFrom(`
		${groupSection.toIOSString("groupSection", true)} = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "chmod u+x \\"\${PROJECT_DIR}/Smartface/Plugins/Fabric/Fabric.framework/uploadDSYM\\"\\n chmod u+x \\"\${PROJECT_DIR}/Smartface/Plugins/Fabric/Fabric.framework/run\\"\\n\\"\${PROJECT_DIR}/Smartface/Plugins/Fabric/Fabric.framework/run\\" ${fabric.API_KEY} ${fabric.BUILD_SECRET}";
		};
	`, SEARCH_SHELLSCRIPT_BUILDPHASE_B);
	return strBuilder.finishBuild();
}

// control iosConfig objects.
function controliOSConfig() {
	const iosConfig = globalData.get('iosConfig.iosConfig');
	var errObj;
	if (iosConfig === null) {
		errObj = error.getObject('undefinedNull', {
			err: {
				OBJ: 'null'
			},
			msg: {
				obj: 'config.iosConfig',
				OBJ: 'null'
			}
		});
	}
	else if (!(iosConfig instanceof IOSConfig)) {
		errObj = error.getObject('object', {
			err: {
				OBJ: 'IOSConfig'
			},
			msg: {
				obj: 'config.iosConfig',
				OBJ: 'IOSConfig'
			}
		});
	}
	if (errObj) {
		logger.error(error.getMsgForLoggerFromErr(errObj));
		utility.killProcess(errObj);
	}

	const images = globalData.get('iosConfig.iosConfig.input.images');
	utility.throwsNoSuchFile(globalData.get('iosConfig.iosConfig.input.playerZip'), 'zip');
	utility.throwsNoSuchDir(globalData.get('iosConfig.iosConfig.input.scripts'));
	utility.throwsNoSuchDir(globalData.get('iosConfig.iosConfig.input.assets'));
	utility.throwsNoSuchDir(images);
	utility.pngImagesControl(images);
	_.each(globalData.get('iosConfig.iosConfig.input.plugins'), function(item) {
		utility.throwsNoSuchFile(item.path, 'zip');
	});
}
// control iosconfig and config2 objects.
function control_Config2_IosConfig() {
	const iosConfig = globalData.get('iosConfig.iosConfig');
	const config2 = globalData.get('iosConfig.config2');
	const key = globalData.get('iosConfig.tripleDes.key');

	if (key.length !== 24) {
		var errObj = error.getObject('tripleDesKey');
		errObj.msg += ' Key Length: ' + key.length;
		logger.error(error.getMsgForLoggerFromErr(errObj));
		utility.killProcess(errObj);
	}
	else {
		utility.controlProperties(config2, 'config.config2');
		utility.controlProperties(iosConfig, 'config.iosConfig');
	}
	controliOSConfig();
}

module.exports = IosPublisher;
