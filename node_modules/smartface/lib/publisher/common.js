const fs = require('fs');
const path = require("path");

const _ = require("lodash");
const rmdir = require("rmdir");
const projectJSONCombiner = require("project-json-combiner");

const mixOne = require("./mix-objects").one;
const Workspace = require("./indexWorkspace");
const globalData = require('../globalData');
const util = require('../utility');
const createDummyPromise = util.createDummyPromise;
const error = require("../error");
const md5File = require("./managefiles").md5.file;
const crtContentZip = require("./createContentZip");

// prepare combined project.json for rau.
function prepareTemplateCombinedProjectJSON(projectjSon, mixedRauBinaries, os, revision) {
  var promiseArr = [];

  delete projectjSon.config.rau.channels;
  projectjSon.config.rau.revision = revision;

  promiseArr.push(prepareAndAddFilesIndex(projectjSon, os));
  promiseArr.push(addBinaries());

  function addBinaries() {
    var player = null;
    var plugins = [];
    var binaryPromiseArr = [];
    projectjSon.config.rau.binary = {};
    var bin = projectjSon.config.rau.binary;
    if (os === "iOS") {
      player = globalData.get("iosConfig.iosConfig.input.playerZip");
      plugins = globalData.get("iosConfig.iosConfig.input.plugins");
    }
    else if (os === "Android") {
      player = globalData.get("androidConfig.androidConfig.input.extractor.inputApk");
      plugins = globalData.get("androidConfig.androidConfig.input.plugins");
    }
    mixOne(bin, {
      "player": {}
    });
    mixOne(projectjSon.config.rau.binary, {
      "plugins": {}
    });
    projectjSon.config.rau.binary.plugins[os] = {};

    binaryPromiseArr.push(addHashOfBinaries([player], bin.player));
    binaryPromiseArr.push(addHashOfBinaries(plugins, bin.plugins[os]));

    return Promise
      .all(binaryPromiseArr)
      .then(res => {
        mixOne(mixedRauBinaries.players, bin.player);
        mixOne(mixedRauBinaries.plugins[os], bin.plugins[os]);
        return res;
      }, err => {
        throw err;
      });
  }

  return Promise.all(promiseArr);
}

//indexing project files.
// return promise of result.
function prepareAndAddFilesIndex(metaObj, os, isRau) {
  const wsIndexing = new Workspace({
    path: globalData.get('args').projectRoot
  });
  isRau && wsIndexing.setGlobalOptions({
    path: globalData.get('args').projectRoot,
    rau: true
  });
  return new Promise((resolve, reject) => {
    wsIndexing.getIndex({
      os: os
    }, function(index) {
      if (index.errors) {
        reject(getWsIndexingErrorsObject(index.errors));
      }
      else {
        metaObj.files = index.files;
        resolve(index);
      }
    });
  });
}
//private
function addHashOfBinaries(binaries, metaObj) {
  var promiseArr = [];
  binaries.forEach(item => {
    promiseArr.push(md5File(item.path ? item.path : item));
  });
  return Promise
    .all(promiseArr)
    .then(hashes => {
      binaries.forEach((item, index) => {
        metaObj[path.basename(item.path ? item.path : item)] = hashes[index];
      });
      return hashes;
    }, err => {
      throw err;
    });
}
//private
function getWsIndexingErrorsObject(errors) {
  var msgs = [];
  errors.forEach(function(item) {
    msgs.push(item.type + " -> " + item.details.name + "\n\t └─ " + item.details.fullPath);
  });
  return error.getObject("android.imageName", {
    msg: {
      msg: "\n\t" + msgs.join("\n\t")
    }
  });
}

function combineProjectJSON(projectjSon) {
  return new Promise((resolve, reject) => {
    projectJSONCombiner.getProjectJSON(path.join(globalData.get('args')
      .projectRoot, "config"), fs, function(err, _projectJSON) {
      if (err) {
        return reject(error.getObject("combineProjectJSON", {
          msg: {
            msg: err.message
          },
          helpForUser: {
            file: err.currentFile
          }
        }));
      }
      resolve(_projectJSON);
    });
  });
}

function cleanup() {
  return new Promise((resolve, reject) => {
    util.writeJsonMsgToStdout("Cleaning temporary files...");
    rmdir(globalData.get('moduleGlobals.tmpdir'), function(err) {
      if (err) {
        return reject(err);
      }
      util.writeJsonToStdout({
        msg: 'Publish process complete.',
        allDone: true
      });
      resolve("finished.");
    });
  });
}

// prepare rau.json to update server.
function prepareAndWriteRauJson(publishConfig, projectjSon) {
  if (publishConfig.justPublish) {
    return createDummyPromise();
  }
  var rau_JSON = {};
  util.writeJsonMsgToStdout("Preparing rau.json...");
  var rau = _.cloneDeep(publishConfig.configRAU);
  rau.os = new Array();
  publishConfig.iOS && rau.os.push("iOS");
  publishConfig.android && rau.os.push("Android");
  delete rau.currentReleaseChannel;
  var outputFile = path.join(publishConfig.TMP_DIR, "rau.json");

  return new Promise((resolve, reject) => {
    prepareAndAddFilesIndex(rau_JSON, null, true).then(index => {
      _.extend(rau, {
        "binary": publishConfig.mixedRauBinaries
      });
      _.extend(rau_JSON, {
        "info": projectjSon.info,
        "rau": rau
      });
      fs.writeFile(outputFile, JSON.stringify(rau_JSON), function(err) {
        if (err) {
          return reject(err);
        }
        publishConfig.willBeUploadedFiles.push(outputFile);
        resolve(rau_JSON);
      });
    }, err => {
      throw err;
    });
  });
}
//prepare contentzip for rau.
function prepareContentZip(publishConfig) {
  if (publishConfig.justPublish) {
    return createDummyPromise();
  }

  var wsPath = globalData.get('args').projectRoot;
  util.writeJsonMsgToStdout("Preparing content.zip...");
  var options = getLicenseTypeAndKey();

  return crtContentZip(wsPath, {
    targetPath: publishConfig.TMP_DIR + "/content.zip",
    isDemo: options.isDemo,
    key: options.key
  }).then(res => {
    publishConfig.willBeUploadedFiles.push(publishConfig.TMP_DIR + "/content.zip");
    return res;
  }, err => {
    throw err;
  });

  function getLicenseTypeAndKey() {
    var getLicenseTypeStr = '';
    var getKeyStr = '';
    if (publishConfig.iOS) {
      getKeyStr = 'iosConfig.tripleDes.key';
      getLicenseTypeStr = 'iosConfig.iosConfig.input.license.type';
    }
    else if (publishConfig.android) {
      getKeyStr = 'androidConfig.tripleDes.key';
      getLicenseTypeStr = 'androidConfig.androidConfig.input.license.type';
    }
    return {
      isDemo: (globalData.get(getLicenseTypeStr) === 'Demo') ? true : false,
      key: globalData.get(getKeyStr)
    };
  }
}

module.exports = {
  combineProjectJSON: combineProjectJSON,
  cleanup: cleanup,
  prepareTemplateCombinedProjectJSON: prepareTemplateCombinedProjectJSON,
  prepareAndWriteRauJson: prepareAndWriteRauJson,
  prepareContentZip: prepareContentZip
};
