const fs = require('fs');
const path = require("path");
var https = require('https');

const FormData = require('form-data');
const _ = require("lodash");
const bytes = require("bytes");
const colors = require("colors");
const forge = require("node-forge");
const ProgressInfo = require('../progressinfo.js');

const utility = require("../utility");
const md5File = require("./managefiles").md5.file;
const error = require("../error");

const isOutJSON = utility.LogStatus.getOutJson();



// upload to server.
/**
 * Upload files to server
 * @function upload
 * @param   {Array.string} array of files path that will be uploaded.
 * @param   {string} url that will be uploaded.
 * @param   {function} callback function err, response.
 * @returns { undefined } 
 */
function upload(files, options, callBack) {

    var CRLF = '\r\n';
    var taskCount = files.length;
    var hashes = {};
    var form = new FormData();
    var totalBytes = 0;
    var elapsedTime = 0;
    var maximumCharacterNum = 12;
    var repeatCh = "=";
    var proginfo = null;
    https = options.https || https;
    // files md5
    function getHash(file) {
        md5File(file, function(err, res) {
            if (err)
                throw err;
            hashes[path.basename(file)] = res;
            var name = path.basename(file);
            var options = {
                headers: {
                    "Content-MD5": forge.util.encode64(forge.util.hexToBytes(res))
                },
                combiningHeaders: true
            };
            var fileStream = fs.createReadStream(file);
            fileStream.on("data", onData);
            form.append(name, fileStream, options);
            //console.log("File: " + file);
            getFilesizeInBytes(file, (err, res) => {
                if (err)
                    throw err;
                totalBytes += res;
                writeBeautifyInfo(res, path.basename(file));
                done();
            });
        });
    }

    function onData(chunk) {
        proginfo.update(chunk.length);
    }

    //get size of file that given.
    function getFilesizeInBytes(filename, callBack) {
        fs.stat(filename, (err, stats) => {
            if (err)
                return callBack(err);
            var fileSizeInBytes = stats["size"];
            callBack(null, fileSizeInBytes);
        });
    }

    //measure speed, MB/s 
    function measureSpeed() {
        //console.log("elapsedTime: " + elapsedTime);
        return (((totalBytes) / (elapsedTime / 1000)));
    }

    function writeBeautifyInfo(res, file) {
        var str = bytes(res, {
            unitSeparator: ' ',
            thousandsSeparator: ' '
        });
        str += colors.gray(" " + repeatCh.repeat(maximumCharacterNum - str.length) + "> ");
        utility.writeJsonMsgToStdout(colors.yellow(str) + colors.cyan(file));
    }


    // remote async functions. 
    function done() {
        --taskCount;
        if (taskCount !== 0)
            return;
        startUpload();
    }

    // initializing upload call basic functions.
    function initilazeForUpload() {

        _.each(files, function(file) {
            getHash(file);
        });
    }

    // now files ready for uploading ..
    function startUpload() {
        //console.inspect(form);
        //console.inspect(form.getHeaders());
        //form.submit(url,callBack);
        _.extend(options.headers, form.getHeaders());
        //console.inspect(options);
        //form.submit(options, callBack);
        //control request.
        /*var options = {
            host: "requestb.in",
            path: "/scq3tdsc",
            headers: {
                Authorization: "awdsadasdasdasd"
            },
            method: "post"
        };
        Object.assign(options.headers,form.getHeaders());
        */
        var request = https.request(options);

        form.pipe(request);
        utility.writeJsonMsgToStdout("The total size of the files to be uploaded  : " + colors.yellow(bytes(totalBytes, {
            unitSeparator: ' ',
            thousandsSeparator: ' '
        })));
        utility.writeJsonToStdout({
            msg: "Starting upload...",
            uploading: true
        });
        var time = new Date();
        proginfo = new ProgressInfo(totalBytes, "Uploading", writer);
        proginfo.start();
        //console.time("Upload");
        request.on('response', function(res) {
            elapsedTime = new Date() - time;
            //console.timeEnd("Upload");
            var str = '';
            res.on("data", function(chunk) {
                str += chunk;
            });
            res.on("end", function() {
                if (res.statusCode !== 202) {
                    res.message = str;
                    return callBack(res);
                }
                else {
                    utility.writeJsonMsgToStdout("Uploading has been completed : " + colors.green(ProgressInfo.beautyTime(elapsedTime / 1000)));
                    utility.writeJsonMsgToStdout("Avarage speed of uploading   : " + colors.green(bytes(measureSpeed(), {
                        unitSeparator: ' ',
                        thousandsSeparator: ' '
                    }) + "/s"));
                    callBack(null, str);
                }
            });
        });

        request.on('error', function(err) {
            utility.killProcess(error.getObject("connection", {
                msg: {
                    "msg": err.message + " -> Upload Error !"
                }
            }));
        });

        proginfo.onFinish = function() {
            utility.writeJsonMsgToStdout("Awaiting response from server...");
        };
    }

    initilazeForUpload();
}

function writer(data) {
    if (isOutJSON) {
        utility.writeJsonMsgToStdout(data.replace(/\s+/g, " "));
    }
    else {
        process.stdout.write(data);
    }
}

module.exports = upload;

/*upload(['/home/ubuntu/workspace/workspace/content.zip','/home/ubuntu/workspace/workspace/README.md'],'https://portalapi.smartface.io',function(err, res){
    
    console.inspect(res);
    console.inspect(err);
});*/
