const path = require('path');

const fs = require('fs-extra');

const Zipper = require("../zipperMemory.js");
const utility = require("../utility");
const jsonlint = require("jsonlint");

var packageJson;
module.exports = movePluginFiles;


function movePluginFiles(options) {
	const root = options.path;
	const pathSmartfaceFolder = path.join(root, 'Smartface');
	const pathAppDelegateMM = path.join(pathSmartfaceFolder, 'SmartfaceAppDelegate.mm');
	const pathSmartfacePbxproj = path.join(root, 'Smartface.xcodeproj', 'project.pbxproj');
	const pathPackageJson = path.join(root, 'package.json');
	const pathPluginsFolder = path.join(pathSmartfaceFolder, 'Plugins');

	killIfDoesntExists(pathPackageJson, "file", "json", "'package.json' must be there.");
	killIfDoesntExists(pathAppDelegateMM, "file", "mm");
	killIfDoesntExists(pathSmartfacePbxproj, "file", "pbxproj");
	killIfDoesntExists(pathPluginsFolder, "dir");

	try {
		const packageJsonStr = fs.readFileSync(pathPackageJson, 'utf8');
		packageJson = jsonlint.parse(packageJsonStr);
	}
	catch (e) {
		if (typeof e !== "string") {
			e = e.toString();
		}
		killDueToError('Package.json Parse Error', e.replace(/\n/gm, "\n\t"));
	}
	if (!packageJson.name) {
		killDueToError("Name Error", 'on package.json, missing \'name\' property. ');
	}

	const zipName = packageJson.name + ".zip";
	const outputPath = path.join(root, zipName);
	packageJson.zipFiles = [packageJson.name + '.zip'];

	//updated package.json
	fs.writeFileSync(pathPackageJson, JSON.stringify(packageJson, null, 2), 'utf8');

	const dontCopy = ['dir.info', 'libAdmobDisabled.a', 'libAdmobEnabled.a',
		'SMFApplication.h', 'SMFApplication.m'
	];
	const pluginFiles = utility.searchFilesInDirRec(pathPluginsFolder);

	generateInternalZip().then(function(data) {

		createExternalZip(data).then(function(res) {
			utility.writeJsonToStdout({
				pluginDone: true,
				msg: "Your plugin zip file has been created.",
				downloadFilePath: outputPath
			});
		}, function(err) {
			killDueToError("Unexpected Error", err);
		});

	}, function(err) {

		killDueToError("Unexpected Error", err);

	});


	function killDueToError(err, msg) {
		utility.killProcess({
			err: err,
			msg: msg
		});
	}

	function generateInternalZip() {
		const zipperInternal = new Zipper();

		pluginFiles.forEach(function(file) {

			if (dontCopy.indexOf(path.basename(file)) === -1) {
				zipperInternal.addEditFile(path.relative(pathPluginsFolder, file),
					fs.readFileSync(file));
			}

		});

		return zipperInternal.zip.generateAsync({
			type: 'nodebuffer',
			platform: 'UNIX',
			compression: "DEFLATE"
		});

	}

	function createExternalZip(internalZipBuffer) {
		const externalZipper = new Zipper();

		externalZipper.addEditFile(zipName, internalZipBuffer);

		[pathSmartfacePbxproj, pathAppDelegateMM, pathPackageJson].forEach(function(file) {
			try {
				fs.statSync(file);
			}
			catch (e) {
				killDueToError("Missing File Error", 'File does not exist:' + file);
			}
			externalZipper.addEditFile(path.basename(file), fs.readFileSync(file));
		});

		return externalZipper.createZip(outputPath);
	}

	function killIfDoesntExists(_path, fileOrDir, fext, message) {
		var msg = "You should check project files.";
		if (message) {
			msg = message;
		}
		if (fileOrDir === "file") {
			utility.throwsNoSuchFile(_path, fext, msg);
		}
		else {
			utility.throwsNoSuchDir(_path, msg);
		}
	}

	/*
		@unused
		function handleMainClass(mainClass) {
			importLines.push("#import \"" + mainClass.class + ".h\"");
			const prefix = (mainClass.isView && mainClass.isView === true) ? ESPRAT_SMFCreateViewJS : ESPRAT_SMFCreateJSInterface;
			handleImplementationLine(prefix, mainClass);
			const scopedClasses = mainClass.scopedClasses;
			if (scopedClasses) {
				scopedClasses.forEach(handleScopedClass);
			}
		}

		function handleScopedClass(scopedClass) {
			importLines.push("#import \"" + scopedClass.class + ".h\"");
			const prefix = (scopedClass.isView && scopedClass.isView === true) ? ESPRAT_SMFCreateViewJS : ESPRAT_SMFCreateJSInterface;
			handleImplementationLine(prefix, mainClass);
		}

		function handleImplementationLine(prefix, classParent) {
			const line = EspratLines(prefix, classParent);
			implementationLines.push(line);
		}

		function EspratLines(prefix, classParent) {
			return line = prefix + classParent.class + '") refString:@"' + classParent.class + '"];';
		}
	*/
}
