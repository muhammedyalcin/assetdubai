const path = require('path');
const child_process = require('child_process');
const async = require('async');
const _ = require('lodash');
const common = require('./generate_CommonPluginZip');
const getJavaPath = require('../check').EnvDep.getJavaPath;
const fs = require("fs");
const checkApplicationClass = require("./checkApplicationClass");
const utility = require("../utility");
const rmdir = require("rmdir");
const fs_extra = require('fs-extra');

const PLAYERS_BIN_FOLDER = path.normalize(__dirname + '/../../bin/');

function decompileApk(options, callback) {
    utility.throwsNoSuchFile(options.apkPath, null, "ensure that 'apkPath' is correct. ");
    var parameters = [
        '-Duser.language=en ',
        '-jar', PLAYERS_BIN_FOLDER + 'apktool.jar',
        'd',
        '-f', options.apkPath,
        '-o', options.pathToDecompileApk
    ];
    if (options.Xmx) {
        parameters.unshift('-Xmx' + options.Xmx);
    }
    const child = child_process.spawn(options.java_path, parameters);
    var isCallbackCalled = false;
    child.stderr.on('data', function(data) {
        if (data.toString().match(/Cleaning up unclosed ZipFile/)) {
            return;
        }
        if (!isCallbackCalled) {
            isCallbackCalled = true;
            callback(data.toString());
        }
    });
    child.on('close', function() {
        if (!isCallbackCalled)
            callback(null);
    });
}

function facade(options, all_done) {
    const extended_options = {
        os: 'Android',
        path: process.cwd(),
        playerPath: PLAYERS_BIN_FOLDER + 'SmartfacePlayer.apk',
        backupPath: options.path
    };
    options = _.extend(extended_options, options);
    getJavaPath(function(java_path) {
        if (!java_path) {
            return all_done('Java was not found on this system');
        }
        options.java_path = java_path;
        run(options, all_done);
    });
    options.pathToDecompileApk = path.join(options.path, 'apk');
}

function checkApplicationClassSuper(options, callback) {
    const checkResult = checkApplicationClass({
        readFileSync: fs.readFileSync,
        basePath: options.pathToDecompileApk
    });
    if (!checkResult) {
        callback(checkApplicationClass.errorText);
    }
    else {
        callback(null, "Application Class is OK");
    }
}

function removeConflictingSmaliFiles(options, callback) {
    var decompiledFolders = fs.readdirSync(options.pathToDecompileApk);
    var smaliFolders = [];
    decompiledFolders.forEach(function(folder) {
        if (folder.toString().indexOf("smali") > -1) {
            smaliFolders.push(folder);
        }
    });
    smaliFolders.forEach(function(smaliFolder) {
        fs_extra.removeSync(path.join(options.pathToDecompileApk, smaliFolder, "io", "smartface", "android"));
        fs_extra.removeSync(path.join(options.pathToDecompileApk, smaliFolder, "io", "smartface", "plugin"));
        fs_extra.removeSync(path.join(options.pathToDecompileApk, smaliFolder, "io", "smartface", "SmartfaceDemo"));
        fs_extra.removeSync(path.join(options.pathToDecompileApk, smaliFolder, "android", "support", "design"));
        fs_extra.removeSync(path.join(options.pathToDecompileApk, smaliFolder, "android", "support", "annotation"));
        fs_extra.removeSync(path.join(options.pathToDecompileApk, smaliFolder, "android", "support", "v4"));
        fs_extra.removeSync(path.join(options.pathToDecompileApk, smaliFolder, "android", "support", "v7"));
        fs_extra.removeSync(path.join(options.pathToDecompileApk, smaliFolder, "android", "support", "graphics"));
        fs_extra.removeSync(path.join(options.pathToDecompileApk, smaliFolder, "android", "support", "multidex"));
        fs_extra.removeSync(path.join(options.pathToDecompileApk, smaliFolder, "com", "google", "android", "gms"));
    });
    callback(null, "Removed conflicting smali files.");
}


function createTempFolderCopyPackageJson(options, callback) {

    try {
        var beforeTemp = options.path;
        var packageJsonPath = path.join(beforeTemp, "package.json");
        options.path = path.join(options.path, ".tmp");
        options.pathToDecompileApk = path.join(options.path, "apk");
        utility.throwsNoSuchDir(beforeTemp, "ensure that 'path' is correct");
        utility.throwsNoSuchFile(packageJsonPath, "json", "'package.json' must be there.");
        rmdir(options.path, (err) => {
            if (err && err.code !== "ENOENT") {
                return callback(err);
            }
            fs.mkdirSync(options.path);
            fs.writeFileSync(path.join(options.path, "package.json"), fs.readFileSync(packageJsonPath));
            callback(null, "Temp folder created");
        });
    }
    catch (e) {
        if (e.code == 'ENOENT') {
            callback('You must have created package.json under your target path.', null);
        }
        else {
            callback(e, null);
        }
    }
}

function deleteTempFolder(options, callback) {
    try {
        rmdir(options.path);
        callback(null, "Temp folder deleted");
    }
    catch (e) {
        callback(e, null);
    }
}

function moveLib(libfrom, libto, libPath) {
    var resPromises = [],
        libfromPath = path.join(libPath, libfrom),
        libtoPath = path.join(libPath, libto);

    resPromises.push(utility.isExistsFileDir(libfromPath));
    resPromises.push(utility.isExistsFileDir(libtoPath));

    return new Promise((resolve, reject) => {
        Promise
            .all(resPromises)
            .then(res => {
                if (res[1].existing && res[1].dir) {
                    utility.writeJsonToStdout({
                        warning: "Skipped Command -> --moveLib " + libfrom + "," + libto,
                        msg: libto + " already exists."
                    });
                    return resolve(null);
                }
                if (res[0].existing && res[0].dir) {
                    utility.writeJsonMsgToStdout("Moving lib folder " + libfrom + " --> " + libto);
                    fs.rename(libfromPath, libtoPath, function(err) {
                        if (err) return reject(err);
                        resolve(null);
                    });
                }
                utility.writeJsonToStdout({
                    warning: "Skipped Command -> --moveLib " + libfrom + "," + libto,
                    msg: libfrom + " does not exist."
                });
                return resolve(null);

            });
    });

}

function moveLibs(libsArgs, libPath, callback) {
    var resPromises = [];

    libsArgs && libsArgs.forEach(item => {
        var libs = item.split(",");
        if (libs.length === 2) {
            resPromises.push(moveLib(libs[0], libs[1], libPath));
        }
        else {
            utility.writeJsonToStdout({
                warning: "Invalid Parameter Value",
                msg: "--moveLib " + item,
                helpForUser: "You should use --moveLib lib1,lib2"
            });
        }
    });

    Promise
        .all(resPromises)
        .then(res => {
            callback(null);
        }, err => {
            callback(err);
        });
}

function run(options, all_done) {
    var outputPath;
    async.series([
            function(callback) {
                utility.writeJsonMsgToStdout('Creating temp folder...');
                createTempFolderCopyPackageJson(options, callback);
            },
            function(callback) {
                utility.writeJsonMsgToStdout('Creating folder structures...');
                common.createFolderStructure(options, callback);
            },
            function(callback) {
                utility.writeJsonMsgToStdout('Checking package.json file..');
                common.checkAndCreatePackageJSON(options, callback);
            },
            function(callback) {
                utility.writeJsonMsgToStdout('Extracting player file...');
                decompileApk(options, callback);
            },
            function(callback) {
                moveLibs(options.moveLib, path.join(options.pathToDecompileApk, "lib"), callback);
            },
            function(callback) {
                utility.writeJsonMsgToStdout('Checking AndroidManifest.xml file...');
                checkApplicationClassSuper(options, callback);
            },
            function(callback) {
                utility.writeJsonMsgToStdout('Removing conflict smali files...');
                removeConflictingSmaliFiles(options, callback);
            },
            function(callback) {
                utility.writeJsonMsgToStdout('Validating package...');
                common.validatePackage(options, callback);
            },
            function(callback) {
                utility.writeJsonMsgToStdout('Creating plugin zip file...');
                common.createZipFileFromFolder(options, function(err, res) {
                    if (!err) {
                        outputPath = res;
                    }
                    callback(err);
                });
            },
            function(callback) {
                utility.writeJsonMsgToStdout('Cleaning temp files...');
                deleteTempFolder(options, callback);
            }
        ],
        function(err, results) {
            if (err) {
                deleteTempFolder(options, function() {});
                utility.writeJsonToStdout({
                    err: "Unexpected Error",
                    msg: err
                });
            }
            else {
                utility.writeJsonToStdout({
                    pluginDone: true,
                    msg: "Your plugin zip file has been created.",
                    downloadFilePath: outputPath
                });
            }
            all_done(null, null);
        });
}

module.exports = facade;
