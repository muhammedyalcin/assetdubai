/**
 * @file Zip library, Zip operations: edit, add, remove files and zip , unzip
 * 	- add files or folder
 *	- remove files or folder
 *	- edit files or folder
 *   - zip or unzip files.
 * @description Zipper Module This module achieved files and folders zip operations.
 
 * @version 1.0.0
 
 * 	@requires module:jszip
 * 	@requires module:fs
 */
const os = require("os");
const spawnSync = require("child_process").spawnSync;
const cpRunner = require("./childProcessRunner");
const path = require("path");
const fs = require('fs-extra');

const JSZip = require('jszip');
const AdmZip = require('adm-zip');
const globalData = require('./globalData');
const utility = require("./utility");

const mkdirpSync = utility.mkdirpSync;

/**
 *	Creates new zipper ,files and folders of zip_operations of class.
 * @constructor Zipper
 *
 */

const Zipper = function() {
	var tmpdir =  globalData.get("moduleGlobals.tmpdir");
	this._sourceZip = null;
	this._zipFolder = path.join(tmpdir, "zipper_" + utility.guid());
	mkdirpSync(this._zipFolder);
	/**
	 * instance of JSzip object
	 *@memberof Zipper
	 */
};
/**
	* Add / Edit file in the current Zipper object. 
	* If file isn't exist add new file.
	* @method addEditFile
	* @this Zipper
	* @param   {string} filename file that edited.
	* @param   {string}  content content of file that edited.
	* @returns { Zipper } this
	  @memberof Zipper
	*/
Zipper.prototype.addEditFile = function(filename, content) {
	mkdirpSync(path.join(this._zipFolder, filename, ".."));
	fs.writeFileSync(path.join(this._zipFolder, filename), content);
	return this;
};


Zipper.prototype.file = function(fileName, data) {
	if (arguments.length !== 1)
		return this.addEditFile(fileName, data);
	try {
		fs.statSync(path.join(this._zipFolder, fileName));
		return fs.readFileSync(path.join(this._zipFolder, fileName), "utf8");
	}
	catch (e) {}
	if (this._sourceZip) {
		var resSpawn = spawnSync("unzip", ['-o', this._sourceZip, fileName, "-d", this._zipFolder]);
		if (resSpawn.error) {
			throw Error("File does not exists in zipfile -> ", fileName);
		}
		return fs.readFileSync(path.join(this._zipFolder, fileName), "utf8");
	}
};
/**
	* Test zipper arguments must be  fileName (filePath)
		add files and create 'test.zip' file.
		files unlimited.
	* @method testZip
	* @this Zipper
	* @param   {string}  filePath file that added
	  @returns { Zipper }  this
	  @memberof Zipper
	*/
/*
Zipper.prototype.testZip = function() {
	this.zip.folder('test');

	for (var i in arguments) { // add each file zip folder.
		this.zip.file(arguments[i], fs.readFileSync(arguments[i], 'utf-8'));
		console.log(arguments[i]);
	}
	const buffer = this.zip.generate({
		type: "nodebuffer"
	});
	fs.writeFileSync("test.zip", buffer);
	return new JSZip();
};
*/
/**
	* Control file is in  this zipper object. 
	* @method isInFile
	* @this Zipper
	* @param   { string  }  filename file that searched.
	* @returns { boolean } if this file is in zipper returns true otherwise false. 
	  @memberof Zipper
	*/
/*
Zipper.prototype.isInFile = function(fileName) {
	var res = true;
	var resSpawn = spawnSync("unzip", ['-o', '-v', zipPath, outPath]);
	if (resSpawn.error) {
		return false;
	}
	try {
		fs.statSync(path.join(this._zipFolder, fileName));
	}
	catch (e) {
		res = false;
	}
	return res;
};
*/
/**
	* Add fileto folder in the current Zipper object. 
	* @method addFileToFolder
	* @this Zipper
	* @param   {string} filename filename that will be added in current zipper.
	* @param   {string} filePath file that added.
	* @param   {string} folderPath  to the folder in current zipper.
	* @returns { Zipper } this
	  @memberof Zipper
	*/
Zipper.prototype.addFileToFolder = function(fileName, filePath, folderPath) {
	const _folderPath = path.join(this._zipFolder, folderPath);
	mkdirpSync(_folderPath);
	fs.copySync(filePath, path.join(_folderPath, fileName), {
		overwrite: true
	});
	return this;
};

/**
	* Add folder in the current Zipper object. 
	* @method addFolder
	* @this Zipper
	* @param   {string} folderPath folder that added.
	* @returns { Zipper } this
	  @memberof Zipper
	*/
Zipper.prototype.addFolder = function(foldername) {
	const _folderPath = path.join(this._zipFolder, foldername);
	mkdirpSync(_folderPath);
	return this;
};



/**
	* Delete a file or folder (recursively).
	* @method remove
	* @this Zipper
	* @param   {string} filePath File or Folder  that will be deleted.
	* @returns { Zipper } this
	  @memberof Zipper
	*/
Zipper.prototype.remove = function(filePath) {
	fs.removeSync(filePath);
	return this;
};

/**
	* Create a zip file.
	* @method createZip
	* @this Zipper
	* @param   {string} zipFilePath zip file that will be created.
	* @returns {Promise} promise with this
	  @memberof Zipper
	*/
Zipper.prototype.createZip = function(zipFilePath) {
	var files = fs.readdirSync(this._zipFolder);
	var update = false;
	if (this._sourceZip) {
		update = true;
		mkdirpSync(path.join(zipFilePath, ".."));
		fs.copySync(this._sourceZip, zipFilePath);
	}
	var options = {
		cwd: this._zipFolder,
		cmd: "zip",
		opt: {
			cwd: this._zipFolder
		},
		args: [(update ? "-ur" : "-r"), zipFilePath].concat(files)
	};
	return cpRunner(options).then(res => {
		return zipFilePath;
	}, err => {
		throw err;
	});
};

/**
	* Read a zip file in the current folder on Zipper Object.
	* @method readZip
	* @this Zipper
	* @param   {string} zipFilePath  zip file that will be read.
	* @returns { Promise } If it loads succesfully content returns res=zipperObject.    
	  @memberof Zipper
	*/
Zipper.prototype.readZip = function(zipFilePath) {
	this._sourceZip = zipFilePath;
};


/**
	* Add files in the current Zipper object from  that given folder. 
	* @method addFilesFromFolder
	* @this Zipper
	* @param   {string} folderPath folderpath that containing the files that will be added.
	* @returns { Zipper } this
	  @memberof Zipper
	*/
Zipper.prototype.addFilesFromFolder = function(folderPath) {


	const files = fs.readdirSync(folderPath);
	for (var i = 0; i < files.length; ++i) {
		//this.zip.file(files[i], fs.readFileSync(folderPath + '/' + files[i
		fs.copySync(path.join(folderPath, files[i]), path.join(this._zipFolder, files[i]), {
			overwrite: true
		});
	}
	return this;
};
/**
	* Add folder in the current Zipper object and   files that given folder and sub folder. 
	* @method addFilesFromFolderToFolder
	* @this Zipper
	* @param   {string} folderName folder that will be added.
	* @param   {string} folderPath folderpath that containing the files that will be added.
	* @returns { Zipper } this
	  @memberof Zipper
	*/
Zipper.prototype.addFilesFromFolderToFolder = function addFilesFromFolderToFolder(foldername, folderPath) {
	const files = fs.readdirSync(folderPath),
		folder = path.join(this._zipFolder, foldername);
	for (var i = 0; i < files.length; ++i) {
		if (fs.statSync(folderPath + '/' + files[i]).isDirectory()) {
			addFilesFromFolderToFolder.call(this, foldername, folderPath + '/' + files[i]); // call recursively.
		}
		else {
			fs.copySync(path.join(folderPath, files[i]), path.join(folder, files[i]), {
				overwrite: true
			});
		}
	}
	return this;
};
/**
	* Add folder in the current Zipper object and   files that given folder and sub folder. 
	* @method addFolderToFolder
	* @this Zipper
	* @param   {string} folderName folder that will be added.
	* @param   {straddFolderToFoldering} folderPath folderpath that containing the files that will be added.
	* @returns { Zipper } this
	  @memberof Zipper
	*/
Zipper.prototype.addFolderToFolder = function addFilesFromFolderToFolder(foldername, folderPath) {
	const files = fs.readdirSync(folderPath);
	var folder = path.join(this._zipFolder, foldername);
	for (var i = 0; i < files.length; ++i) {
		if (fs.statSync(folderPath + '/' + files[i]).isDirectory()) {
			addFilesFromFolderToFolder.call(this, foldername + "/" + files[i], folderPath + '/' + files[i]); // call recursively.
		}
		else {
			//folder.file(files[i], fs.readFileSync(folderPath + '/' + files[i]));
			fs.copySync(path.join(folderPath, files[i]), path.join(folder, files[i]), {
				overwrite: true
			});
		}
	}
	return this;
};
/**
	* Extract zip file   in folder. 
	* @method extract
	* @this Zipper
	* @param   {string} zipPath path of zip file that will be extracted.
	* @param   {string} outPath destination path..
	* @returns { undefined } undefined
	  @memberof Zipper
	*/
Zipper.prototype.extract = function(zipPath, outPath) {
	var zip = new AdmZip(zipPath);
	if (os.platform() === "darwin") {
		var res = spawnSync("ditto", ['-xk', '-v', zipPath, outPath]);
		if (res.error) {
			console.log("ERROR extracting with ditto ", res.error);
		}
	}
	else {
		zip.extractAllTo(outPath, /*overwrite*/ true);
	}
};

module.exports = Zipper;
