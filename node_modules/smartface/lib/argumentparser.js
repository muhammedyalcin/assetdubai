const path = require('path');

const _ = require('lodash');

const utility = require('./utility');
const requireJSON = require('./requireJSON');
const logger = require('./log/log4j').getLogger('ArgumentParser');
const checker = require('./check');
const error = require('./error');
const globalData = require('./globalData');
const argumentParserUtils = require('./argumentparser-utils');

const killProcess = utility.killProcess;
const getBuildTimestamp = utility.getBuildTimestamp;
const convert = utility.convertAbsolute.convert;

const pluginsParse = argumentParserUtils.pluginsParse;

function parse() {
	const argv = globalData.get('args');
	const platform = argv.platform;
	var args = {},
		publishConfig;
	if (/rau:/i.test(argv.task)) { // if rau task ?
		publishConfig = parseForTask(argv.task, "rau"); // parse rau param detect os.
		argv.task = "rau";
		argv.token && (publishConfig.token = argv.token);
		argv.clisecret && (publishConfig.clisecret = argv.clisecret);
		publishConfig.justPublish = false;
	}
	else if (/publish:/i.test(argv.task)) { // if publish task.
		publishConfig = parseForTask(argv.task, "publish"); // parse rau param detect os.
		argv.task = "publish";
		publishConfig.justPublish = true;
		publishConfig.channels = parseChannells(argv.channels);
		argv.token && (publishConfig.token = argv.token);
		argv.clisecret && (publishConfig.clisecret = argv.clisecret);
	}
	else if (/test:/i.test(argv.task)) {
		publishConfig = parseForTask(argv.task, "test"); // parse test param detect os.
		argv.task = "test";
		argv.token && (publishConfig.token = argv.token);
		argv.clisecret && (publishConfig.clisecret = argv.clisecret);
		publishConfig.justPublish = true;
		publishConfig.sendToTest = true;
		argv.iosTPID && (publishConfig.iosTPID = argv.iosTPID);
		argv.androidTPID && (publishConfig.androidTPID = argv.androidTPID);
		publishConfig.channels = parseChannells(argv.channels);
	}
	else if (/enterprise:/i.test(argv.task)) {
		publishConfig = parseForTask(argv.task, "enterprise"); // parse store param detect os.
		argv.task = "enterprise";
		argv.token && (publishConfig.token = argv.token);
		argv.clisecret && (publishConfig.clisecret = argv.clisecret);
		publishConfig.justPublish = true;
		publishConfig.sendToStore = true;
		argv.iosEPID && (publishConfig.iosEPID = argv.iosEPID);
		argv.androidEPID && (publishConfig.androidEPID = argv.androidEPID);
		publishConfig.channels = parseChannells(argv.channels);
	}
	else if (/storeSubmission:/i.test(argv.task)) {
		publishConfig = parseForTask(argv.task, "storesubmission"); // parse test param detect os.
		argv.task = "storeSubmission";
		argv.token && (publishConfig.token = argv.token);
		argv.clisecret && (publishConfig.clisecret = argv.clisecret);
		publishConfig.justPublish = true;
		publishConfig.saveBinary = true;
		publishConfig.channels = null;
	}
	globalData.set("publishConfig", publishConfig);
	argv.projectRoot = convert(argv.projectRoot || ".");
	if (argv.tempFolder) {
		argv.tempFolder = convert(argv.tempFolder);
		utility.mkdirpSync(argv.tempFolder);
	}
	checker.checkArguments(argv, platform);
	if (publishConfig) {
		publishConfig.cloudBuild = {
			provisioningProfileID: Number(argv.provisioningProfileID ? argv.provisioningProfileID : -1),
			keystoreID: Number(argv.keystoreID ? argv.keystoreID : -1)
		};
		publishConfig.androidCloudBuild = !!argv.androidCloudBuild;
		if (!utility.safeControlDirectory(argv.projectRoot)) {
			killProcess(_.extend(error.getObject('projectRoot'), {
				"fullPath": argv.projectRoot
			}));
		}
		if (platform === 'win32') {
			args = parseForWin32();
		}
		else {
			//logger.fatal('Unknown platform : ' + platform);
			args = parseForC9();
		}
	}
	utility.tmpdir.set(globalData.get("moduleGlobals.tmpdir"));

	//fs.writeFileSync("args.txt",JSON.stringify(args,null,"\t"));
	return args;
}
// parsing arguments by task.
function parseForWin32() {
	var args;
	const argv = globalData.get('args');
	const task = argv.task;
	const tmpdir = argv.tempFolder || globalData.get('moduleGlobals.tmpdir');
	const DEFAULT_OUTPUT_APK_FOLDER = tmpdir + '/SmartfacePlayer';
	const DEFAULT_INPUT_APK_FOLDER = DEFAULT_OUTPUT_APK_FOLDER;
	const DEFAULT_OUTPUT_APK = tmpdir + '/SmartfacePlayerEdited.apk';
	utility.mkdirpSync(tmpdir);
	logger.debug('start parseForWin32()  Task : ' + task);
	if (task === 'Android-publish') {
		args = _.extend(commonFullPublish('Android'), commonAndroid(argv), {
			INPUT_APK_x86: convert(argv.androidPlayerx86) || null,
			APK_TOOL: convert(argv.apkTool) || 'bin/apktool.jar',
			INPUT_APK: convert(argv.androidPlayer) || null,
			DECOMP_OUTPUT_FOLDER: DEFAULT_OUTPUT_APK_FOLDER,
			COMP_INPUT_FOLDER: DEFAULT_INPUT_APK_FOLDER,
			COMP_OUTPUT_APK: DEFAULT_OUTPUT_APK,
			SIGN_INPUT_APK: DEFAULT_OUTPUT_APK,
			OUTPUT_APK: convert(argv.outputApk) || 'Smartface Demo.apk',
			SIGN_OUTPUT_APK: null,
			SIGNER: convert(argv.signer) || 'bin/SignApk.jar',
			KEYSTORE_FILE: convert(argv.keystoreFile) || 'test-files/input/smfdefault.keystore',
			KEYSTORE_PASS: argv.keystorePass || 'smartface',
			ALIAS_NAME: argv.aliasName || 'smartface',
			KEY_PASS: argv.keyPass || 'smartface'
		});
	}
	else if (task === 'iOS-publish') {
		const outputFolder = tmpdir + "/player";
		const outputTempFolder = tmpdir + "/7";
		args = _.extend(commonFullPublish('iOS'), {
			PLAYER_ZIP: convert(argv.iosPlayer) || undefined,
			OUTPUT_ZIP: convert(argv.outputZip) || 'Smartface Demo.zip',
			outputFolder: outputFolder,
			outputTempFolder: outputTempFolder
		});
	}
	logger.debug('done parseForWin32()');
	return args;

	function commonFullPublish(platform, root) {
		return {
			PROJECT_SFPX: convert(argv.sfpx) || undefined,
			LICENSE_FILEPATH: convert(argv.licenseFile) || path.join(__dirname, '../test-files/input/data2.sfd'),
			projectRoot: argv.projectRoot,
			PLUGINS: pluginsParse(argv.plugin, platform, root),
			PROFILES: profileParse(argv.profile),
			TASK: task,
			timestamp: getBuildTimestamp()
		};
	}
}

function commonAndroid(argv) {
	return {
		JAVA: argv.java || 'java',
		MAX_JAVA_MEM: argv.maxJavaMemory || null,
		DECOMP_INPUT_APK: null
	};
}

function parseForC9(data) {
	var args = {};
	const argv = globalData.get('args');
	var publishConfig = globalData.get("publishConfig") || {};
	const task = argv.task;
	const config_json = loadConfigJson(argv);
	const root = argv.projectRoot;
	var playerPathiOS = null;
	var playerPathAnd = null;

	if (config_json.build.input.ios.playerPath) {
		playerPathiOS = config_json.build.input.ios.playerPath;
		playerPathiOS = path.join(root, playerPathiOS);
	}
	if (config_json.build.input.android.playerPath) {
		if (typeof config_json.build.input.android.playerPath === "string") {
			playerPathAnd = config_json.build.input.android.playerPath;
			playerPathAnd = path.join(root, playerPathAnd);
		}
	}
	//data.config_json = config_json;
	const NODE_MOD_ROOT = globalData.get('moduleGlobals.root') + '/';
	const BIN_ROOT = NODE_MOD_ROOT + 'bin/';
	const build = config_json.build;
	const output = build.output;
	var outputFolder, outputTempFolder;
	var playerMessage = "\n\t If you don't want give it, you can set it to null.";

	logger.debug('start parseForC9() TASK : ' + task);
	if ((task === 'Android-publish') || (publishConfig.android)) {
		if (playerPathAnd) {
			utility.throwsNoSuchFile(playerPathAnd, null, "You should check 'build.input.android.playerPath' field on project.json" + playerMessage);
		}
		const config_signer = build.input.android.sign;
		_.extend(args, commonFullPublish('Android', root, config_json));
		if (argv.outputApk) {
			outputFolder = path.dirname(argv.outputApk);
		}
		else {
			if (output.android.outputFolder) {
				outputFolder = root + '/' + output.android.outputFolder + '/' + args.timestamp + '/';
			}
			else {
				outputFolder = root + '/' + "output/Android" + '/' + args.timestamp + '/';
			}
		}
		outputFolder = convert(outputFolder);
		utility.mkdirpSync(outputFolder);
		changeOutputTempFolder();
		globalData.set('moduleGlobals.tmpdir', outputTempFolder);
		utility.tmpdir.set(outputFolder);
		const preSignedApk = outputTempFolder + '/preSigned.apk';
		const signedApk = outputTempFolder + '/signed.apk';
		_.extend(args, commonAndroid(argv), {
			APK_TOOL: convert(argv.apkTool) || BIN_ROOT + '/apktool.jar',
			outputTempFolder: outputTempFolder,
			INPUT_APK: convert(argv.androidPlayer) || playerPathAnd || BIN_ROOT + '/SmartfacePlayer.zip',
			DECOMP_OUTPUT_FOLDER: outputTempFolder + '/SmartfacePlayer',
			COMP_INPUT_FOLDER: outputTempFolder + '/SmartfacePlayer',
			COMP_OUTPUT_APK: preSignedApk,
			SIGN_INPUT_APK: preSignedApk,
			OUTPUT_APK: (argv.outputApk ? convert(argv.outputApk) : (outputFolder + config_signer.aliasName + '.apk')),
			SIGN_OUTPUT_APK: signedApk,
			ZIPALING_INPUT_APK: signedApk,
			SIGNER: convert(argv.signer) || BIN_ROOT + '/SignApk.jar',
			KEYSTORE_FILE: convert(argv.keystoreFile) || root + '/' + config_signer.keystoreFile,
			KEYSTORE_PASS: config_signer.keystorePass,
			ALIAS_NAME: config_signer.aliasName,
			KEY_PASS: config_signer.keyPass,
			Android_PLUGINS: pluginsParse(argv.plugin, "Android", root, config_json)
		});
	}
	if ((task === 'iOS-publish') || (publishConfig.iOS)) {
		// --outputZip=\"test-files/output/xcode/out_4_4.zip\"
		if (playerPathiOS) {
			utility.throwsNoSuchFile(playerPathiOS, null, "You should check 'build.input.ios.playerPath' field on project.json" + playerMessage);
		}
		_.extend(args, commonFullPublish('iOS', root, config_json));
		if (output.ios.outputFolder) {
			outputFolder = root + '/' + output.ios.outputFolder + '/' + args.timestamp + '/';
		}
		else {
			outputFolder = root + '/' + "output/iOS" + '/' + args.timestamp + '/';
		}
		outputFolder = convert(outputFolder);
		utility.mkdirpSync(outputFolder);
		changeOutputTempFolder();
		globalData.set('moduleGlobals.tmpdir', outputTempFolder);
		_.extend(args, {
			PLAYER_ZIP: convert(argv.iosPlayer) || playerPathiOS || BIN_ROOT + '/iOS_Player.zip',
			OUTPUT_ZIP: convert(argv.outputZip) || outputFolder + 'app.zip',
			outputFolder: outputFolder,
			outputTempFolder: outputTempFolder,
			iOS_PLUGINS: pluginsParse(argv.plugin, "iOS", root, config_json)
		});
	}
	
	args.config_json = config_json;
	/*if (publishConfig.justPublish && !publishConfig.channels) {
		publishConfig.channels = [config_json.config.rau.currentReleaseChannel];
	}*/
	logger.debug('done parseForC9()  TASK : ' + task);
	return args;

	function loadConfigJson(argv) {
		const DEFAULT_CONFIG_JSON_FILE = 'config/project.json';
		const config_file_path = (argv.config_file_full_path) ? argv.config_file_full_path :
			argv.projectRoot + '/' + ((!argv.config_file) ? DEFAULT_CONFIG_JSON_FILE : argv.config_file);
		try {
			return requireJSON(config_file_path);
		}
		catch (e) {
			var errObj = error.getObject('projectJSON');
			if (e.code) {
				errObj = _.extend(errObj, {
					"fullPath": path.normalize(config_file_path),
					"helpForUser": "You can use --projectRoot param to set the correct project folder."
				});
			}
			else {
				e = e.toString('utf8');
				errObj.msg = "on project.json, " + e.replace(/\n/gm, "\n\t");
				errObj.helpForUser = "You should check it.";
			}
			utility.killProcess(errObj);
		}
	}

	function commonFullPublish(platform, root, projectConfig) {
		return {
			LICENSE_FILEPATH: convert(argv.licenseFile) || path.join(__dirname, '../test-files/input/data2.sfd'),
			projectRoot: argv.projectRoot,
			PROFILES: profileParse(argv.profile),
			TASK: task,
			timestamp: getBuildTimestamp()
		};
	}

	function changeOutputTempFolder() {
		if (publishConfig.iOS || publishConfig.android) {
			if (argv.tempFolder)
				outputTempFolder = argv.tempFolder;
			else
				outputTempFolder = root + '/' + "output/.tmp";
		}
	}
}

function profileParse(profiles) {
	var resProfile = [];
	if (!_.isUndefined(profiles)) {
		if (!(profiles instanceof Array) && (profiles.replace(/ /gm, '') === '*')) {
			resProfile.push('*');
		}
		else { // only *
			!(profiles instanceof Array) && (profiles = [profiles]);
			resProfile = {
				'x86': [],
				'arm': []
			};
			utility.writeJsonToStdout({
				p: profiles
			});
			_.each(profiles, function(profile) {
				const profileJuniors = profile.split(';');
				_.each(profileJuniors, function(junior) {
					var tokenProfile = junior.split(':');
					if (tokenProfile.length === 2) {
						tokenProfile[0] = tokenProfile[0].toLowerCase();
						if (tokenProfile[0] === 'x86' || tokenProfile[0] === 'arm') {
							_.each(tokenProfile[1].split(','), function(item) {
								resProfile[tokenProfile[0]].push(item);
							});
						}
						else {
							var errObj = error.getObject('android.profileParse');
							errObj.msg += ': ' + junior;
							logger.error(error.getMsgForLoggerFromErr(errObj));
							utility.killProcess(errObj);
						}
					}
					else {
						var errObj = error.getObject('android.profileParse');
						errObj.msg += ': ' + junior;
						logger.error(error.getMsgForLoggerFromErr(errObj));
						utility.killProcess(errObj);
					}
				});

			});
		}
	}
	else {
		resProfile = {
			'arm': ['Default'],
			'x86': []
		};
	}
	return resProfile;
}

function parseForTask(param, task) {
	var helpForUser = {
		"rau": "We are supporting these oses: 'Android', 'iOS'.",
		"publish": "We are supporting 'Android' and 'iOS'.",
		"test": "We are supporting these oses: 'Android', 'iOS'.",
		"enterprise": "We are supporting these oses: 'Android', 'iOS'.",
		"storeSubmission": "We are supporting these oses: 'Android', 'iOS'."
	};
	var OSES = ['android', "ios"];
	var params = param.toLowerCase().split(":");
	if ((params.length !== 2) || (params[0] !== task)) {
		utility.killProcess(error.getObject('task', {
			msg: {
				task: param
			}
		}));
	}
	var oses = params[1].split(",");
	if (oses.length > 2) {
		utility.killProcess(error.getObject('osNum', {
			msg: {
				oses: oses.join(",")
			},
			helpForUser: {
				msg: helpForUser[task]
			}
		}));
	}
	var os = {
		android: false,
		iOS: false
	};
	_.each(oses, function(item) {
		item = item.trim();
		if (OSES.indexOf(item) === -1) {
			utility.killProcess(error.getObject('os', {
				msg: {
					os: item,
					task: task
				},
				helpForUser: {
					msg: helpForUser[task]
				}
			}));
		}
		item === "android" && (os.android = true);
		item === "ios" && (os.iOS = true);
	});
	//console.inspect(rau);
	return os;
}


function parseChannells(channels) {
	var res = null;
	if (channels) {
		if (!(channels instanceof Array) && (typeof channels === "string")) {
			res = [];
			var splitted = channels.split(",");
			_.each(splitted, function(channel) {
				channel = channel.trim();
				if (channel === "") {
					killProcessWithErrChannels();
				}
				else {
					res.push(channel);
				}
			});
		}
		else {
			killProcessWithErrChannels();
		}
	}
	return res;

	function killProcessWithErrChannels() {
		utility.killProcess(error.getObject("publish.channels", {
			msg: {
				channels: channels
			}
		}));
	}
}


module.exports = parse;
