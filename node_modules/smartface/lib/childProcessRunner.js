"use strict";
const spawn = require("child_process").spawn;

/*
 * @function childProcesRunner
 * @param {Object} opt options that will be given.
 * opt.cmd  command 
 * opt.args command of arguments
 * opt.opt  options of command
 * opt.tmpdir tempfolder that will be using in runtime.
 * @return {Promise} promise object..
 */
function childProcesRunner(_opt) {

  const opt = _opt || {};
  const options = opt;
  var isChildError = null;
  var resolver, rejecter;
  var stdio = {
    stdout: "",
    stderr: ""
  };
  var child;

  var promise = new Promise(function(resolve, reject) {
    resolver = resolve;
    rejecter = reject;
  });

  runChild();

  return promise;

  function runChild() {
    createChild([options.cmd, options.args, options.opt]);
  }

  function createChild(params) {

    child = spawn(params[0], params[1], params[2]);

    if (opt.isAddChild) {
      promise.child = child;
    }

    child.on("error", function(err) {
      isChildError = err;
    });

    child
      .stdout
      .on("data", function(chunk) {
        stdio.stdout += chunk.toString('utf8');
      });

    child
      .stderr
      .on("data", function(chunk) {
        stdio.stderr += chunk.toString('utf8');
      });

    child.on("close", function(code) {
      done(code);
    });
  }

  // done child_process.
  function done(code) {

    if (isChildError) {
      rejecter(new Error("Child was not spawned ! -> " + isChildError));
    }
    else {
      var output = stdio.stdout + stdio.stderr;
      if (code !== 0) {
        rejecter(new Error(opt.cmd + " Error -> " + output));
      }
      else {
        resolver({
          stderr: stdio.stderr,
          stdout: stdio.stdout,
          output: output,
          exitCode: code
        });
      }
    }
  }

}

module.exports = childProcesRunner;
