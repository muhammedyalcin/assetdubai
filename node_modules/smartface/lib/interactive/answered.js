const path = require('path');
const _ = require('underscore');
const inquirer = require("inquirer");
const TAG = require("../collector/tag")
const utility = require('../utility');
const XmlParser = require('../xmltojson');
const Default = require('./tag'); // get Defaults
const PACKAGE_PROFILES = TAG.PACKAGE_PROFILES;

const Answered = (function() { // answers of questions
	const WORKSPACE = Default.def.WORKSPACE;
	const TASK = Default.def.TASK;
	const LICENSE = Default.def.LICENSE;
	const ANDROID = Default.def.ANDROID;
	const iOS = Default.def.iOS;

	function helper() {
		const that = this;
		this.task = '';
		this.workSpaceType = WORKSPACE.SMFC;
		this.sfpx = '';
		this.projectRoot = '.';
		this.android = {
			java: null,
			playerArm: null,
			playerx86: null,
			packageProfiles: null,
			profiles: []
		};
		this.iOS = {
			playeriOS: null
		};
		this.chdir = null;
		this.license = null; // license name. ( Smartface Demo )
		this.licenseData = null; // license.xml
		this.licenseFolder = null; // license.file in temp.
		this.sampleProjects = '';
		this.checking = '';
		this.plugin = false;
		this.pluginName = '';
		this.pluginPath = '';
		this.plugins = [];
		this.pluginNames = [];

		this.login = {
			username: '',
			password: '',
			response: null
		};
		this.iOSPluginDeveloper = {
			path: '',
			playeriOS: ''
		};
		this.iOSPluginDeveloperCreate = {
			path: '',
			playeriOS: ''
		};
		this.androidPluginDeveloper = {
			path: '',
			playerAndroid: ''
		};
		this.setProperty = function(_key, _value) {
			_keys = _key.split('.');
			var temp = that;
			for (var i = 0; i < _keys.length - 1; i++) {
				temp = temp[_keys[i]]
			}
			temp[_keys[i]] = _value;
		}
		this.isPublishTask = function() {
			return ([TASK.ANDROID_FULL_PUBLISH, TASK.IOS_FULL_PUBLISH].indexOf(that.task) !== -1);
		};
		this.isPluginTask = function() {
			return ([TASK.GENERATE_IOS_PLUGIN, TASK.GENERATE_ANDROID_PLUGIN, TASK.CREATE_IOS_PLUGIN].indexOf(that.task) !== -1);
		};
		this.isCheckPublishRulesTask = function() {
			return ([TASK.CHECK_PUBLISH_RULES_ANDROID, TASK.CHECK_PUBLISH_RULES_IOS].indexOf(that.task) !== -1);
		};
		this.isLoggedOut = function() {
			return that.auth.loggedIn;
		};
		this.isDemoLicense = function() {
			return LICENSE.DEMO === that.license;
		};
		this.isLoggedInForLicense = function() {
			return (that.license === LICENSE.LOGIN);
		};

		this.isC9Workspace = function() {
			return (that.workSpaceType === Default.def.WORKSPACE.SMFC);
		};

		this.getPkcgProfile = function() { // profiles from PackageProfiles.xml
			const workspaceSpecificPathPart = (that.isC9Workspace()) ? 'config/Android/PackageProfiles.xml' : 'PackageProfiles.xml';
			const pkcgPath = path.join(that.projectRoot, workspaceSpecificPathPart);
			if (utility.safeControlFile(pkcgPath, 'xml')) { // xml file is exists ?
				that.android.packageProfiles = new XmlParser().parse(pkcgPath);
			} else {
				// TO DO : HANDLE ERROR
				return false;
			}
			return true;
		};

		this.getProfiles = function() {
			var armx86Profs = [ANDROID.PROFILE]; // get profiles
			that.getPkcgProfile();
			if (that.android.packageProfiles) {
				const _profiles = that.android.packageProfiles.findObjects('profile');
				var profNames = [];
				armx86Profs = [];
				_.each(_profiles, function(item) { // get avaiable profiles name.
					if(item.getAttribute(PACKAGE_PROFILES.ATTR_PROFILE_NAME_TAG)){
						profNames.push(item.getAttribute(PACKAGE_PROFILES.ATTR_PROFILE_NAME_TAG));
					}
					else{
						profNames.push(item.getAttribute(PACKAGE_PROFILES.ATTR_PROFILE_NAME_TAG_BC));
					}
				});
				_.each(['ARM - ', 'x86 - '], function(armOrx86) {
					armx86Profs.push(new inquirer.Separator());
					_.each(profNames, function(itemProfName) {
						armx86Profs.push(armOrx86 + itemProfName);
					});
				});
			}
			return armx86Profs;
		};
		this.getFitLengthProfiles = function() {
			var res = 0;
			_.each(that.android.profiles, function(item) {
				if (res < item.length) {
					res = item.length;
				}
			});
			return res;
		};
	}
	return new helper();
})();

module.exports = Answered;