const _ = require('underscore');
const rmdir = require('rmdir');
const validator = require('validator');
const Default = require('./tag');
const asker = require('./asker').asker;
const QUESTIONS = require('./asker').QUESTIONS;
const utility = require('../utility');
const UI = require('./ui');
const error = require('../error');
const answered = require('./answered');
const checker = require('../check');
const spinner = require('../spinner');
const loginModule = require('../login/lib');
const AdmZip = require('adm-zip');

var ANDROID_QUESTIONS = QUESTIONS.android;
var IOS_QUESTIONS = QUESTIONS.iOS;
var IOS_PLUGIN_QUESTIONS = QUESTIONS.iOSPluginDeveloper;
var ANDROID_PLUGIN_QUESTIONS = QUESTIONS.androidPluginDeveloper;
const convertAbsolute = utility.convertAbsolute.convert;
const errorFilePath = UI.errorFilePath;
const stdin = process.openStdin();
const UI_STATES = ['continue', 'back'];
var CLISTATE = 'continue';
var CLI_IN_VALIDATER = false;
const BACK_KEY = '\u001b'; // escape key (unicode)
var canBePressedBack = true;
var PROCESS_BUSY = false;
//stdin.setRawMode(true);

const backKeyEventListener = function(chunk, key) {
	//console.log("backkey1: ", JSON.stringify(key),(chunk == '\u001b'))
	if ((chunk == BACK_KEY) && canBePressedBack && !CLI_IN_VALIDATER && !PROCESS_BUSY) {
		CLISTATE = UI_STATES[1]; // back
		stdin.push('\r'); // break current question.
		stdin.resume();
	}
	if ((chunk == BACK_KEY) && CLI_IN_VALIDATER) { // reactived back event.
		CLI_IN_VALIDATER = false;
		stdin.push('\u001b'); // 'escape' break current question.
		stdin.resume();
	}
};

stdin.on('data', backKeyEventListener);
stdin.resume();

// control back or continue and if back key pressed, then call callback(cbParam);
function isBack(callback, cbParam) {
	var res = false;
	if (CLISTATE === UI_STATES[1]) {
		res = true;
		UI.complete();
		CLISTATE = UI_STATES[0];
		if (callback && cbParam) {
			UI.decreaseCompletedIndex();
			UI.complete();
			callback(cbParam);
		}
	}
	return res;
}
// allows back key and display hint and stdin pause
function allowBackAndHint() {
	canBePressedBack = true;
	UI.hint.enable();
}

function blockBackAndHint() {
	canBePressedBack = false;
	UI.hint.disable();
}

// fake control for validater.
function fakeValidater() {
	var res = false;
	if (CLISTATE === UI_STATES[1]) { // is pressed Back ?
		res = true;
	}
	return res;
}

function blockInputFromUser() {
	PROCESS_BUSY = true; // process state busy.
}

function allowInputFromUser() {
	setTimeout(function() {
		PROCESS_BUSY = false; // process state continue.
		stdin.push('\r'); // break fake question.
	}, 100);
}

function blockBackKey(_res) {
	if (_res !== true) {
		CLI_IN_VALIDATER = true;
	}
}

function endBackKeyEvent() {
	stdin.removeListener('keypress', backKeyEventListener);
}

// fake question for  key that pressed on process busy state
function askFake(callback) {
	asker(QUESTIONS.fake, function() {
		process.stdout.write('\033[1A'); // clear fake question output.
		process.stdout.clearLine();
		callback();
	}, {
		opt: {
			validate: function(input) {
				if (PROCESS_BUSY) {
					return false;
				}
				return true;
			}
		}
	});
}

// Ask tasks 
function askTask(callback, fake) {
	var list = Default.getList('TASK');
	if (answered.login.response) {
		list.splice(list.indexOf(Default.def.TASK.LOGIN), 1);
	}
	asker(QUESTIONS.task, callback, {
		opt: {
			choices: list,
			filter: function(input) { // remember old task.
				if (list.indexOf(input) !== -1) {
					QUESTIONS.task.default = input;
				}
				else {
					QUESTIONS.task.default = list[0];
				}
				return input;
			}
		},
		fake: fake,
		waitMsg: true
	});
}
/**
 * @unused
 * Ask workspace type
 */
function askWorkspace(callback) {
	UI.wait(QUESTIONS.workspace.description);
	asker(QUESTIONS.workspace, callback, {
		opt: {
			choices: Default.getList('WORKSPACE')
		}
	});
}

function askLogin(callback, previousAsk, previosAskCallback, fake) {
	asker(QUESTIONS.login.username, function() {
		if (isBack(previousAsk, previosAskCallback)) {
			return;
		}
		QUESTIONS.login.username.default = answered.login.username;
		asker(QUESTIONS.login.password, function() {
			if (isBack()) {
				return askLogin(callback, previousAsk, previosAskCallback);
			}
			login();
		}, {
			midObj: 'login'
		});
	}, {
		midObj: 'login',
		opt: {
			filter: function(input) {
				return input.trim();
			},
			validate: function(_input) {
				if (fakeValidater()) {
					return true;
				}
				if (validator.isEmail(_input)) {
					return true;
				}
				else {
					blockBackKey(false);
					return 'The Email field is not a valid e-mail address !';
				}

			}
		},
		fake: fake,
		waitMsg: true
	});

	function login() { // login.
		blockBackAndHint();
		blockInputFromUser();
		UI.write('yellow', '  ' + UI.message.loginWait, true);
		spinner.start();
		loginModule.login({
			"UserName": answered.login.username,
			"Password": answered.login.password
		}, function(err, res) {
			spinner.stop();
			allowBackAndHint();
			allowInputFromUser();
			if (err) {
				errorDisplayer('login.username', error.getObject('loginWrong'), true);
			}
			else {
				if (res.FullName && res.Token) {
					answered.login.response = res;
					answered.login.username = res.FullName;
					QUESTIONS.task.default = Default.def.TASK.ANDROID_FULL_PUBLISH;
					UI.complete(QUESTIONS.login.username.description);
					return callback();
				}
				else if (res.FullName === undefined || res.Token === undefined) {
					errorDisplayer('login.username', error.getObject('loginFatal'), true);
				}
				else {
					errorDisplayer('login.username', error.getObject('loginWrong'), true);
				}
			}
			askLogin(callback, previousAsk, previosAskCallback, askFake);
		});
	}
}

function askLogout(callback) {
	UI.wait(QUESTIONS.logout.description);
	asker(QUESTIONS.logout, callback);
}

function askJava(callback) {
	UI.wait(ANDROID_QUESTIONS.java.description);
	asker(ANDROID_QUESTIONS.java, callback, {
		midObj: 'android',
		opt: {
			validate: function(input) {
				input = input.trim();
				if (fakeValidater()) {
					return true;
				}
				var res = false;
				if (utility.javaControlSync(input, 1.8)) {
					res = true;
					ANDROID_QUESTIONS.java.default = input;
				}
				else {
					errorDisplayer('android.java', error.getObject('android.javaPath'));
					res = input;
				}
				blockBackKey(res);
				return res;
			}
		}
	});
}
// return absolute path.
function filterAbsolutePath(_input) {
	return convertAbsolute(_input.trim());
}

//  UI for errors
function errorDisplayer(_key, _resObj, noWait) {
	const subQuestion = utility.getSubObject(QUESTIONS, _key);
	answered.setProperty(_key, _resObj.err);
	UI.complete();
	UI.completedError(subQuestion.description);
	console.log();
	UI.error(_resObj.msg);
	if (_resObj.fullPath) {
		console.log(errorFilePath(_resObj.fullPath));
	}
	if (_resObj.helpForUser) {
		console.log('  help?: ' + _resObj.helpForUser);
	}
	console.log();
	if (!noWait) {
		UI.wait(subQuestion.description);
	}
}

function askProjectRoot(callback) {
	if (answered.isPublishTask()) {
		/*	var samples = require('./sample').getSamplePaths(validateProjectFolder);  // Advance default sample projects.
		if (samples.length !== 0) {
			QUESTIONS.projectRoot.default = samples[0];
		}*/
		UI.wait(QUESTIONS.projectRoot.description);
		asker(QUESTIONS.projectRoot, callback, {
			opt: {
				validate: function(input) { // control  with  isDirectory().
					input = input.trim();
					if (fakeValidater()) {
						return true;
					}
					var res = validateProjectFolder(input);
					if (res !== true) {
						errorDisplayer('projectRoot', res);
						res = errorFilePath(input);
					}
					return res;
				},
				filter: filterAbsolutePath
			}
		});
	}
	else {
		callback();
	}

	function validateProjectFolder(input) { // validate project folder
		const path = require('path');
		const projPath = convertAbsolute(input);
		var res = false;
		if (utility.safeControlDirectory(projPath)) {
			if (answered.workSpaceType === Default.def.WORKSPACE.DESKTOP) {
				// TO DO DESKTOP Ä±de sfpx, data control.
			}
			else {
				if (utility.safeControlFile(path.join(projPath, 'config', 'project.json'), 'json')) {
					if (utility.safeControlFile(path.join(projPath, 'config', 'Android', 'PackageProfiles.xml'), 'xml')) {
						res = true;
						QUESTIONS.projectRoot.default = projPath;
					}
					else {
						// Error handling PackageProfiles.xml
						res = error.getObject('android.packageProfiles');
					}
				}
				else {
					// Error handling project.json
					res = error.getObject('projectJSON');
				}
			}
		}
		else {
			// Error handling no such a dir
			res = error.getObject('projectRoot');
		}
		blockBackKey(res);
		return res;
	}
}
// validate input path exist and .fileExt 
function validatePlayer(_input, _key, fileExt) {
	if (fakeValidater()) {
		return true;
	}
	var res = false;
	const absolutePath = convertAbsolute(_input);
	if (utility.safeControlFile(absolutePath, fileExt)) {
		res = true;
		switch (_key) {
			case 'playerArm':
			case 'playerx86':
				ANDROID_QUESTIONS[_key].default = absolutePath;
				break;
			case 'playeriOS':
				IOS_QUESTIONS[_key].default = absolutePath;
				break;
		}
	}
	else {
		switch (_key) {
			case 'playerArm':
			case 'playerx86':
				_key = 'android.' + _key;
				break;
				3
			case 'playeriOS':
				_key = 'iOS.' + _key;
				break;
		}
		errorDisplayer(_key, error.getObject('playerPath'))
		res = errorFilePath(absolutePath);
	}
	blockBackKey(res);
	return res;
}

function askPlayerArm(callback) {
	UI.wait(ANDROID_QUESTIONS.playerArm.description);
	asker(ANDROID_QUESTIONS.playerArm, callback, {
		midObj: 'android',
		opt: {
			validate: validateArm,
			filter: filterAbsolutePath
		}
	});

	function validateArm(_input) {
		_input = _input.trim();
		return validatePlayer(_input, 'playerArm', 'apk');
	}
}

function askPlayerx86(callback) {
	UI.wait(ANDROID_QUESTIONS.playerx86.description);
	asker(ANDROID_QUESTIONS.playerx86, callback, {
		midObj: 'android',
		opt: {
			validate: validatex86,
			filter: filterAbsolutePath
		}
	});

	function validatex86(_input) {
		_input = _input.trim();
		return validatePlayer(_input, 'playerx86', 'apk');
	}
}

function askPlayeriOS(callback) {
	UI.wait(IOS_QUESTIONS.playeriOS.description);
	asker(IOS_QUESTIONS.playeriOS, callback, {
		midObj: 'iOS',
		opt: {
			validate: validateiOS,
			filter: filterAbsolutePath
		}
	});

	function validateiOS(_input) {
		_input = _input.trim();
		return validatePlayer(_input, 'playeriOS', 'zip');
	}
}

function askProfiles(callback) {
	UI.wait(ANDROID_QUESTIONS.profiles.description);
	asker(ANDROID_QUESTIONS.profiles, callback, {
		midObj: 'android',
		opt: {
			choices: answered.getProfiles(),
			validate: function(input) {
				if (fakeValidater()) {
					return true;
				}
				if (input.length === 0) {
					blockBackKey(false);
					return 'select profile !';
				}
				else {
					return true;
				}
			}
		}
	});
}

function askLicense(callback, previosAsk, previosAskCallback) {
	const selectList = Default.getList('LICENSE');
	var opt = {
		choices: selectList
	};
	UI.write('yellow', '  ' + UI.message.licenseNamesWait, true);
	spinner.start();
	blockBackAndHint();
	blockInputFromUser();
	loginModule.getLicenseNames(null, function(err, res) {
		spinner.stop();
		process.stdout.clearLine();
		if (err || !res.Licenses || res.Licenses.length === 0) {
			// TO DO  error handling.
		}
		else {
			_.each(res.Licenses, function(item) {
				opt.choices.push(item.Name);
			});
		}
		allowBackAndHint();
		allowInputFromUser();
		if (!res) {
			UI.write(UI.color.loginForLicense, '\r\n   ' + UI.message.loginForLicense);
		}
		asker(QUESTIONS.license, function() {
			if (isBack(previosAsk, previosAskCallback)) {
				return;
			}
			if (!answered.isDemoLicense()) {
				const licenseObj = _.findWhere(res.Licenses, {
					Name: answered.license
				});
				UI.write('yellow', '  ' + UI.message.licenseTokenWait, true);
				spinner.start();
				blockBackAndHint();
				blockInputFromUser();
				loginModule.getLicenseXML({
					"LicenseId": licenseObj.Id
				}, function(err, res) {
					spinner.stop();
					process.stdout.clearLine();
					if (err) {
						errorDisplayer('license', error.getObject('licenseToken'), true);
					}
					else {
						answered.licenseData = res;
						UI.complete(QUESTIONS.license.description);
						askPlugin(function(selfCallbackPlugin) {
							if (isBack(askLicense, callback)) {
								return;
							}
							callback();
						}, askLicense, callback);
					}
					askLicense(callback, previosAsk, previosAskCallback);
				});
			}
			else {
				UI.complete(QUESTIONS.license.description);
				askPlugin(function(selfCallbackPlugin) {
					if (isBack(askLicense, callback)) {
						return;
					}
					callback();
				}, askLicense, callback);
			}
		}, {
			opt: opt,
			fake: askFake,
			waitMsg: true
		});
	});

}

function askSample(callback, askCallback, fake) {
	const samples = require('./sample');
	asker(QUESTIONS.sampleProjects, function() {
		if (isBack(ask, askCallback)) { // come to ask previos.
			return;
		}
		getProjectFromGit();
	}, {
		opt: {
			choices: samples.getAvailableNames()
		},
		fake: fake,
		waitMsg: true
	});

	function getProjectFromGit() { // project clone from git.
		const git = require('./git');
		const path = require('path');
		const color = UI.color;
		const spinner = UI.spinner;
		const sampleName = answered.sampleProjects;
		const newSampleLink = samples.getAvailableLink(sampleName);
		if (newSampleLink) {
			UI.complete();
			const destDir = path.join(Default.def.SAMPLES_DIR, newSampleLink.substr(newSampleLink.lastIndexOf('/') + 1));
			const updateStr = ' ' + sampleName + ' downloading ...  ';
			console.log();
			UI.write(color.wait, updateStr, true);
			spinner.start();
			blockBackAndHint();
			blockInputFromUser();
			git.gitClone(newSampleLink, function(err) {
				spinner.stop();
				if (err) {
					allowBackAndHint();
					allowInputFromUser();
					errorDisplayer('sampleProjects', err, true);
					askSample(callback, askCallback, askFake);
				}
				else {
					UI.complete(QUESTIONS.sampleProjects.description);
					UI.pushComplete(UI.createStr(color.ok, '\n  Project was successfully downloaded.'));
					UI.pushComplete(UI.createStr(color.output, ' Folder Path: ') + UI.createStr(color.filePath, destDir));
					UI.pushComplete(' ');
					UI.complete();
					askCWDChange(function() {
						if (answered.chdir) {
							utility.convertAbsolute.setCwd(destDir);
							QUESTIONS.projectRoot.default = destDir;
						}
						blockInputFromUser();
						callback();
					});

				}
			}, destDir);
		}
		else {
			errorDisplayer('sampleProjects', error.getObject('sample.sampleProjLink'));
			askSample(callback, askCallback);
		}
	}

	function askCWDChange(_callback) {

		asker(QUESTIONS.chdir, _callback);
	}
}

function askPlugin(callback, previosAsk, previosAskCallback) {
	UI.wait(QUESTIONS.plugin.description);
	asker(QUESTIONS.plugin.confirm, function() {
		if (isBack(previosAsk, previosAskCallback)) {
			return;
		}
		if (answered.plugin) { // yes plugin will be added
			askAddPlugin(callback);
		}
		else { // no plugin
			UI.complete(QUESTIONS.plugin.description);
			callback();
		}
	});
	const convertAbsolute = utility.convertAbsolute;
	var optPath = { // plugin path and absolute path control.
		validate: function(input) {
			if (fakeValidater()) {
				return true;
			}
			var res = false;
			const absPath = utility.convertAbsolute.convert(input);
			if (utility.safeControlFile(absPath)) {
				if (utility.safeControlFile(absPath, 'zip')) {
					res = true;
				}
				else {
					res = error.getMessage('fileExt', {
						err: {
							fileExt: 'zip'
						},
						msg: {
							fileExt: 'zip'
						}
					});
				}
			}
			else {
				res = error.getMessage('fileDir', {
					err: {
						fileDir: 'File'
					},
					msg: {
						fileDir: 'file'
					}
				});
			}
			return res;
		},
		filter: function(item) {
			return item.trim();
		}
	};

	function askAddPlugin(callback) {
		UI.complete();
		UI.wait(QUESTIONS.plugin.name.description);
		asker(QUESTIONS.plugin.name, function() { // plugin name
			if (isBack()) {
				askPlugin(callback, previosAsk, previosAskCallback);
				return;
			}
			UI.complete();
			UI.wait(QUESTIONS.plugin.name.description + ' = ' + answered.pluginName);
			UI.wait(QUESTIONS.plugin.path.description);
			asker(QUESTIONS.plugin.path, function() { // plugin path.
				if (isBack()) {
					UI.complete();
					return callback();
				}
				addPlugin(); // save plugin
				UI.complete(QUESTIONS.plugin.description);
				UI.wait(QUESTIONS.plugin.more.description);
				asker(QUESTIONS.plugin.more, function() { // add one more ?
					if (isBack()) {
						UI.complete();
						return callback();
					}
					if (answered.plugin) {
						askAddPlugin(callback);
					}
					else {
						UI.complete();
						callback();
					}
				});
			}, {
				opt: optPath
			});
		});
	}

	function addPlugin() { // add current plugin into plugins.
		//dd
		switch (answered.task) {
			case Default.def.TASK.ANDROID_FULL_PUBLISH:
				checkZipForEnvironment('android', function(data) {
					if (data) {
						answered.pluginNames.push(answered.pluginName);
						answered.plugins.push(answered.pluginName + '::' + answered.pluginPath);
					}
					else {}
				});
				break;
			case Default.def.TASK.IOS_FULL_PUBLISH:
				checkZipForEnvironment('ios', function(data) {
					if (data) {
						answered.pluginNames.push(answered.pluginName);
						answered.plugins.push(answered.pluginName + '::' + answered.pluginPath);
					}
					else {}
				});
				break;
		}
	}
}

function checkZipForEnvironment(platform, callback) {
	var zip = new AdmZip(answered.pluginPath);
	var packageJsonTxt;
	var packageJson;
	try {
		packageJsonTxt = zip.readAsText("package.json");
		packageJson = JSON.parse(packageJsonTxt);
		if ((packageJson.os && packageJson.os.toLowerCase() === platform) || (packageJson.OS && packageJson.OS.toLowerCase() === platform)) {
			callback(true);
		}
		else {
			callback(false);
		}
	}
	catch (e) {
		callback(false);
	}
}

function askForAndroid(callback, projectRootCallback) {

	askProfiles(function(selfCallbackProfiles) {
		if (isBack(askProjectRoot, projectRootCallback)) { // come back askLicense
			return;
		}
		var profs = answered.android.profiles;
		if (profs.length === 0) {
			profs.push(Default.def.ANDROID.PROFILE);
		}

		UI.complete(ANDROID_QUESTIONS.profiles.description);
		askLicense(function(selfCallbackLicense) {
			if (isBack(askProfiles, selfCallbackProfiles)) { // come back askPlayerx86
				return;
			}
			callback();
		}, askProfiles, selfCallbackProfiles);
	});
}

function askForiOS(callback, projectRootCallback) {
	askLicense(function(selfCallbackLicense) {
		if (isBack(askProjectRoot, projectRootCallback)) { // come back askPlayeriOS
			return;
		}
		callback();
	}, askProjectRoot, projectRootCallback);
}

function checkEnvDep(previosAskCallback) {
	UI.wait('Checking ... ');
	spinner.start();
	checker.EnvDep.checkAll(function(err, res) {
		spinner.stop();
		if (err) {
			throw new Error(err);
		}
		UI.reset();
		UI.writeEnvDep();
		askTask(previosAskCallback);
	});
}

function askForGenerateiOSPlugin(callback, previousAsk, previosAskCallback, fake) {
	asker(IOS_PLUGIN_QUESTIONS.path, function() {
		if (isBack(previousAsk, previosAskCallback)) {
			return;
		}
		IOS_PLUGIN_QUESTIONS.path.default = answered.iOSPluginDeveloper.path || ".";
		UI.complete(IOS_PLUGIN_QUESTIONS.path.description);
		return callback();
	}, {
		midObj: 'iOSPluginDeveloper',
		opt: {
			filter: function(input) {
				return input.trim();
			},
			validate: function(input) {
				if (fakeValidater()) {
					return true;
				}
				const path = require('path');
				const projPath = convertAbsolute(input);
				var res = false;
				if (utility.safeControlDirectory(projPath)) {
					if (utility.safeControlFile(path.join(projPath, 'package.json'), 'json')) {
						res = true;
					}
					else {
						// Error handling package.json
						errorDisplayer('iOSPluginDeveloper.path', error.getObject('iOSPluginDevelop.generate.package'))
					}
				}
				else {
					// Error handling no such a dir
					errorDisplayer('iOSPluginDeveloper.path', error.getObject('projectRoot'))
				}
				return res;
			}
		},
		fake: fake,
		waitMsg: true
	});
}

function askForGenerateAndroidPlugin(callback, previousAsk, previosAskCallback, fake) {
	asker(ANDROID_PLUGIN_QUESTIONS.path, function() {
		if (isBack(previousAsk, previosAskCallback)) {
			return;
		}
		ANDROID_PLUGIN_QUESTIONS.path.default = answered.androidPluginDeveloper.path || ".";
		UI.complete(ANDROID_PLUGIN_QUESTIONS.path.description);

		asker(ANDROID_PLUGIN_QUESTIONS.playerAndroid, function() {
			if (isBack(previousAsk, previosAskCallback)) {
				return;
			}
			ANDROID_PLUGIN_QUESTIONS.playerAndroid.default = answered.androidPluginDeveloper.playerAndroid;
			UI.complete(ANDROID_PLUGIN_QUESTIONS.playerAndroid.description);
			return callback();
		}, {
			midObj: 'androidPluginDeveloper',
			opt: {
				filter: function(input) {
					return input.trim();
				},
				validate: function(input) {
					if (fakeValidater()) {
						return true;
					}
					const path = require('path');
					const projPath = convertAbsolute(input);
					var res = false;
					if (utility.safeControlFile(projPath)) {
						res = true;
					}
					else {
						// Error handling no such a dir
						errorDisplayer('androidPluginDeveloper.playerAndroid', error.getObject('playerPath'))
					}
					return res;
				}
			}
		});

	}, {
		midObj: 'androidPluginDeveloper',
		opt: {
			filter: function(input) {
				return input.trim();
			},
			validate: function(input) {
				if (fakeValidater()) {
					return true;
				}
				const path = require('path');
				const projPath = convertAbsolute(input);
				var res = false;
				if (utility.safeControlDirectory(projPath)) {
					if (utility.safeControlFile(path.join(projPath, 'package.json'), 'json')) {
						res = true;
					}
					else {
						// Error handling package.json
						errorDisplayer('androidPluginDeveloper.path', error.getObject('androidPluginDevelop.generate.package'))
					}
				}
				else {
					// Error handling no such a dir
					errorDisplayer('androidPluginDeveloper.path', error.getObject('projectRoot'))
				}
				return res;
			}
		},
		fake: fake,
		waitMsg: true
	});
}

function askForCreateiOSPlugin(callback, previosAsk, previosAskCallback, fake) {
	asker(QUESTIONS.iOSPluginDeveloperCreate.path, function() {
		if (isBack(previosAsk, previosAskCallback)) {
			return;
		}
		QUESTIONS.iOSPluginDeveloperCreate.path.default = answered.iOSPluginDeveloperCreate.path || ".";
		UI.complete(QUESTIONS.iOSPluginDeveloperCreate.path.description);
		return callback();
	}, {
		midObj: 'iOSPluginDeveloperCreate',
		opt: {
			filter: function(input) {
				return input.trim();
			}
		},
		fake: fake,
		waitMsg: true
	});
}

function askByTask(callback, previosAskCallback, askCallbackForSample) {
	switch (answered.task) {
		case Default.def.TASK.ANDROID_FULL_PUBLISH:
			answered.plugins = [];
			answered.pluginNames = [];
			askForAndroid(callback, previosAskCallback);
			break;
		case Default.def.TASK.IOS_FULL_PUBLISH:
			answered.plugins = [];
			answered.pluginNames = [];
			askForiOS(callback, previosAskCallback);
			break;
		case Default.def.TASK.LOGIN:
			var loop = true;
			askLogin(function() {
				askTask(previosAskCallback, askFake);
			}, askTask, previosAskCallback);
			break;
		case Default.def.TASK.SAMPLE:
			askSample(callback, askCallbackForSample);
			break;
		case Default.def.TASK.CHECK:
			checkEnvDep(previosAskCallback);
			break;
		case Default.def.TASK.EXIT:
			cleanTemp(function() {
				process.exit();
			});
			break;
		case Default.def.TASK.GENERATE_IOS_PLUGIN:
			askForGenerateiOSPlugin(callback, askTask, previosAskCallback);
			break;
		case Default.def.TASK.GENERATE_ANDROID_PLUGIN:
			askForGenerateAndroidPlugin(callback, askTask, previosAskCallback);
			break;
		case Default.def.TASK.CREATE_IOS_PLUGIN:
			askForCreateiOSPlugin(callback, askTask, previosAskCallback);
			break;
		case Default.def.TASK.CHECK_PUBLISH_RULES_IOS:
			askForCheckPublishRulesiOS(callback, askTask);
			break;
		case Default.def.TASK.CHECK_PUBLISH_RULES_ANDROID:
			askForCheckPublishRulesAndroid(callback, askTask);
			break;
		default:
			UI.decreaseCompletedIndex();
			errorDisplayer('task', error.getObject('task', {
				msg: {
					task: answered.task
				}
			}), true);
			callback();
	}
}

function askForCheckPublishRulesiOS(callback, askTask, previosAskCallback) {
	asker(QUESTIONS.iOSPluginDeveloperCreate.path, function() {
		if (isBack(previosAsk, previosAskCallback)) {
			return;
		}
		QUESTIONS.iOSPluginDeveloperCreate.path.default = answered.iOSPluginDeveloperCreate.path;
		UI.complete(QUESTIONS.projectRoot.description);
		return callback();
	}, {});
}

function askForCheckPublishRulesAndroid(callback, askTask) {
	asker(QUESTIONS.projectRoot, function() {
		QUESTIONS.projectRoot.default = answered.projectRoot;
		UI.complete(QUESTIONS.projectRoot.description);
		return callback();
	}, {});
}

function askForCheckPublishRulesiOS(callback, askTask) {
	asker(QUESTIONS.projectRoot, function() {
		QUESTIONS.projectRoot.default = answered.projectRoot;
		UI.complete(QUESTIONS.projectRoot.description);
		return callback();
	}, {});
}

function ask(callback, noReset) {
	if (!noReset) {
		UI.reset();
	}
	UI.complete();
	var isPublishTask = answered.isPublishTask;
	blockBackAndHint();
	askTask(function(selfCallbackTask) {
		if (isBack(ask, callback)) { // come back ask
			return;
		}
		if (noReset) {
			UI.reset();
		}
		allowBackAndHint();
		UI.complete(QUESTIONS.task.description);
		if (isPublishTask()) {
			askProjectRoot(function(selfCallbackProjectRoot) { // come back ask
				if (isBack(ask, callback)) {
					return;
				}
				UI.complete(QUESTIONS.projectRoot.description);
				askByTask(function() {
					callback();
				}, selfCallbackProjectRoot);
			});
		}
		else {
			askByTask(function() {
				callback();
			}, selfCallbackTask, callback);
		}
	});
}
// ask to continue.
function askToContinue(callback) {
	allowInputFromUser();
	asker(QUESTIONS.continue, callback, {
		fake: askFake
	});
}


function cleanTemp(callback) {
	if (answered.licenseFolder) {
		rmdir(answered.licenseFolder, function() {
			callback();
		});
	}
	else {
		callback();
	}
}

function setup(callback) {
	console.log('initilazing ... ');
	spinner.start();
	utility.cwd(function(err, dir) { // find CWD [cd, pwd ]
		if (err) {
			throw new Error('CWD Error');
		}
		else if (dir) {

			const convertAbsolute = utility.convertAbsolute;
			convertAbsolute.setCwd(dir);
			QUESTIONS.projectRoot.default = convertAbsolute.getCwd();
			checker.EnvDep.checkAll(function(err, res) {
				if (err) {
					throw new Error('Checking Error');
				}
				ANDROID_QUESTIONS.java.default = res.env.java; // set java path.
				spinner.stop();

				function askCallback() {
					const collector = require('./collector');
					blockBackAndHint();
					blockInputFromUser();
					if (answered.isPublishTask() || answered.isPluginTask() || answered.isCheckPublishRulesTask) {
						require('./run')(function() {
							cleanTemp(function() {
								askToContinue(function() {
									ask(askCallback, true);
								});
							});
						});
					}
					else {
						askToContinue(function() {
							ask(askCallback, true);
						});
					}
				}
				ask(askCallback);
			});
		}
	});
}
/*
process.on('uncaughtException', function(err) {
	utility.killProcess({
		msg: 'Process was killed.'
	});
});
*/
module.exports = setup;